{"ast":null,"code":"import { bitCode, intersect } from './lineclip';\nimport { getPointAtIndex, copy, push } from './utils';\nexport function cutPolylineByGrid(positions) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$size = options.size,\n      size = _options$size === void 0 ? 2 : _options$size,\n      _options$broken = options.broken,\n      broken = _options$broken === void 0 ? false : _options$broken,\n      _options$gridResoluti = options.gridResolution,\n      gridResolution = _options$gridResoluti === void 0 ? 10 : _options$gridResoluti,\n      _options$gridOffset = options.gridOffset,\n      gridOffset = _options$gridOffset === void 0 ? [0, 0] : _options$gridOffset,\n      _options$startIndex = options.startIndex,\n      startIndex = _options$startIndex === void 0 ? 0 : _options$startIndex,\n      _options$endIndex = options.endIndex,\n      endIndex = _options$endIndex === void 0 ? positions.length : _options$endIndex;\n  var numPoints = (endIndex - startIndex) / size;\n  var part = [];\n  var result = [part];\n  var a = getPointAtIndex(positions, 0, size, startIndex);\n  var b;\n  var codeB;\n  var cell = getGridCell(a, gridResolution, gridOffset, []);\n  var scratchPoint = [];\n  push(part, a);\n\n  for (var i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      var codeAlt = bitCode(scratchPoint, cell);\n\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n\n      push(part, scratchPoint);\n      copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\nvar TYPE_INSIDE = 0;\nvar TYPE_BORDER = 1;\nexport function cutPolygonByGrid(positions, holeIndices) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!positions.length) {\n    return [];\n  }\n\n  var _options$size2 = options.size,\n      size = _options$size2 === void 0 ? 2 : _options$size2,\n      _options$gridResoluti2 = options.gridResolution,\n      gridResolution = _options$gridResoluti2 === void 0 ? 10 : _options$gridResoluti2,\n      _options$gridOffset2 = options.gridOffset,\n      gridOffset = _options$gridOffset2 === void 0 ? [0, 0] : _options$gridOffset2,\n      _options$edgeTypes = options.edgeTypes,\n      edgeTypes = _options$edgeTypes === void 0 ? false : _options$edgeTypes;\n  var result = [];\n  var queue = [{\n    pos: positions,\n    types: edgeTypes && new Array(positions.length / size).fill(TYPE_BORDER),\n    holes: holeIndices || []\n  }];\n  var bbox = [[], []];\n  var cell = [];\n\n  while (queue.length) {\n    var _queue$shift = queue.shift(),\n        pos = _queue$shift.pos,\n        types = _queue$shift.types,\n        holes = _queue$shift.holes;\n\n    getBoundingBox(pos, size, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    var code = bitCode(bbox[1], cell);\n\n    if (code) {\n      var parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      var polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      var polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n\n      for (var i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = polygonLow.pos.concat(parts[0].pos);\n\n          if (edgeTypes) {\n            polygonLow.types = polygonLow.types.concat(parts[0].types);\n          }\n        }\n\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = polygonHigh.pos.concat(parts[1].pos);\n\n          if (edgeTypes) {\n            polygonHigh.types = polygonHigh.types.concat(parts[1].types);\n          }\n        }\n      }\n    } else {\n      var polygon = {\n        positions: pos\n      };\n\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n\n  return result;\n}\n\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  var numPoints = (endIndex - startIndex) / size;\n  var resultLow = [];\n  var resultHigh = [];\n  var typesLow = [];\n  var typesHigh = [];\n  var scratchPoint = [];\n  var p;\n  var side;\n  var type;\n  var prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  var prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  var prevType = edgeTypes && edgeTypes[numPoints - 1];\n  var lowPointCount = 0;\n  var highPointCount = 0;\n\n  for (var i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  var left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  var bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, out) {\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n\n  for (var i = 0; i < positions.length; i += size) {\n    var x = positions[i];\n    var y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}","map":{"version":3,"sources":["../../src/cut-by-grid.js"],"names":["options","size","broken","gridResolution","gridOffset","startIndex","endIndex","positions","numPoints","part","result","a","getPointAtIndex","cell","getGridCell","scratchPoint","push","i","b","codeB","bitCode","intersect","codeAlt","copy","moveToNeighborCell","TYPE_INSIDE","TYPE_BORDER","edgeTypes","queue","pos","types","holes","holeIndices","bbox","getBoundingBox","code","parts","bisectPolygon","polygonLow","polygonHigh","polygon","resultLow","resultHigh","typesLow","typesHigh","prev","prevSide","Math","edge","prevType","lowPointCount","highPointCount","p","side","type","left","bottom","out","minX","maxX","minY","maxY","x","y"],"mappings":"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","sourcesContent":["/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport {bitCode, intersect} from './lineclip';\nimport {getPointAtIndex, copy, push} from './utils';\n\nexport function cutPolylineByGrid(positions, options = {}) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options;\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      // find the intersection with the current cell\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      // move to the next cell\n      copy(a, scratchPoint);\n\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\n\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nexport function cutPolygonByGrid(positions, holeIndices, options = {}) {\n  if (!positions.length) {\n    // input is empty\n    return [];\n  }\n  const {size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false} = options;\n  const result = [];\n  const queue = [\n    {\n      pos: positions,\n      types: edgeTypes && new Array(positions.length / size).fill(TYPE_BORDER),\n      holes: holeIndices || []\n    }\n  ];\n  const bbox = [[], []];\n  let cell = [];\n\n  // Recursively bisect polygon until every part fit in a single grid cell\n  while (queue.length) {\n    const {pos, types, holes} = queue.shift();\n\n    getBoundingBox(pos, size, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      // Split the outer ring at the boundary\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {pos: parts[0].pos, types: parts[0].types, holes: []};\n      const polygonHigh = {pos: parts[1].pos, types: parts[1].types, holes: []};\n      queue.push(polygonLow, polygonHigh);\n\n      // Split each hole at the boundary\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = polygonLow.pos.concat(parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = polygonLow.types.concat(parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = polygonHigh.pos.concat(parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = polygonHigh.types.concat(parts[1].types);\n          }\n        }\n      }\n    } else {\n      // Polygon fits in a single cell, no more processing required\n      const polygon = {positions: pos};\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n  return result;\n}\n\n// edgeTypes:\n// TYPE_BORDER - edge from the original polygon\n// TYPE_INSIDE - inside the original polygon\n// eslint-disable-next-line max-params\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n\n  let p;\n  let side;\n  let type;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    // if segment goes through the boundary, add an intersection\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [\n    lowPointCount ? {pos: resultLow, types: edgeTypes && typesLow} : null,\n    highPointCount ? {pos: resultHigh, types: edgeTypes && typesHigh} : null\n  ];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom =\n    Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    // top\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    // bottom\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    // right\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    // left\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < positions.length; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n"]},"metadata":{},"sourceType":"module"}