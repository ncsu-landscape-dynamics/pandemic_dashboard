{"ast":null,"code":"import { log, COORDINATE_SYSTEM } from '@deck.gl/core';\nvar R_EARTH = 6378000;\n\nfunction toFinite(n) {\n  return Number.isFinite(n) ? n : 0;\n}\n\nexport function getBoundingBox(attributes, vertexCount) {\n  var positions = attributes.positions.value;\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var y;\n  var x;\n\n  for (var i = 0; i < vertexCount; i++) {\n    x = positions[i * 3];\n    y = positions[i * 3 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  var boundingBox = {\n    xMin: toFinite(xMin),\n    xMax: toFinite(xMax),\n    yMin: toFinite(yMin),\n    yMax: toFinite(yMax)\n  };\n  return boundingBox;\n}\n\nfunction getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {\n  var width = viewport.width,\n      height = viewport.height;\n  var worldOrigin = coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];\n  log.assert([COORDINATE_SYSTEM.CARTESIAN, COORDINATE_SYSTEM.LNGLAT, COORDINATE_SYSTEM.DEFAULT].includes(coordinateSystem));\n  var xMin = boundingBox.xMin,\n      yMin = boundingBox.yMin;\n  return [-1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]), -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])];\n}\n\nexport function alignToCell(inValue, cellSize) {\n  var sign = inValue < 0 ? -1 : 1;\n  var value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n  value = Math.floor(value / cellSize) * cellSize;\n  return value * sign;\n}\nexport function getGridOffset(boundingBox, cellSize) {\n  var convertToMeters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (!convertToMeters) {\n    return {\n      xOffset: cellSize,\n      yOffset: cellSize\n    };\n  }\n\n  var yMin = boundingBox.yMin,\n      yMax = boundingBox.yMax;\n  var centerLat = (yMin + yMax) / 2;\n  return calculateGridLatLonOffset(cellSize, centerLat);\n}\nexport function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {\n  var gridOffset = getGridOffset(boundingBox, cellSize, coordinateSystem !== COORDINATE_SYSTEM.CARTESIAN);\n  var translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);\n  var xMin = boundingBox.xMin,\n      yMin = boundingBox.yMin,\n      xMax = boundingBox.xMax,\n      yMax = boundingBox.yMax;\n  var width = xMax - xMin + gridOffset.xOffset;\n  var height = yMax - yMin + gridOffset.yOffset;\n  var numCol = Math.ceil(width / gridOffset.xOffset);\n  var numRow = Math.ceil(height / gridOffset.yOffset);\n  return {\n    gridOffset: gridOffset,\n    translation: translation,\n    width: width,\n    height: height,\n    numCol: numCol,\n    numRow: numRow\n  };\n}\n\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n  var yOffset = calculateLatOffset(cellSize);\n  var xOffset = calculateLonOffset(latitude, cellSize);\n  return {\n    yOffset: yOffset,\n    xOffset: xOffset\n  };\n}\n\nfunction calculateLatOffset(dy) {\n  return dy / R_EARTH * (180 / Math.PI);\n}\n\nfunction calculateLonOffset(lat, dx) {\n  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n}","map":{"version":3,"sources":["../../../src/utils/grid-aggregation-utils.js"],"names":["R_EARTH","Number","positions","attributes","yMin","yMax","xMin","xMax","i","x","y","boundingBox","toFinite","width","height","viewport","worldOrigin","coordinateSystem","COORDINATE_SYSTEM","log","alignToCell","gridOffset","sign","inValue","value","Math","convertToMeters","xOffset","yOffset","cellSize","centerLat","calculateGridLatLonOffset","getGridOffset","translation","getTranslation","numCol","numRow","calculateLatOffset","calculateLonOffset","dy","dx","lat"],"mappings":"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","sourcesContent":["import {log, COORDINATE_SYSTEM} from '@deck.gl/core';\nconst R_EARTH = 6378000;\n\nfunction toFinite(n) {\n  return Number.isFinite(n) ? n : 0;\n}\n\n// Parse input data to build positions, wights and bounding box.\n/* eslint-disable max-statements */\nexport function getBoundingBox(attributes, vertexCount) {\n  // TODO - value might not exist (e.g. attribute transition)\n  const positions = attributes.positions.value;\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 3];\n    y = positions[i * 3 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  const boundingBox = {\n    xMin: toFinite(xMin),\n    xMax: toFinite(xMax),\n    yMin: toFinite(yMin),\n    yMax: toFinite(yMax)\n  };\n\n  return boundingBox;\n}\n/* eslint-enable max-statements */\n\n// Returns XY translation for positions to peform aggregation in +ve sapce\nfunction getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {\n  const {width, height} = viewport;\n\n  // Origin to define grid\n  // DEFAULT coordinate system is treated as LNGLAT\n  const worldOrigin =\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];\n\n  // Other coordinate systems not supported/verified yet.\n  log.assert(\n    [COORDINATE_SYSTEM.CARTESIAN, COORDINATE_SYSTEM.LNGLAT, COORDINATE_SYSTEM.DEFAULT].includes(\n      coordinateSystem\n    )\n  );\n\n  const {xMin, yMin} = boundingBox;\n  return [\n    // Align origin to match grid cell boundaries in CPU and GPU aggregations\n    -1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]),\n    -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])\n  ];\n}\n\n// Aligns `inValue` to given `cellSize`\nexport function alignToCell(inValue, cellSize) {\n  const sign = inValue < 0 ? -1 : 1;\n\n  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n\n  value = Math.floor(value / cellSize) * cellSize;\n\n  return value * sign;\n}\n\n/**\n * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space\n * @param {object} boundingBox - {xMin, yMin, xMax, yMax} contains bounding box of data\n * @param {number} cellSize - grid cell size in meters\n * @param {boolean, optional} converToDegrees - when true offsets are converted from meters to lng/lat (degree) space\n * @returns {xOffset, yOffset} - cellSize size\n */\n\nexport function getGridOffset(boundingBox, cellSize, convertToMeters = true) {\n  if (!convertToMeters) {\n    return {xOffset: cellSize, yOffset: cellSize};\n  }\n\n  const {yMin, yMax} = boundingBox;\n  const centerLat = (yMin + yMax) / 2;\n\n  return calculateGridLatLonOffset(cellSize, centerLat);\n}\n\nexport function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {\n  const gridOffset = getGridOffset(\n    boundingBox,\n    cellSize,\n    coordinateSystem !== COORDINATE_SYSTEM.CARTESIAN\n  );\n\n  const translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);\n\n  const {xMin, yMin, xMax, yMax} = boundingBox;\n\n  const width = xMax - xMin + gridOffset.xOffset;\n  const height = yMax - yMin + gridOffset.yOffset;\n\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n  return {gridOffset, translation, width, height, numCol, numRow};\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = calculateLatOffset(cellSize);\n  const xOffset = calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction calculateLonOffset(lat, dx) {\n  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n"]},"metadata":{},"sourceType":"module"}