{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nvar _marked = _regeneratorRuntime.mark(makeStringIterator);\n\nexport function makeStringIterator(string) {\n  var options,\n      _options$chunkSize,\n      chunkSize,\n      offset,\n      textEncoder,\n      chunkLength,\n      chunk,\n      _args = arguments;\n\n  return _regeneratorRuntime.wrap(function makeStringIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? 256 * 1024 : _options$chunkSize;\n          offset = 0;\n          textEncoder = new TextEncoder();\n\n        case 4:\n          if (!(offset < string.length)) {\n            _context.next = 12;\n            break;\n          }\n\n          chunkLength = Math.min(string.length - offset, chunkSize);\n          chunk = string.slice(offset, offset + chunkLength);\n          offset += chunkLength;\n          _context.next = 10;\n          return textEncoder.encode(chunk);\n\n        case 10:\n          _context.next = 4;\n          break;\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}","map":{"version":3,"sources":["../../../../src/iterator-utils/make-iterator/string-iterator.js"],"names":["makeStringIterator","options","chunkSize","offset","textEncoder","string","chunkLength","Math","chunk"],"mappings":";;uCAKiBA,kB;;AAAjB,OAAO,SAAA,kBAAA,CAAA,MAAA,EAAA;AAAA,MAAA,OAAA;AAAA,MAAA,kBAAA;AAAA,MAAA,SAAA;AAAA,MAAA,MAAA;AAAA,MAAA,WAAA;AAAA,MAAA,WAAA;AAAA,MAAA,KAAA;AAAA,MAAA,KAAA,GAAA,SAAA;;AAAA,SAAA,mBAAA,CAAA,IAAA,CAAA,SAAA,mBAAA,CAAA,QAAA,EAAA;AAAA,WAAA,CAAA,EAAA;AAAA,cAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;AAAA,aAAA,CAAA;AAAqCC,UAAAA,OAArC,GAAA,KAAA,CAAA,MAAA,GAAA,CAAA,IAAA,KAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,KAAA,CAAA,CAAA,CAAA,GAAA,EAAqCA;AAArC,UAAA,kBAAA,GAC4BA,OAD5B,CAAA,SAAA,EACEC,SADF,GAAA,kBAAA,KAAA,KAAA,CAAA,GACc,MADd,IAAA,GAAA,kBAAA;AAGDC,UAAAA,MAHC,GAAA,CAGDA;AACEC,UAAAA,WAJD,GAIe,IAJf,WAIe,EAAdA;;AAJD,aAAA,CAAA;AAAA,cAAA,EAKED,MAAM,GAAGE,MAAM,CALjB,MAAA,CAAA,EAAA;AAAA,YAAA,QAAA,CAAA,IAAA,GAAA,EAAA;AAAA;AAAA;;AAOGC,UAAAA,WAPH,GAOiBC,IAAI,CAAJA,GAAAA,CAASF,MAAM,CAANA,MAAAA,GAATE,MAAAA,EAPjB,SAOiBA,CAAdD;AACAE,UAAAA,KARH,GAQWH,MAAM,CAANA,KAAAA,CAAAA,MAAAA,EAAqBF,MAAM,GARtC,WAQWE,CAARG;AACNL,UAAAA,MAAM,IAANA,WAAAA;AATG,UAAA,QAAA,CAAA,IAAA,GAAA,EAAA;AAYH,iBAAMC,WAAW,CAAXA,MAAAA,CAAN,KAAMA,CAAN;;AAZG,aAAA,EAAA;AAAA,UAAA,QAAA,CAAA,IAAA,GAAA,CAAA;AAAA;;AAAA,aAAA,EAAA;AAAA,aAAA,KAAA;AAAA,iBAAA,QAAA,CAAA,IAAA,EAAA;AAAA;AAAA;AAAA,GAAA,EAAA,OAAA,CAAA;AAAA","sourcesContent":["/* global TextEncoder */\n\n/**\n * Returns an iterator that breaks a big string into chunks and yields them one-by-one\n */\nexport function* makeStringIterator(string, options = {}) {\n  const {chunkSize = 256 * 1024} = options;\n\n  let offset = 0;\n  const textEncoder = new TextEncoder();\n  while (offset < string.length) {\n    // Create a chunk of the right size\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    // yield an ArrayBuffer chunk\n    yield textEncoder.encode(chunk);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}