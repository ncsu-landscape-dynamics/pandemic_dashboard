{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { normalizeLoader } from '../loader-utils/normalize-loader';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { getRegisteredLoaders } from './register-loaders';\nvar EXT_PATTERN = /\\.([^.]+)$/;\nexport function selectLoader(data) {\n  var loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (loaders && !Array.isArray(loaders)) {\n    return normalizeLoader(loaders);\n  }\n\n  loaders = [].concat(_toConsumableArray(loaders || []), _toConsumableArray(getRegisteredLoaders()));\n  normalizeLoaders(loaders);\n\n  var _getResourceUrlAndTyp = getResourceUrlAndType(data),\n      url = _getResourceUrlAndTyp.url,\n      type = _getResourceUrlAndTyp.type;\n\n  var loader = findLoaderByUrl(loaders, url || context.url);\n  loader = loader || findLoaderByContentType(loaders, type);\n  loader = loader || findLoaderByExamingInitialData(loaders, data);\n\n  if (!loader && !options.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data, url, type));\n  }\n\n  return loader;\n}\n\nfunction getNoValidLoaderMessage(data, url, contentType) {\n  var message = 'No valid loader found';\n\n  if (data) {\n    message += \" data: \\\"\".concat(getFirstCharacters(data), \"\\\"\");\n  }\n\n  if (url) {\n    message += \" for \".concat(url);\n  }\n\n  return message;\n}\n\nfunction normalizeLoaders(loaders) {\n  var _iterator = _createForOfIteratorHelper(loaders),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var loader = _step.value;\n      normalizeLoader(loader);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction findLoaderByUrl(loaders, url) {\n  var match = url && url.match(EXT_PATTERN);\n  var extension = match && match[1];\n  return extension && findLoaderByExtension(loaders, extension);\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  var _iterator2 = _createForOfIteratorHelper(loaders),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var loader = _step2.value;\n\n      var _iterator3 = _createForOfIteratorHelper(loader.extensions),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var loaderExtension = _step3.value;\n\n          if (loaderExtension.toLowerCase() === extension) {\n            return loader;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return null;\n}\n\nfunction findLoaderByContentType(loaders, mimeType) {\n  var _iterator4 = _createForOfIteratorHelper(loaders),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var loader = _step4.value;\n\n      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n        return loader;\n      }\n\n      if (mimeType === \"application/x.\".concat(loader.id)) {\n        return loader;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return null;\n}\n\nfunction findLoaderByExamingInitialData(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(loaders),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var loader = _step5.value;\n\n      if (typeof data === 'string') {\n        if (testText(data, loader)) {\n          return loader;\n        }\n      } else if (ArrayBuffer.isView(data)) {\n        if (testBinary(data.buffer, data.byteOffset, loader)) {\n          return loader;\n        }\n      } else if (data instanceof ArrayBuffer) {\n        var byteOffset = 0;\n\n        if (testBinary(data, byteOffset, loader)) {\n          return loader;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return null;\n}\n\nfunction testText(data, loader) {\n  return loader.testText && loader.testText(data);\n}\n\nfunction testBinary(data, byteOffset, loader) {\n  var type = Array.isArray(loader.test) ? 'array' : _typeof(loader.test);\n\n  switch (type) {\n    case 'function':\n      return loader.test(data, loader);\n\n    case 'string':\n    case 'array':\n      var tests = Array.isArray(loader.test) ? loader.test : [loader.test];\n      return tests.some(function (test) {\n        var magic = getMagicString(data, byteOffset, test.length);\n        return test === magic;\n      });\n\n    default:\n      return false;\n  }\n}\n\nfunction getFirstCharacters(data) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    var byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n\n  return '';\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n\n  var dataView = new DataView(arrayBuffer);\n  var magic = '';\n\n  for (var i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n\n  return magic;\n}","map":{"version":3,"sources":["../../../../src/lib/api/select-loader.js"],"names":["EXT_PATTERN","loaders","options","context","Array","normalizeLoader","getRegisteredLoaders","normalizeLoaders","url","type","getResourceUrlAndType","loader","findLoaderByUrl","findLoaderByContentType","findLoaderByExamingInitialData","getNoValidLoaderMessage","message","getFirstCharacters","match","extension","findLoaderByExtension","loaderExtension","mimeType","testText","ArrayBuffer","testBinary","data","byteOffset","tests","magic","getMagicString","test","length","arrayBuffer","dataView","i","String"],"mappings":"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","sourcesContent":["import {normalizeLoader} from '../loader-utils/normalize-loader';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {getRegisteredLoaders} from './register-loaders';\n\nconst EXT_PATTERN = /\\.([^.]+)$/;\n\n// TODO - Need a variant that peeks at streams for parseInBatches\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\n\n// eslint-disable-next-line complexity\nexport function selectLoader(data, loaders = [], options = {}, context = {}) {\n  // if only a single loader was provided (not as array), force its use\n  // TODO - Should this behaviour be kept and documented?\n  if (loaders && !Array.isArray(loaders)) {\n    return normalizeLoader(loaders);\n  }\n\n  // Add registered loaders\n  loaders = [...(loaders || []), ...getRegisteredLoaders()];\n  normalizeLoaders(loaders);\n\n  const {url, type} = getResourceUrlAndType(data);\n\n  let loader = findLoaderByUrl(loaders, url || context.url);\n  loader = loader || findLoaderByContentType(loaders, type);\n  loader = loader || findLoaderByExamingInitialData(loaders, data);\n\n  // no loader available\n  if (!loader && !options.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data, url, type));\n  }\n\n  return loader;\n}\n\nfunction getNoValidLoaderMessage(data, url, contentType) {\n  let message = 'No valid loader found';\n  if (data) {\n    message += ` data: \"${getFirstCharacters(data)}\"`;\n  }\n  if (url) {\n    message += ` for ${url}`;\n  }\n  return message;\n}\n\nfunction normalizeLoaders(loaders) {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders, url) {\n  // Get extension\n  const match = url && url.match(EXT_PATTERN);\n  const extension = match && match[1];\n  return extension && findLoaderByExtension(loaders, extension);\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByContentType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n      return loader;\n    }\n\n    // Support referring to loaders using the \"unregistered tree\"\n    // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree\n    if (mimeType === `application/x.${loader.id}`) {\n      return loader;\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByExamingInitialData(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      // Typed Arrays can have offsets into underlying buffer\n      if (testBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n      if (testBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\n  }\n  return null;\n}\n\nfunction testText(data, loader) {\n  return loader.testText && loader.testText(data);\n}\n\nfunction testBinary(data, byteOffset, loader) {\n  const type = Array.isArray(loader.test) ? 'array' : typeof loader.test;\n  switch (type) {\n    case 'function':\n      return loader.test(data, loader);\n\n    case 'string':\n    case 'array':\n      // Magic bytes check: If `loader.test` is a string or array of strings,\n      // check if binary data starts with one of those strings\n      const tests = Array.isArray(loader.test) ? loader.test : [loader.test];\n      return tests.some(test => {\n        const magic = getMagicString(data, byteOffset, test.length);\n        return test === magic;\n      });\n\n    default:\n      return false;\n  }\n}\n\nfunction getFirstCharacters(data, length = 5) {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n"]},"metadata":{},"sourceType":"module"}