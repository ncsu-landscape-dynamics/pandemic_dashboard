{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3 } from '@math.gl/core';\nimport { INTERSECTION } from '../constants';\nvar scratchVector = new Vector3();\nvar scratchNormal = new Vector3();\n\nvar AxisAlignedBoundingBox = function () {\n  function AxisAlignedBoundingBox() {\n    var minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    var center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, AxisAlignedBoundingBox);\n\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n    this.minimum = new Vector3(minimum);\n    this.maximum = new Vector3(maximum);\n  }\n\n  _createClass(AxisAlignedBoundingBox, [{\n    key: \"clone\",\n    value: function clone() {\n      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var halfDiagonal = this.halfDiagonal;\n      var normal = scratchNormal.from(plane.normal);\n      var e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);\n      var s = this.center.dot(normal) + plane.distance;\n\n      if (s - e > 0) {\n        return INTERSECTION.INSIDE;\n      }\n\n      if (s + e < 0) {\n        return INTERSECTION.OUTSIDE;\n      }\n\n      return INTERSECTION.INTERSECTING;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      return Math.sqrt(this.distanceSquaredTo(point));\n    }\n  }, {\n    key: \"distanceSquaredTo\",\n    value: function distanceSquaredTo(point) {\n      var offset = scratchVector.from(point).subtract(this.center);\n      var halfDiagonal = this.halfDiagonal;\n      var distanceSquared = 0.0;\n      var d;\n      d = Math.abs(offset.x) - halfDiagonal.x;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      d = Math.abs(offset.y) - halfDiagonal.y;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      d = Math.abs(offset.z) - halfDiagonal.z;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      return distanceSquared;\n    }\n  }]);\n\n  return AxisAlignedBoundingBox;\n}();\n\nexport { AxisAlignedBoundingBox as default };","map":{"version":3,"sources":["../../../src/lib/axis-aligned-bounding-box.js"],"names":["scratchVector","scratchNormal","AxisAlignedBoundingBox","minimum","maximum","center","right","Boolean","plane","halfDiagonal","normal","e","Math","s","INTERSECTION","point","offset","distanceSquared","d"],"mappings":";;AAAA,SAAA,OAAA,QAAA,eAAA;AACA,SAAA,YAAA,QAAA,cAAA;AAEA,IAAMA,aAAa,GAAG,IAAtB,OAAsB,EAAtB;AACA,IAAMC,aAAa,GAAG,IAAtB,OAAsB,EAAtB;;IAEqBC,sB;AACnB,WAAA,sBAAA,GAAqE;AAAA,QAAzDC,OAAyD,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAA/C,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAA+C;AAAA,QAApCC,OAAoC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAA1B,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAA0B;AAAA,QAAfC,MAAe,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAN,IAAM;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,sBAAA,CAAA;;AAEnEA,IAAAA,MAAM,GACJA,MAAM,IACNL,aAAa,CAAbA,IAAAA,CAAAA,OAAAA,EAAAA,GAAAA,CAAAA,OAAAA,EAAAA,KAAAA,CAFFK,GAEEL,CAFFK;AAUA,SAAA,MAAA,GAAc,IAAA,OAAA,CAAd,MAAc,CAAd;AAKA,SAAA,YAAA,GAAoB,IAAA,OAAA,CAAA,OAAA,EAAA,QAAA,CAA8B,KAAlD,MAAoB,CAApB;AAOA,SAAA,OAAA,GAAe,IAAA,OAAA,CAAf,OAAe,CAAf;AAOA,SAAA,OAAA,GAAe,IAAA,OAAA,CAAf,OAAe,CAAf;AACD;;;;4BAOO;AACN,aAAO,IAAA,sBAAA,CAA2B,KAA3B,OAAA,EAAyC,KAAzC,OAAA,EAAuD,KAA9D,MAAO,CAAP;AACD;;;2BASMC,K,EAAO;AACZ,aACE,SAAA,KAAA,IACCC,OAAO,CAAPA,KAAO,CAAPA,IAAkB,KAAA,OAAA,CAAA,MAAA,CAAoBD,KAAK,CAA3CC,OAAkB,CAAlBA,IAAwD,KAAA,OAAA,CAAA,MAAA,CAAoBD,KAAK,CAFpF,OAE2D,CAF3D;AAID;;;mCAKcE,K,EAAO;AAAA,UACbC,YADa,GAAA,KAAA,YAAA;AAEpB,UAAMC,MAAM,GAAGT,aAAa,CAAbA,IAAAA,CAAmBO,KAAK,CAAvC,MAAeP,CAAf;AACA,UAAMU,CAAC,GACLF,YAAY,CAAZA,CAAAA,GAAiBG,IAAI,CAAJA,GAAAA,CAASF,MAAM,CAAhCD,CAAiBG,CAAjBH,GACAA,YAAY,CAAZA,CAAAA,GAAiBG,IAAI,CAAJA,GAAAA,CAASF,MAAM,CADhCD,CACiBG,CADjBH,GAEAA,YAAY,CAAZA,CAAAA,GAAiBG,IAAI,CAAJA,GAAAA,CAASF,MAAM,CAHlC,CAGmBE,CAHnB;AAIA,UAAMC,CAAC,GAAG,KAAA,MAAA,CAAA,GAAA,CAAA,MAAA,IAA0BL,KAAK,CAAzC,QAAA;;AAEA,UAAIK,CAAC,GAADA,CAAAA,GAAJ,CAAA,EAAe;AACb,eAAOC,YAAY,CAAnB,MAAA;AACD;;AAED,UAAID,CAAC,GAADA,CAAAA,GAAJ,CAAA,EAAe;AAEb,eAAOC,YAAY,CAAnB,OAAA;AACD;;AAED,aAAOA,YAAY,CAAnB,YAAA;AACD;;;+BAGUC,K,EAAO;AAChB,aAAOH,IAAI,CAAJA,IAAAA,CAAU,KAAA,iBAAA,CAAjB,KAAiB,CAAVA,CAAP;AACD;;;sCAIiBG,K,EAAO;AACvB,UAAMC,MAAM,GAAGhB,aAAa,CAAbA,IAAAA,CAAAA,KAAAA,EAAAA,QAAAA,CAAmC,KAAlD,MAAeA,CAAf;AADuB,UAEhBS,YAFgB,GAAA,KAAA,YAAA;AAIvB,UAAIQ,eAAe,GAAnB,GAAA;AACA,UAAA,CAAA;AAEAC,MAAAA,CAAC,GAAGN,IAAI,CAAJA,GAAAA,CAASI,MAAM,CAAfJ,CAAAA,IAAqBH,YAAY,CAArCS,CAAAA;;AACA,UAAIA,CAAC,GAAL,CAAA,EAAW;AACTD,QAAAA,eAAe,IAAIC,CAAC,GAApBD,CAAAA;AACD;;AAEDC,MAAAA,CAAC,GAAGN,IAAI,CAAJA,GAAAA,CAASI,MAAM,CAAfJ,CAAAA,IAAqBH,YAAY,CAArCS,CAAAA;;AACA,UAAIA,CAAC,GAAL,CAAA,EAAW;AACTD,QAAAA,eAAe,IAAIC,CAAC,GAApBD,CAAAA;AACD;;AAEDC,MAAAA,CAAC,GAAGN,IAAI,CAAJA,GAAAA,CAASI,MAAM,CAAfJ,CAAAA,IAAqBH,YAAY,CAArCS,CAAAA;;AACA,UAAIA,CAAC,GAAL,CAAA,EAAW;AACTD,QAAAA,eAAe,IAAIC,CAAC,GAApBD,CAAAA;AACD;;AAED,aAAA,eAAA;AACD;;;;;;SAhHkBf,sB","sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {INTERSECTION} from '../constants';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n\nexport default class AxisAlignedBoundingBox {\n  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center = null) {\n    // If center was not defined, compute it.\n    center =\n      center ||\n      scratchVector\n        .copy(minimum)\n        .add(maximum)\n        .scale(0.5);\n    /**\n     * The center point of the bounding box.\n     * @type {Vector3}\n     */\n    this.center = new Vector3(center);\n    /**\n     * The positive half diagonal of the bounding box.\n     * @type {Vector3}\n     */\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n  }\n\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone() {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum))\n    );\n  }\n\n  /**\n   * Determines which side of a plane a box is located.\n   */\n  intersectPlane(plane) {\n    const {halfDiagonal} = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e =\n      halfDiagonal.x * Math.abs(normal.x) +\n      halfDiagonal.y * Math.abs(normal.y) +\n      halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return INTERSECTION.OUTSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  // Computes the estimated distance from the closest point on a bounding box to a point.\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  // Computes the estimated distance squared from the closest point on a bounding box to a point.\n  // A simplified version of OrientedBoundingBox.distanceSquaredTo\n  distanceSquaredTo(point) {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {halfDiagonal} = this;\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.x) - halfDiagonal.x;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.y) - halfDiagonal.y;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.z) - halfDiagonal.z;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}