{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nfunction noop() {}\n\nfunction dracoInt8ArrayToArrayBuffer(dracoData) {\n  var byteLength = dracoData.size();\n  var outputBuffer = new ArrayBuffer(byteLength);\n  var outputData = new Int8Array(outputBuffer);\n\n  for (var i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n\n  return outputBuffer;\n}\n\nvar DracoBuilder = function () {\n  function DracoBuilder(draco) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, DracoBuilder);\n\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.log = options.log || noop;\n  }\n\n  _createClass(DracoBuilder, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.destroyEncodedObject(this.dracoMeshBuilder);\n      this.destroyEncodedObject(this.dracoEncoder);\n      this.dracoMeshBuilder = null;\n      this.dracoEncoder = null;\n      this.draco = null;\n    }\n  }, {\n    key: \"destroyEncodedObject\",\n    value: function destroyEncodedObject(object) {\n      if (object) {\n        this.draco.destroy(object);\n      }\n    }\n  }, {\n    key: \"encodeSync\",\n    value: function encodeSync(mesh, options) {\n      this._setOptions(options);\n\n      return options.pointcloud ? this._encodePointCloud(mesh) : this._encodeMesh(mesh);\n    }\n  }, {\n    key: \"_getAttributesFromMesh\",\n    value: function _getAttributesFromMesh(mesh) {\n      var attributes = _objectSpread(_objectSpread({}, mesh), mesh.attributes);\n\n      if (mesh.indices) {\n        attributes.indices = mesh.indices;\n      }\n\n      return attributes;\n    }\n  }, {\n    key: \"_encodePointCloud\",\n    value: function _encodePointCloud(pointcloud) {\n      var attributes = this._getAttributesFromMesh(pointcloud);\n\n      var dracoPointCloud = this._createDracoPointCloud(attributes);\n\n      var dracoData = new this.draco.DracoInt8Array();\n\n      try {\n        var encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(dracoPointCloud, false, dracoData);\n\n        if (!(encodedLen > 0)) {\n          throw new Error('Draco encoding failed.');\n        }\n\n        this.log(\"DRACO encoded \".concat(dracoPointCloud.num_points(), \" points\\n        with \").concat(dracoPointCloud.num_attributes(), \" attributes into \").concat(encodedLen, \" bytes\"));\n        return dracoInt8ArrayToArrayBuffer(dracoData);\n      } finally {\n        this.destroyEncodedObject(dracoData);\n        this.destroyEncodedObject(dracoPointCloud);\n      }\n    }\n  }, {\n    key: \"_encodeMesh\",\n    value: function _encodeMesh(mesh) {\n      var attributes = this._getAttributesFromMesh(mesh);\n\n      var dracoMesh = this._createDracoMesh(attributes);\n\n      var dracoData = new this.draco.DracoInt8Array();\n\n      try {\n        var encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n\n        if (encodedLen <= 0) {\n          throw new Error('Draco encoding failed.');\n        }\n\n        this.log(\"DRACO encoded \".concat(dracoMesh.num_points(), \" points\\n        with \").concat(dracoMesh.num_attributes(), \" attributes into \").concat(encodedLen, \" bytes\"));\n        return dracoInt8ArrayToArrayBuffer(dracoData);\n      } finally {\n        this.destroyEncodedObject(dracoData);\n        this.destroyEncodedObject(dracoMesh);\n      }\n    }\n  }, {\n    key: \"_setOptions\",\n    value: function _setOptions(options) {\n      if ('speed' in options) {\n        var _this$dracoEncoder;\n\n        (_this$dracoEncoder = this.dracoEncoder).SetSpeedOptions.apply(_this$dracoEncoder, _toConsumableArray(options.speed));\n      }\n\n      if ('method' in options) {\n        var dracoMethod = this.draco[options.method];\n        this.dracoEncoder.SetEncodingMethod(dracoMethod);\n      }\n\n      if ('quantization' in options) {\n        for (var attribute in options.quantization) {\n          var bits = options.quantization[attribute];\n          var dracoPosition = this.draco[attribute];\n          this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n        }\n      }\n    }\n  }, {\n    key: \"_createDracoMesh\",\n    value: function _createDracoMesh(attributes) {\n      var dracoMesh = new this.draco.Mesh();\n\n      try {\n        var positions = this._getPositionAttribute(attributes);\n\n        if (!positions) {\n          throw new Error('positions');\n        }\n\n        var vertexCount = positions.length / 3;\n\n        for (var attributeName in attributes) {\n          var attribute = attributes[attributeName];\n          attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n\n          this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n        }\n      } catch (error) {\n        this.destroyEncodedObject(dracoMesh);\n        throw error;\n      }\n\n      return dracoMesh;\n    }\n  }, {\n    key: \"_createDracoPointCloud\",\n    value: function _createDracoPointCloud(attributes) {\n      var dracoPointCloud = new this.draco.PointCloud();\n\n      try {\n        var positions = this._getPositionAttribute(attributes);\n\n        if (!positions) {\n          throw new Error('positions');\n        }\n\n        var vertexCount = positions.length / 3;\n\n        for (var attributeName in attributes) {\n          var attribute = attributes[attributeName];\n          attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n\n          this._addAttributeToMesh(dracoPointCloud, attributeName, attribute, vertexCount);\n        }\n      } catch (error) {\n        this.destroyEncodedObject(dracoPointCloud);\n        throw error;\n      }\n\n      return dracoPointCloud;\n    }\n  }, {\n    key: \"_addAttributeToMesh\",\n    value: function _addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount) {\n      if (!ArrayBuffer.isView(attribute)) {\n        return;\n      }\n\n      var dracoAttributeType = this._getDracoAttributeType(attributeName, attribute);\n\n      var size = attribute.length / vertexCount;\n\n      if (dracoAttributeType === 'indices') {\n        var numFaces = attribute.length / 3;\n        this.log(\"Adding attribute \".concat(attributeName, \", size \").concat(numFaces));\n        this.dracoMeshBuilder.AddFacesToMesh(dracoMesh, numFaces, attribute);\n        return;\n      }\n\n      this.log(\"Adding attribute \".concat(attributeName, \", size \").concat(size));\n\n      switch (attribute.constructor.name) {\n        case 'Int8Array':\n          this.dracoMeshBuilder.AddInt8Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);\n          break;\n\n        case 'Int16Array':\n          this.dracoMeshBuilder.AddInt16Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);\n          break;\n\n        case 'Int32Array':\n          this.dracoMeshBuilder.AddInt32Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);\n          break;\n\n        case 'Uint8Array':\n        case 'Uint8ClampedArray':\n          this.dracoMeshBuilder.AddUInt8Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);\n          break;\n\n        case 'Uint16Array':\n          this.dracoMeshBuilder.AddUInt16Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);\n          break;\n\n        case 'Uint32Array':\n          this.dracoMeshBuilder.AddUInt32Attribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);\n          break;\n\n        case 'Float32Array':\n        default:\n          this.dracoMeshBuilder.AddFloatAttribute(dracoMesh, dracoAttributeType, vertexCount, size, attribute);\n      }\n    }\n  }, {\n    key: \"_getDracoAttributeType\",\n    value: function _getDracoAttributeType(attributeName, attribute) {\n      switch (attributeName.toLowerCase()) {\n        case 'indices':\n          return 'indices';\n\n        case 'position':\n        case 'positions':\n        case 'vertices':\n          return this.draco.POSITION;\n\n        case 'normal':\n        case 'normals':\n          return this.draco.NORMAL;\n\n        case 'color':\n        case 'colors':\n          return this.draco.COLOR;\n\n        case 'texCoord':\n        case 'texCoords':\n          return this.draco.TEX_COORD;\n\n        default:\n          return this.draco.GENERIC;\n      }\n    }\n  }, {\n    key: \"_getPositionAttribute\",\n    value: function _getPositionAttribute(attributes) {\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n\n        var dracoType = this._getDracoAttributeType(attributeName, attribute);\n\n        if (dracoType === this.draco.POSITION) {\n          return attribute;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return DracoBuilder;\n}();\n\nexport { DracoBuilder as default };","map":{"version":3,"sources":["../../../src/lib/draco-builder.js"],"names":["GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","byteLength","dracoData","outputBuffer","outputData","i","DracoBuilder","options","object","mesh","attributes","pointcloud","dracoPointCloud","encodedLen","dracoInt8ArrayToArrayBuffer","dracoMesh","dracoMethod","bits","dracoPosition","positions","vertexCount","attribute","attributeName","ArrayBuffer","dracoAttributeType","size","numFaces","dracoType"],"mappings":"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","sourcesContent":["// This code is a fork of example code from the DRACO repository\n// Copyright 2017 The Draco Authors.\n// Licensed under the Apache License, Version 2.0 (the 'License');\n\n// TODO - seems to be some valid TS failures in this file\n// @ts-nocheck\n\n// const DEFAULT_ENCODING_OPTIONS = {\n//   method: 'MESH_EDGEBREAKER_ENCODING',\n//   speed: [5, 5],\n//   quantization: {\n//     POSITION: 10\n//   }\n// };\n\n// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nfunction noop() {}\n\n// Copy encoded data to buffer\nfunction dracoInt8ArrayToArrayBuffer(dracoData) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n  return outputBuffer;\n}\n\n/* Encoder API:\nhttps://github.com/google/draco/blob/master/src/draco/javascript/emscripten/draco_web_encoder.idl\n   Example:\nhttps://github.com/google/draco/blob/master/javascript/npm/draco3d/draco_nodejs_example.js\n */\nexport default class DracoBuilder {\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco, options = {}) {\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.log = options.log || noop;\n  }\n\n  destroy() {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.dracoMeshBuilder = null;\n    this.dracoEncoder = null;\n    this.draco = null;\n  }\n\n  // TBD - when does this need to be called?\n  destroyEncodedObject(object) {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n\n  // Encode mesh=({})\n  encodeSync(mesh, options) {\n    this._setOptions(options);\n    return options.pointcloud ? this._encodePointCloud(mesh) : this._encodeMesh(mesh);\n  }\n\n  // PRIVATE\n\n  _getAttributesFromMesh(mesh) {\n    // TODO - Change the encodePointCloud interface instead?\n    const attributes = {...mesh, ...mesh.attributes};\n    // Fold indices into the attributes\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n    return attributes;\n  }\n\n  _encodePointCloud(pointcloud) {\n    const attributes = this._getAttributesFromMesh(pointcloud);\n\n    // Build a `DracoPointCloud` from the input data\n    const dracoPointCloud = this._createDracoPointCloud(attributes);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(\n        dracoPointCloud,\n        false,\n        dracoData\n      );\n\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n\n  _encodeMesh(mesh) {\n    const attributes = this._getAttributesFromMesh(mesh);\n    // Build a `DracoMesh` from the input data\n    const dracoMesh = this._createDracoMesh(attributes);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n\n  /**\n   * Set encoding options.\n   * @param {{speed?: any; method?: any; quantization?: any;}} options\n   */\n  _setOptions(options) {\n    if ('speed' in options) {\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method];\n      // if (dracoMethod === undefined) {}\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n\n  _createDracoMesh(attributes) {\n    const dracoMesh = new this.draco.Mesh();\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n\n    return dracoMesh;\n  }\n\n  _createDracoPointCloud(attributes) {\n    const dracoPointCloud = new this.draco.PointCloud();\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        this._addAttributeToMesh(dracoPointCloud, attributeName, attribute, vertexCount);\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n\n    return dracoPointCloud;\n  }\n\n  _addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return;\n    }\n\n    const dracoAttributeType = this._getDracoAttributeType(attributeName, attribute);\n    const size = attribute.length / vertexCount;\n\n    if (dracoAttributeType === 'indices') {\n      const numFaces = attribute.length / 3;\n      this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n      this.dracoMeshBuilder.AddFacesToMesh(dracoMesh, numFaces, attribute);\n      return;\n    }\n\n    this.log(`Adding attribute ${attributeName}, size ${size}`);\n\n    switch (attribute.constructor.name) {\n      case 'Int8Array':\n        this.dracoMeshBuilder.AddInt8Attribute(\n          dracoMesh,\n          dracoAttributeType,\n          vertexCount,\n          size,\n          attribute\n        );\n        break;\n\n      case 'Int16Array':\n        this.dracoMeshBuilder.AddInt16Attribute(\n          dracoMesh,\n          dracoAttributeType,\n          vertexCount,\n          size,\n          attribute\n        );\n        break;\n\n      case 'Int32Array':\n        this.dracoMeshBuilder.AddInt32Attribute(\n          dracoMesh,\n          dracoAttributeType,\n          vertexCount,\n          size,\n          attribute\n        );\n        break;\n\n      case 'Uint8Array':\n      case 'Uint8ClampedArray':\n        this.dracoMeshBuilder.AddUInt8Attribute(\n          dracoMesh,\n          dracoAttributeType,\n          vertexCount,\n          size,\n          attribute\n        );\n        break;\n\n      case 'Uint16Array':\n        this.dracoMeshBuilder.AddUInt16Attribute(\n          dracoMesh,\n          dracoAttributeType,\n          vertexCount,\n          size,\n          attribute\n        );\n        break;\n\n      case 'Uint32Array':\n        this.dracoMeshBuilder.AddUInt32Attribute(\n          dracoMesh,\n          dracoAttributeType,\n          vertexCount,\n          size,\n          attribute\n        );\n        break;\n\n      case 'Float32Array':\n      default:\n        this.dracoMeshBuilder.AddFloatAttribute(\n          dracoMesh,\n          dracoAttributeType,\n          vertexCount,\n          size,\n          attribute\n        );\n    }\n  }\n\n  // DRACO can compress attributes of know type better\n  // TODO - expose an attribute type map?\n  _getDracoAttributeType(attributeName, attribute) {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n      case 'texCoord':\n      case 'texCoords':\n        return this.draco.TEX_COORD;\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const dracoType = this._getDracoAttributeType(attributeName, attribute);\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}