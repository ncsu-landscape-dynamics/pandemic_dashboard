{"ast":null,"code":"import { Vector3, Matrix3 } from '@math.gl/core';\nimport computeEigenDecomposition from './compute-eigen-decomposition';\nimport OrientedBoundingBox from '../lib/oriented-bounding-box';\nimport AxisAlignedBoundingBox from '../lib/axis-aligned-bounding-box';\nvar scratchVector2 = new Vector3();\nvar scratchVector3 = new Vector3();\nvar scratchVector4 = new Vector3();\nvar scratchVector5 = new Vector3();\nvar scratchVector6 = new Vector3();\nvar scratchCovarianceResult = new Matrix3();\nvar scratchEigenResult = {\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n};\nexport function makeOrientedBoundingBoxFromPoints(positions) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new OrientedBoundingBox();\n\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new Vector3();\n    return result;\n  }\n\n  var length = positions.length;\n  var meanPoint = new Vector3(0, 0, 0);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var position = _step.value;\n      meanPoint.add(position);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n  var exx = 0.0;\n  var exy = 0.0;\n  var exz = 0.0;\n  var eyy = 0.0;\n  var eyz = 0.0;\n  var ezz = 0.0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = positions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _position = _step2.value;\n      var p = scratchVector2.copy(_position).subtract(meanPoint);\n      exx += p.x * p.x;\n      exy += p.x * p.y;\n      exz += p.x * p.z;\n      eyy += p.y * p.y;\n      eyz += p.y * p.z;\n      ezz += p.z * p.z;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n  var covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  var _computeEigenDecompos = computeEigenDecomposition(covarianceMatrix, scratchEigenResult),\n      unitary = _computeEigenDecompos.unitary;\n\n  var rotation = result.halfAxes.copy(unitary);\n  var v1 = rotation.getColumn(0, scratchVector4);\n  var v2 = rotation.getColumn(1, scratchVector5);\n  var v3 = rotation.getColumn(2, scratchVector6);\n  var u1 = -Number.MAX_VALUE;\n  var u2 = -Number.MAX_VALUE;\n  var u3 = -Number.MAX_VALUE;\n  var l1 = Number.MAX_VALUE;\n  var l2 = Number.MAX_VALUE;\n  var l3 = Number.MAX_VALUE;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = positions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var _position2 = _step3.value;\n      u1 = Math.max(_position2.dot(v1), u1);\n      u2 = Math.max(_position2.dot(v2), u2);\n      u3 = Math.max(_position2.dot(v3), u3);\n      l1 = Math.min(_position2.dot(v1), l1);\n      l2 = Math.min(_position2.dot(v2), l2);\n      l3 = Math.min(_position2.dot(v3), l3);\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n        _iterator3[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n  result.center.copy(v1).add(v2).add(v3);\n  var scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  result.halfAxes.multiplyByScalar(scale);\n  return result;\n}\nexport function makeAxisAlignedBoundingBoxFromPoints(positions) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new AxisAlignedBoundingBox();\n\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n\n  var minimumX = positions[0][0];\n  var minimumY = positions[0][1];\n  var minimumZ = positions[0][2];\n  var maximumX = positions[0][0];\n  var maximumY = positions[0][1];\n  var maximumZ = positions[0][2];\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = positions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var p = _step4.value;\n      var x = p[0];\n      var y = p[1];\n      var z = p[2];\n      minimumX = Math.min(x, minimumX);\n      maximumX = Math.max(x, maximumX);\n      minimumY = Math.min(y, minimumY);\n      maximumY = Math.max(y, maximumY);\n      minimumZ = Math.min(z, minimumZ);\n      maximumZ = Math.max(z, maximumZ);\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n        _iterator4[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n  return result;\n}","map":{"version":3,"sources":["../../../src/algorithms/bounding-box-from-points.js"],"names":["scratchVector2","scratchVector3","scratchVector4","scratchVector5","scratchVector6","scratchCovarianceResult","scratchEigenResult","diagonal","unitary","result","positions","length","meanPoint","position","invLength","exx","exy","exz","eyy","eyz","ezz","p","covarianceMatrix","computeEigenDecomposition","rotation","v1","v2","v3","u1","Number","u2","u3","l1","l2","l3","Math","scale","minimumX","minimumY","minimumZ","maximumX","maximumY","maximumZ","x","y","z"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport computeEigenDecomposition from './compute-eigen-decomposition';\nimport OrientedBoundingBox from '../lib/oriented-bounding-box';\nimport AxisAlignedBoundingBox from '../lib/axis-aligned-bounding-box';\n\nconst scratchVector2 = new Vector3();\n\nconst scratchVector3 = new Vector3();\n\nconst scratchVector4 = new Vector3();\n\nconst scratchVector5 = new Vector3();\n\nconst scratchVector6 = new Vector3();\n\nconst scratchCovarianceResult = new Matrix3();\n\nconst scratchEigenResult = {\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n};\n\n/* eslint-disable max-statements */\nexport function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new Vector3();\n    return result;\n  }\n\n  const length = positions.length;\n  const meanPoint = new Vector3(0, 0, 0);\n  for (const position of positions) {\n    meanPoint.add(position);\n  }\n  const invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n\n  for (const position of positions) {\n    const p = scratchVector2.copy(position).subtract(meanPoint);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  const {unitary} = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = result.halfAxes.copy(unitary);\n\n  let v1 = rotation.getColumn(0, scratchVector4);\n  let v2 = rotation.getColumn(1, scratchVector5);\n  let v3 = rotation.getColumn(2, scratchVector6);\n\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (const position of positions) {\n    u1 = Math.max(position.dot(v1), u1);\n    u2 = Math.max(position.dot(v2), u2);\n    u3 = Math.max(position.dot(v3), u3);\n\n    l1 = Math.min(position.dot(v1), l1);\n    l2 = Math.min(position.dot(v2), l2);\n    l3 = Math.min(position.dot(v3), l3);\n  }\n\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n\n  result.center\n    .copy(v1)\n    .add(v2)\n    .add(v3);\n\n  const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  result.halfAxes.multiplyByScalar(scale);\n\n  return result;\n}\n\nexport function makeAxisAlignedBoundingBoxFromPoints(\n  positions,\n  result = new AxisAlignedBoundingBox()\n) {\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n\n  let minimumX = positions[0][0];\n  let minimumY = positions[0][1];\n  let minimumZ = positions[0][2];\n\n  let maximumX = positions[0][0];\n  let maximumY = positions[0][1];\n  let maximumZ = positions[0][2];\n\n  for (const p of positions) {\n    const x = p[0];\n    const y = p[1];\n    const z = p[2];\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center\n    .copy(result.minimum)\n    .add(result.maximum)\n    .scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}