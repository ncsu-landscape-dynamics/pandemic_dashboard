{"ast":null,"code":"import { log } from '@deck.gl/core';\nexport function getScale(domain, range, scaleFunction) {\n  var scale = scaleFunction;\n\n  scale.domain = function () {\n    return domain;\n  };\n\n  scale.range = function () {\n    return range;\n  };\n\n  return scale;\n}\nexport function getQuantizeScale(domain, range) {\n  var scaleFunction = function scaleFunction(value) {\n    return quantizeScale(domain, range, value);\n  };\n\n  return getScale(domain, range, scaleFunction);\n}\nexport function getLinearScale(domain, range) {\n  var scaleFunction = function scaleFunction(value) {\n    return linearScale(domain, range, value);\n  };\n\n  return getScale(domain, range, scaleFunction);\n}\nexport function getQuantileScale(domain, range) {\n  var sortedDomain = domain.sort(ascending);\n  var i = 0;\n  var n = Math.max(1, range.length);\n  var thresholds = new Array(n - 1);\n\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedDomain, i / n);\n  }\n\n  var scaleFunction = function scaleFunction(value) {\n    return thresholdsScale(thresholds, range, value);\n  };\n\n  scaleFunction.thresholds = function () {\n    return thresholds;\n  };\n\n  return getScale(domain, range, scaleFunction);\n}\n\nfunction ascending(a, b) {\n  return a - b;\n}\n\nfunction threshold(domain, fraction) {\n  var domainLength = domain.length;\n\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n\n  var domainFraction = (domainLength - 1) * fraction;\n  var lowIndex = Math.floor(domainFraction);\n  var low = domain[lowIndex];\n  var high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\n\nfunction bisectRight(a, x) {\n  var lo = 0;\n  var hi = a.length;\n\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n\n    if (ascending(a[mid], x) > 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n\n  return lo;\n}\n\nfunction thresholdsScale(thresholds, range, value) {\n  return range[bisectRight(thresholds, value)];\n}\n\nfunction ordinalScale(domain, domainMap, range, value) {\n  var key = \"\".concat(value);\n  var d = domainMap.get(key);\n\n  if (d === undefined) {\n    d = domain.push(value);\n    domainMap.set(key, d);\n  }\n\n  return range[(d - 1) % range.length];\n}\n\nexport function getOrdinalScale(domain, range) {\n  var domainMap = new Map();\n  var uniqueDomain = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = domain[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var d = _step.value;\n      var key = \"\".concat(d);\n\n      if (!domainMap.has(key)) {\n        domainMap.set(key, uniqueDomain.push(d));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var scaleFunction = function scaleFunction(value) {\n    return ordinalScale(uniqueDomain, domainMap, range, value);\n  };\n\n  return getScale(domain, range, scaleFunction);\n}\nexport function quantizeScale(domain, range, value) {\n  var domainRange = domain[1] - domain[0];\n\n  if (domainRange <= 0) {\n    log.warn('quantizeScale: invalid domain, returning range[0]')();\n    return range[0];\n  }\n\n  var step = domainRange / range.length;\n  var idx = Math.floor((value - domain[0]) / step);\n  var clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n  return range[clampIdx];\n}\nexport function linearScale(domain, range, value) {\n  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];\n}\n\nfunction notNullOrUndefined(d) {\n  return d !== undefined && d !== null;\n}\n\nexport function unique(values) {\n  var results = [];\n  values.forEach(function (v) {\n    if (!results.includes(v) && notNullOrUndefined(v)) {\n      results.push(v);\n    }\n  });\n  return results;\n}\n\nfunction getTruthyValues(data, valueAccessor) {\n  var values = typeof valueAccessor === 'function' ? data.map(valueAccessor) : data;\n  return values.filter(notNullOrUndefined);\n}\n\nexport function getLinearDomain(data, valueAccessor) {\n  var sorted = getTruthyValues(data, valueAccessor).sort();\n  return sorted.length ? [sorted[0], sorted[sorted.length - 1]] : [0, 0];\n}\nexport function getQuantileDomain(data, valueAccessor) {\n  return getTruthyValues(data, valueAccessor);\n}\nexport function getOrdinalDomain(data, valueAccessor) {\n  return unique(getTruthyValues(data, valueAccessor));\n}\nexport function getScaleDomain(scaleType, data, valueAccessor) {\n  switch (scaleType) {\n    case 'quantize':\n    case 'linear':\n      return getLinearDomain(data, valueAccessor);\n\n    case 'quantile':\n      return getQuantileDomain(data, valueAccessor);\n\n    case 'ordinal':\n      return getOrdinalDomain(data, valueAccessor);\n\n    default:\n      return getLinearDomain(data, valueAccessor);\n  }\n}\nexport function clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nexport function getScaleFunctionByScaleType(scaleType) {\n  switch (scaleType) {\n    case 'quantize':\n      return getQuantizeScale;\n\n    case 'linear':\n      return getLinearScale;\n\n    case 'quantile':\n      return getQuantileScale;\n\n    case 'ordinal':\n      return getOrdinalScale;\n\n    default:\n      return getQuantizeScale;\n  }\n}","map":{"version":3,"sources":["../../../src/utils/scale-utils.js"],"names":["scale","scaleFunction","quantizeScale","getScale","linearScale","sortedDomain","domain","i","n","Math","range","thresholds","threshold","thresholdsScale","a","domainLength","fraction","domainFraction","lowIndex","low","high","lo","hi","mid","ascending","bisectRight","key","d","domainMap","uniqueDomain","ordinalScale","domainRange","log","step","idx","value","clampIdx","results","values","notNullOrUndefined","data","sorted","getTruthyValues","unique","getLinearDomain","getQuantileDomain","getOrdinalDomain"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {log} from '@deck.gl/core';\n\n// a scale function wrapper just like d3-scales\nexport function getScale(domain, range, scaleFunction) {\n  const scale = scaleFunction;\n  scale.domain = () => domain;\n  scale.range = () => range;\n\n  return scale;\n}\n\n// Quantize scale is similar to linear scales,\n// except it uses a discrete rather than continuous range\n// return a quantize scale function\nexport function getQuantizeScale(domain, range) {\n  const scaleFunction = value => quantizeScale(domain, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\n\n// return a linear scale function\nexport function getLinearScale(domain, range) {\n  const scaleFunction = value => linearScale(domain, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\n\nexport function getQuantileScale(domain, range) {\n  // calculate threshold\n  const sortedDomain = domain.sort(ascending);\n  let i = 0;\n  const n = Math.max(1, range.length);\n  const thresholds = new Array(n - 1);\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedDomain, i / n);\n  }\n\n  const scaleFunction = value => thresholdsScale(thresholds, range, value);\n  scaleFunction.thresholds = () => thresholds;\n\n  return getScale(domain, range, scaleFunction);\n}\n\nfunction ascending(a, b) {\n  return a - b;\n}\n\nfunction threshold(domain, fraction) {\n  const domainLength = domain.length;\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n\n  const domainFraction = (domainLength - 1) * fraction;\n  const lowIndex = Math.floor(domainFraction);\n  const low = domain[lowIndex];\n  const high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\n\nfunction bisectRight(a, x) {\n  let lo = 0;\n  let hi = a.length;\n  while (lo < hi) {\n    const mid = (lo + hi) >>> 1;\n    if (ascending(a[mid], x) > 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n\n// return a quantize scale function\nfunction thresholdsScale(thresholds, range, value) {\n  return range[bisectRight(thresholds, value)];\n}\n\n// ordinal Scale\nfunction ordinalScale(domain, domainMap, range, value) {\n  const key = `${value}`;\n  let d = domainMap.get(key);\n  if (d === undefined) {\n    // update the domain\n    d = domain.push(value);\n    domainMap.set(key, d);\n  }\n  return range[(d - 1) % range.length];\n}\n\nexport function getOrdinalScale(domain, range) {\n  const domainMap = new Map();\n  const uniqueDomain = [];\n  for (const d of domain) {\n    const key = `${d}`;\n    if (!domainMap.has(key)) {\n      domainMap.set(key, uniqueDomain.push(d));\n    }\n  }\n\n  const scaleFunction = value => ordinalScale(uniqueDomain, domainMap, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\n\n// Quantize scale is similar to linear scales,\n// except it uses a discrete rather than continuous range\nexport function quantizeScale(domain, range, value) {\n  const domainRange = domain[1] - domain[0];\n  if (domainRange <= 0) {\n    log.warn('quantizeScale: invalid domain, returning range[0]')();\n    return range[0];\n  }\n  const step = domainRange / range.length;\n  const idx = Math.floor((value - domain[0]) / step);\n  const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n\n  return range[clampIdx];\n}\n\n// Linear scale maps continuous domain to continuous range\nexport function linearScale(domain, range, value) {\n  return ((value - domain[0]) / (domain[1] - domain[0])) * (range[1] - range[0]) + range[0];\n}\n\n// get scale domains\nfunction notNullOrUndefined(d) {\n  return d !== undefined && d !== null;\n}\n\nexport function unique(values) {\n  const results = [];\n  values.forEach(v => {\n    if (!results.includes(v) && notNullOrUndefined(v)) {\n      results.push(v);\n    }\n  });\n\n  return results;\n}\n\nfunction getTruthyValues(data, valueAccessor) {\n  const values = typeof valueAccessor === 'function' ? data.map(valueAccessor) : data;\n  return values.filter(notNullOrUndefined);\n}\n\nexport function getLinearDomain(data, valueAccessor) {\n  const sorted = getTruthyValues(data, valueAccessor).sort();\n  return sorted.length ? [sorted[0], sorted[sorted.length - 1]] : [0, 0];\n}\n\nexport function getQuantileDomain(data, valueAccessor) {\n  return getTruthyValues(data, valueAccessor);\n}\n\nexport function getOrdinalDomain(data, valueAccessor) {\n  return unique(getTruthyValues(data, valueAccessor));\n}\n\nexport function getScaleDomain(scaleType, data, valueAccessor) {\n  switch (scaleType) {\n    case 'quantize':\n    case 'linear':\n      return getLinearDomain(data, valueAccessor);\n\n    case 'quantile':\n      return getQuantileDomain(data, valueAccessor);\n\n    case 'ordinal':\n      return getOrdinalDomain(data, valueAccessor);\n\n    default:\n      return getLinearDomain(data, valueAccessor);\n  }\n}\n\nexport function clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\nexport function getScaleFunctionByScaleType(scaleType) {\n  switch (scaleType) {\n    case 'quantize':\n      return getQuantizeScale;\n    case 'linear':\n      return getLinearScale;\n    case 'quantile':\n      return getQuantileScale;\n    case 'ordinal':\n      return getOrdinalScale;\n\n    default:\n      return getQuantizeScale;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}