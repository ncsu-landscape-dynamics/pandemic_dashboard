{"ast":null,"code":"import isEqual from 'lodash.isequal';\nimport normalize from '@mapbox/geojson-normalize';\nimport hat from 'hat';\nimport featuresAt from './lib/features_at';\nimport stringSetsAreEqual from './lib/string_sets_are_equal';\nimport geojsonhint from '@mapbox/geojsonhint';\nimport * as Constants from './constants';\nimport StringSet from './lib/string_set';\nimport Polygon from './feature_types/polygon';\nimport LineString from './feature_types/line_string';\nimport Point from './feature_types/point';\nimport MultiFeature from './feature_types/multi_feature';\nconst featureTypes = {\n  Polygon,\n  LineString,\n  Point,\n  MultiPolygon: MultiFeature,\n  MultiLineString: MultiFeature,\n  MultiPoint: MultiFeature\n};\nexport default function (ctx, api) {\n  api.modes = Constants.modes;\n\n  api.getFeatureIdsAt = function (point) {\n    const features = featuresAt.click({\n      point\n    }, null, ctx);\n    return features.map(feature => feature.properties.id);\n  };\n\n  api.getSelectedIds = function () {\n    return ctx.store.getSelectedIds();\n  };\n\n  api.getSelected = function () {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getSelectedIds().map(id => ctx.store.get(id)).map(feature => feature.toGeoJSON())\n    };\n  };\n\n  api.getSelectedPoints = function () {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getSelectedCoordinates().map(coordinate => ({\n        type: Constants.geojsonTypes.FEATURE,\n        properties: {},\n        geometry: {\n          type: Constants.geojsonTypes.POINT,\n          coordinates: coordinate.coordinates\n        }\n      }))\n    };\n  };\n\n  api.set = function (featureCollection) {\n    if (featureCollection.type === undefined || featureCollection.type !== Constants.geojsonTypes.FEATURE_COLLECTION || !Array.isArray(featureCollection.features)) {\n      throw new Error('Invalid FeatureCollection');\n    }\n\n    const renderBatch = ctx.store.createRenderBatch();\n    let toDelete = ctx.store.getAllIds().slice();\n    const newIds = api.add(featureCollection);\n    const newIdsLookup = new StringSet(newIds);\n    toDelete = toDelete.filter(id => !newIdsLookup.has(id));\n\n    if (toDelete.length) {\n      api.delete(toDelete);\n    }\n\n    renderBatch();\n    return newIds;\n  };\n\n  api.add = function (geojson) {\n    const errors = geojsonhint.hint(geojson, {\n      precisionWarning: false\n    }).filter(e => e.level !== 'message');\n\n    if (errors.length) {\n      throw new Error(errors[0].message);\n    }\n\n    const featureCollection = JSON.parse(JSON.stringify(normalize(geojson)));\n    const ids = featureCollection.features.map(feature => {\n      feature.id = feature.id || hat();\n\n      if (feature.geometry === null) {\n        throw new Error('Invalid geometry: null');\n      }\n\n      if (ctx.store.get(feature.id) === undefined || ctx.store.get(feature.id).type !== feature.geometry.type) {\n        // If the feature has not yet been created ...\n        const Model = featureTypes[feature.geometry.type];\n\n        if (Model === undefined) {\n          throw new Error(`Invalid geometry type: ${feature.geometry.type}.`);\n        }\n\n        const internalFeature = new Model(ctx, feature);\n        ctx.store.add(internalFeature);\n      } else {\n        // If a feature of that id has already been created, and we are swapping it out ...\n        const internalFeature = ctx.store.get(feature.id);\n        internalFeature.properties = feature.properties;\n\n        if (!isEqual(internalFeature.getCoordinates(), feature.geometry.coordinates)) {\n          internalFeature.incomingCoords(feature.geometry.coordinates);\n        }\n      }\n\n      return feature.id;\n    });\n    ctx.store.render();\n    return ids;\n  };\n\n  api.get = function (id) {\n    const feature = ctx.store.get(id);\n\n    if (feature) {\n      return feature.toGeoJSON();\n    }\n  };\n\n  api.getAll = function () {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getAll().map(feature => feature.toGeoJSON())\n    };\n  };\n\n  api.delete = function (featureIds) {\n    ctx.store.delete(featureIds, {\n      silent: true\n    }); // If we were in direct select mode and our selected feature no longer exists\n    // (because it was deleted), we need to get out of that mode.\n\n    if (api.getMode() === Constants.modes.DIRECT_SELECT && !ctx.store.getSelectedIds().length) {\n      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, {\n        silent: true\n      });\n    } else {\n      ctx.store.render();\n    }\n\n    return api;\n  };\n\n  api.deleteAll = function () {\n    ctx.store.delete(ctx.store.getAllIds(), {\n      silent: true\n    }); // If we were in direct select mode, now our selected feature no longer exists,\n    // so escape that mode.\n\n    if (api.getMode() === Constants.modes.DIRECT_SELECT) {\n      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, {\n        silent: true\n      });\n    } else {\n      ctx.store.render();\n    }\n\n    return api;\n  };\n\n  api.changeMode = function (mode, modeOptions = {}) {\n    // Avoid changing modes just to re-select what's already selected\n    if (mode === Constants.modes.SIMPLE_SELECT && api.getMode() === Constants.modes.SIMPLE_SELECT) {\n      if (stringSetsAreEqual(modeOptions.featureIds || [], ctx.store.getSelectedIds())) return api; // And if we are changing the selection within simple_select mode, just change the selection,\n      // instead of stopping and re-starting the mode\n\n      ctx.store.setSelected(modeOptions.featureIds, {\n        silent: true\n      });\n      ctx.store.render();\n      return api;\n    }\n\n    if (mode === Constants.modes.DIRECT_SELECT && api.getMode() === Constants.modes.DIRECT_SELECT && modeOptions.featureId === ctx.store.getSelectedIds()[0]) {\n      return api;\n    }\n\n    ctx.events.changeMode(mode, modeOptions, {\n      silent: true\n    });\n    return api;\n  };\n\n  api.getMode = function () {\n    return ctx.events.getMode();\n  };\n\n  api.trash = function () {\n    ctx.events.trash({\n      silent: true\n    });\n    return api;\n  };\n\n  api.combineFeatures = function () {\n    ctx.events.combineFeatures({\n      silent: true\n    });\n    return api;\n  };\n\n  api.uncombineFeatures = function () {\n    ctx.events.uncombineFeatures({\n      silent: true\n    });\n    return api;\n  };\n\n  api.setFeatureProperty = function (featureId, property, value) {\n    ctx.store.setFeatureProperty(featureId, property, value);\n    return api;\n  };\n\n  return api;\n}","map":{"version":3,"sources":["/Users/garrettmillar/pandemic_dashboard/node_modules/@mapbox/mapbox-gl-draw/src/api.js"],"names":["isEqual","normalize","hat","featuresAt","stringSetsAreEqual","geojsonhint","Constants","StringSet","Polygon","LineString","Point","MultiFeature","featureTypes","MultiPolygon","MultiLineString","MultiPoint","ctx","api","modes","getFeatureIdsAt","point","features","click","map","feature","properties","id","getSelectedIds","store","getSelected","type","geojsonTypes","FEATURE_COLLECTION","get","toGeoJSON","getSelectedPoints","getSelectedCoordinates","coordinate","FEATURE","geometry","POINT","coordinates","set","featureCollection","undefined","Array","isArray","Error","renderBatch","createRenderBatch","toDelete","getAllIds","slice","newIds","add","newIdsLookup","filter","has","length","delete","geojson","errors","hint","precisionWarning","e","level","message","JSON","parse","stringify","ids","Model","internalFeature","getCoordinates","incomingCoords","render","getAll","featureIds","silent","getMode","DIRECT_SELECT","events","changeMode","SIMPLE_SELECT","deleteAll","mode","modeOptions","setSelected","featureId","trash","combineFeatures","uncombineFeatures","setFeatureProperty","property","value"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,gBAApB;AACA,OAAOC,SAAP,MAAsB,2BAAtB;AACA,OAAOC,GAAP,MAAgB,KAAhB;AACA,OAAOC,UAAP,MAAuB,mBAAvB;AACA,OAAOC,kBAAP,MAA+B,6BAA/B;AACA,OAAOC,WAAP,MAAwB,qBAAxB;AACA,OAAO,KAAKC,SAAZ,MAA2B,aAA3B;AACA,OAAOC,SAAP,MAAsB,kBAAtB;AAEA,OAAOC,OAAP,MAAoB,yBAApB;AACA,OAAOC,UAAP,MAAuB,6BAAvB;AACA,OAAOC,KAAP,MAAkB,uBAAlB;AACA,OAAOC,YAAP,MAAyB,+BAAzB;AAEA,MAAMC,YAAY,GAAG;AACnBJ,EAAAA,OADmB;AAEnBC,EAAAA,UAFmB;AAGnBC,EAAAA,KAHmB;AAInBG,EAAAA,YAAY,EAAEF,YAJK;AAKnBG,EAAAA,eAAe,EAAEH,YALE;AAMnBI,EAAAA,UAAU,EAAEJ;AANO,CAArB;AASA,eAAe,UAASK,GAAT,EAAcC,GAAd,EAAmB;AAEhCA,EAAAA,GAAG,CAACC,KAAJ,GAAYZ,SAAS,CAACY,KAAtB;;AAEAD,EAAAA,GAAG,CAACE,eAAJ,GAAsB,UAASC,KAAT,EAAgB;AACpC,UAAMC,QAAQ,GAAGlB,UAAU,CAACmB,KAAX,CAAiB;AAAEF,MAAAA;AAAF,KAAjB,EAA4B,IAA5B,EAAkCJ,GAAlC,CAAjB;AACA,WAAOK,QAAQ,CAACE,GAAT,CAAaC,OAAO,IAAIA,OAAO,CAACC,UAAR,CAAmBC,EAA3C,CAAP;AACD,GAHD;;AAKAT,EAAAA,GAAG,CAACU,cAAJ,GAAqB,YAAY;AAC/B,WAAOX,GAAG,CAACY,KAAJ,CAAUD,cAAV,EAAP;AACD,GAFD;;AAIAV,EAAAA,GAAG,CAACY,WAAJ,GAAkB,YAAY;AAC5B,WAAO;AACLC,MAAAA,IAAI,EAAExB,SAAS,CAACyB,YAAV,CAAuBC,kBADxB;AAELX,MAAAA,QAAQ,EAAEL,GAAG,CAACY,KAAJ,CAAUD,cAAV,GAA2BJ,GAA3B,CAA+BG,EAAE,IAAIV,GAAG,CAACY,KAAJ,CAAUK,GAAV,CAAcP,EAAd,CAArC,EAAwDH,GAAxD,CAA4DC,OAAO,IAAIA,OAAO,CAACU,SAAR,EAAvE;AAFL,KAAP;AAID,GALD;;AAOAjB,EAAAA,GAAG,CAACkB,iBAAJ,GAAwB,YAAY;AAClC,WAAO;AACLL,MAAAA,IAAI,EAAExB,SAAS,CAACyB,YAAV,CAAuBC,kBADxB;AAELX,MAAAA,QAAQ,EAAEL,GAAG,CAACY,KAAJ,CAAUQ,sBAAV,GAAmCb,GAAnC,CAAuCc,UAAU,KAAK;AAC9DP,QAAAA,IAAI,EAAExB,SAAS,CAACyB,YAAV,CAAuBO,OADiC;AAE9Db,QAAAA,UAAU,EAAE,EAFkD;AAG9Dc,QAAAA,QAAQ,EAAE;AACRT,UAAAA,IAAI,EAAExB,SAAS,CAACyB,YAAV,CAAuBS,KADrB;AAERC,UAAAA,WAAW,EAAEJ,UAAU,CAACI;AAFhB;AAHoD,OAAL,CAAjD;AAFL,KAAP;AAWD,GAZD;;AAcAxB,EAAAA,GAAG,CAACyB,GAAJ,GAAU,UAASC,iBAAT,EAA4B;AACpC,QAAIA,iBAAiB,CAACb,IAAlB,KAA2Bc,SAA3B,IAAwCD,iBAAiB,CAACb,IAAlB,KAA2BxB,SAAS,CAACyB,YAAV,CAAuBC,kBAA1F,IAAgH,CAACa,KAAK,CAACC,OAAN,CAAcH,iBAAiB,CAACtB,QAAhC,CAArH,EAAgK;AAC9J,YAAM,IAAI0B,KAAJ,CAAU,2BAAV,CAAN;AACD;;AACD,UAAMC,WAAW,GAAGhC,GAAG,CAACY,KAAJ,CAAUqB,iBAAV,EAApB;AACA,QAAIC,QAAQ,GAAGlC,GAAG,CAACY,KAAJ,CAAUuB,SAAV,GAAsBC,KAAtB,EAAf;AACA,UAAMC,MAAM,GAAGpC,GAAG,CAACqC,GAAJ,CAAQX,iBAAR,CAAf;AACA,UAAMY,YAAY,GAAG,IAAIhD,SAAJ,CAAc8C,MAAd,CAArB;AAEAH,IAAAA,QAAQ,GAAGA,QAAQ,CAACM,MAAT,CAAgB9B,EAAE,IAAI,CAAC6B,YAAY,CAACE,GAAb,CAAiB/B,EAAjB,CAAvB,CAAX;;AACA,QAAIwB,QAAQ,CAACQ,MAAb,EAAqB;AACnBzC,MAAAA,GAAG,CAAC0C,MAAJ,CAAWT,QAAX;AACD;;AAEDF,IAAAA,WAAW;AACX,WAAOK,MAAP;AACD,GAhBD;;AAkBApC,EAAAA,GAAG,CAACqC,GAAJ,GAAU,UAAUM,OAAV,EAAmB;AAC3B,UAAMC,MAAM,GAAGxD,WAAW,CAACyD,IAAZ,CAAiBF,OAAjB,EAA0B;AAAEG,MAAAA,gBAAgB,EAAE;AAApB,KAA1B,EAAuDP,MAAvD,CAA8DQ,CAAC,IAAIA,CAAC,CAACC,KAAF,KAAY,SAA/E,CAAf;;AACA,QAAIJ,MAAM,CAACH,MAAX,EAAmB;AACjB,YAAM,IAAIX,KAAJ,CAAUc,MAAM,CAAC,CAAD,CAAN,CAAUK,OAApB,CAAN;AACD;;AACD,UAAMvB,iBAAiB,GAAGwB,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAepE,SAAS,CAAC2D,OAAD,CAAxB,CAAX,CAA1B;AAEA,UAAMU,GAAG,GAAG3B,iBAAiB,CAACtB,QAAlB,CAA2BE,GAA3B,CAAgCC,OAAD,IAAa;AACtDA,MAAAA,OAAO,CAACE,EAAR,GAAaF,OAAO,CAACE,EAAR,IAAcxB,GAAG,EAA9B;;AAEA,UAAIsB,OAAO,CAACe,QAAR,KAAqB,IAAzB,EAA+B;AAC7B,cAAM,IAAIQ,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAED,UAAI/B,GAAG,CAACY,KAAJ,CAAUK,GAAV,CAAcT,OAAO,CAACE,EAAtB,MAA8BkB,SAA9B,IAA2C5B,GAAG,CAACY,KAAJ,CAAUK,GAAV,CAAcT,OAAO,CAACE,EAAtB,EAA0BI,IAA1B,KAAmCN,OAAO,CAACe,QAAR,CAAiBT,IAAnG,EAAyG;AACvG;AACA,cAAMyC,KAAK,GAAG3D,YAAY,CAACY,OAAO,CAACe,QAAR,CAAiBT,IAAlB,CAA1B;;AACA,YAAIyC,KAAK,KAAK3B,SAAd,EAAyB;AACvB,gBAAM,IAAIG,KAAJ,CAAW,0BAAyBvB,OAAO,CAACe,QAAR,CAAiBT,IAAK,GAA1D,CAAN;AACD;;AACD,cAAM0C,eAAe,GAAG,IAAID,KAAJ,CAAUvD,GAAV,EAAeQ,OAAf,CAAxB;AACAR,QAAAA,GAAG,CAACY,KAAJ,CAAU0B,GAAV,CAAckB,eAAd;AACD,OARD,MAQO;AACL;AACA,cAAMA,eAAe,GAAGxD,GAAG,CAACY,KAAJ,CAAUK,GAAV,CAAcT,OAAO,CAACE,EAAtB,CAAxB;AACA8C,QAAAA,eAAe,CAAC/C,UAAhB,GAA6BD,OAAO,CAACC,UAArC;;AACA,YAAI,CAACzB,OAAO,CAACwE,eAAe,CAACC,cAAhB,EAAD,EAAmCjD,OAAO,CAACe,QAAR,CAAiBE,WAApD,CAAZ,EAA8E;AAC5E+B,UAAAA,eAAe,CAACE,cAAhB,CAA+BlD,OAAO,CAACe,QAAR,CAAiBE,WAAhD;AACD;AACF;;AACD,aAAOjB,OAAO,CAACE,EAAf;AACD,KAxBW,CAAZ;AA0BAV,IAAAA,GAAG,CAACY,KAAJ,CAAU+C,MAAV;AACA,WAAOL,GAAP;AACD,GAnCD;;AAsCArD,EAAAA,GAAG,CAACgB,GAAJ,GAAU,UAAUP,EAAV,EAAc;AACtB,UAAMF,OAAO,GAAGR,GAAG,CAACY,KAAJ,CAAUK,GAAV,CAAcP,EAAd,CAAhB;;AACA,QAAIF,OAAJ,EAAa;AACX,aAAOA,OAAO,CAACU,SAAR,EAAP;AACD;AACF,GALD;;AAOAjB,EAAAA,GAAG,CAAC2D,MAAJ,GAAa,YAAW;AACtB,WAAO;AACL9C,MAAAA,IAAI,EAAExB,SAAS,CAACyB,YAAV,CAAuBC,kBADxB;AAELX,MAAAA,QAAQ,EAAEL,GAAG,CAACY,KAAJ,CAAUgD,MAAV,GAAmBrD,GAAnB,CAAuBC,OAAO,IAAIA,OAAO,CAACU,SAAR,EAAlC;AAFL,KAAP;AAID,GALD;;AAOAjB,EAAAA,GAAG,CAAC0C,MAAJ,GAAa,UAASkB,UAAT,EAAqB;AAChC7D,IAAAA,GAAG,CAACY,KAAJ,CAAU+B,MAAV,CAAiBkB,UAAjB,EAA6B;AAAEC,MAAAA,MAAM,EAAE;AAAV,KAA7B,EADgC,CAEhC;AACA;;AACA,QAAI7D,GAAG,CAAC8D,OAAJ,OAAkBzE,SAAS,CAACY,KAAV,CAAgB8D,aAAlC,IAAmD,CAAChE,GAAG,CAACY,KAAJ,CAAUD,cAAV,GAA2B+B,MAAnF,EAA2F;AACzF1C,MAAAA,GAAG,CAACiE,MAAJ,CAAWC,UAAX,CAAsB5E,SAAS,CAACY,KAAV,CAAgBiE,aAAtC,EAAqDvC,SAArD,EAAgE;AAAEkC,QAAAA,MAAM,EAAE;AAAV,OAAhE;AACD,KAFD,MAEO;AACL9D,MAAAA,GAAG,CAACY,KAAJ,CAAU+C,MAAV;AACD;;AAED,WAAO1D,GAAP;AACD,GAXD;;AAaAA,EAAAA,GAAG,CAACmE,SAAJ,GAAgB,YAAW;AACzBpE,IAAAA,GAAG,CAACY,KAAJ,CAAU+B,MAAV,CAAiB3C,GAAG,CAACY,KAAJ,CAAUuB,SAAV,EAAjB,EAAwC;AAAE2B,MAAAA,MAAM,EAAE;AAAV,KAAxC,EADyB,CAEzB;AACA;;AACA,QAAI7D,GAAG,CAAC8D,OAAJ,OAAkBzE,SAAS,CAACY,KAAV,CAAgB8D,aAAtC,EAAqD;AACnDhE,MAAAA,GAAG,CAACiE,MAAJ,CAAWC,UAAX,CAAsB5E,SAAS,CAACY,KAAV,CAAgBiE,aAAtC,EAAqDvC,SAArD,EAAgE;AAAEkC,QAAAA,MAAM,EAAE;AAAV,OAAhE;AACD,KAFD,MAEO;AACL9D,MAAAA,GAAG,CAACY,KAAJ,CAAU+C,MAAV;AACD;;AAED,WAAO1D,GAAP;AACD,GAXD;;AAaAA,EAAAA,GAAG,CAACiE,UAAJ,GAAiB,UAASG,IAAT,EAAeC,WAAW,GAAG,EAA7B,EAAiC;AAChD;AACA,QAAID,IAAI,KAAK/E,SAAS,CAACY,KAAV,CAAgBiE,aAAzB,IAA0ClE,GAAG,CAAC8D,OAAJ,OAAkBzE,SAAS,CAACY,KAAV,CAAgBiE,aAAhF,EAA+F;AAC7F,UAAI/E,kBAAkB,CAAEkF,WAAW,CAACT,UAAZ,IAA0B,EAA5B,EAAiC7D,GAAG,CAACY,KAAJ,CAAUD,cAAV,EAAjC,CAAtB,EAAoF,OAAOV,GAAP,CADS,CAE7F;AACA;;AACAD,MAAAA,GAAG,CAACY,KAAJ,CAAU2D,WAAV,CAAsBD,WAAW,CAACT,UAAlC,EAA8C;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAA9C;AACA9D,MAAAA,GAAG,CAACY,KAAJ,CAAU+C,MAAV;AACA,aAAO1D,GAAP;AACD;;AAED,QAAIoE,IAAI,KAAK/E,SAAS,CAACY,KAAV,CAAgB8D,aAAzB,IAA0C/D,GAAG,CAAC8D,OAAJ,OAAkBzE,SAAS,CAACY,KAAV,CAAgB8D,aAA5E,IACFM,WAAW,CAACE,SAAZ,KAA0BxE,GAAG,CAACY,KAAJ,CAAUD,cAAV,GAA2B,CAA3B,CAD5B,EAC2D;AACzD,aAAOV,GAAP;AACD;;AAEDD,IAAAA,GAAG,CAACiE,MAAJ,CAAWC,UAAX,CAAsBG,IAAtB,EAA4BC,WAA5B,EAAyC;AAAER,MAAAA,MAAM,EAAE;AAAV,KAAzC;AACA,WAAO7D,GAAP;AACD,GAlBD;;AAoBAA,EAAAA,GAAG,CAAC8D,OAAJ,GAAc,YAAW;AACvB,WAAO/D,GAAG,CAACiE,MAAJ,CAAWF,OAAX,EAAP;AACD,GAFD;;AAIA9D,EAAAA,GAAG,CAACwE,KAAJ,GAAY,YAAW;AACrBzE,IAAAA,GAAG,CAACiE,MAAJ,CAAWQ,KAAX,CAAiB;AAAEX,MAAAA,MAAM,EAAE;AAAV,KAAjB;AACA,WAAO7D,GAAP;AACD,GAHD;;AAKAA,EAAAA,GAAG,CAACyE,eAAJ,GAAsB,YAAW;AAC/B1E,IAAAA,GAAG,CAACiE,MAAJ,CAAWS,eAAX,CAA2B;AAAEZ,MAAAA,MAAM,EAAE;AAAV,KAA3B;AACA,WAAO7D,GAAP;AACD,GAHD;;AAKAA,EAAAA,GAAG,CAAC0E,iBAAJ,GAAwB,YAAW;AACjC3E,IAAAA,GAAG,CAACiE,MAAJ,CAAWU,iBAAX,CAA6B;AAAEb,MAAAA,MAAM,EAAE;AAAV,KAA7B;AACA,WAAO7D,GAAP;AACD,GAHD;;AAKAA,EAAAA,GAAG,CAAC2E,kBAAJ,GAAyB,UAASJ,SAAT,EAAoBK,QAApB,EAA8BC,KAA9B,EAAqC;AAC5D9E,IAAAA,GAAG,CAACY,KAAJ,CAAUgE,kBAAV,CAA6BJ,SAA7B,EAAwCK,QAAxC,EAAkDC,KAAlD;AACA,WAAO7E,GAAP;AACD,GAHD;;AAKA,SAAOA,GAAP;AACD","sourcesContent":["import isEqual from 'lodash.isequal';\nimport normalize from '@mapbox/geojson-normalize';\nimport hat from 'hat';\nimport featuresAt from './lib/features_at';\nimport stringSetsAreEqual from './lib/string_sets_are_equal';\nimport geojsonhint from '@mapbox/geojsonhint';\nimport * as Constants from './constants';\nimport StringSet from './lib/string_set';\n\nimport Polygon from './feature_types/polygon';\nimport LineString from './feature_types/line_string';\nimport Point from './feature_types/point';\nimport MultiFeature from './feature_types/multi_feature';\n\nconst featureTypes = {\n  Polygon,\n  LineString,\n  Point,\n  MultiPolygon: MultiFeature,\n  MultiLineString: MultiFeature,\n  MultiPoint: MultiFeature\n};\n\nexport default function(ctx, api) {\n\n  api.modes = Constants.modes;\n\n  api.getFeatureIdsAt = function(point) {\n    const features = featuresAt.click({ point }, null, ctx);\n    return features.map(feature => feature.properties.id);\n  };\n\n  api.getSelectedIds = function () {\n    return ctx.store.getSelectedIds();\n  };\n\n  api.getSelected = function () {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getSelectedIds().map(id => ctx.store.get(id)).map(feature => feature.toGeoJSON())\n    };\n  };\n\n  api.getSelectedPoints = function () {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getSelectedCoordinates().map(coordinate => ({\n        type: Constants.geojsonTypes.FEATURE,\n        properties: {},\n        geometry: {\n          type: Constants.geojsonTypes.POINT,\n          coordinates: coordinate.coordinates\n        }\n      }))\n    };\n  };\n\n  api.set = function(featureCollection) {\n    if (featureCollection.type === undefined || featureCollection.type !== Constants.geojsonTypes.FEATURE_COLLECTION || !Array.isArray(featureCollection.features)) {\n      throw new Error('Invalid FeatureCollection');\n    }\n    const renderBatch = ctx.store.createRenderBatch();\n    let toDelete = ctx.store.getAllIds().slice();\n    const newIds = api.add(featureCollection);\n    const newIdsLookup = new StringSet(newIds);\n\n    toDelete = toDelete.filter(id => !newIdsLookup.has(id));\n    if (toDelete.length) {\n      api.delete(toDelete);\n    }\n\n    renderBatch();\n    return newIds;\n  };\n\n  api.add = function (geojson) {\n    const errors = geojsonhint.hint(geojson, { precisionWarning: false }).filter(e => e.level !== 'message');\n    if (errors.length) {\n      throw new Error(errors[0].message);\n    }\n    const featureCollection = JSON.parse(JSON.stringify(normalize(geojson)));\n\n    const ids = featureCollection.features.map((feature) => {\n      feature.id = feature.id || hat();\n\n      if (feature.geometry === null) {\n        throw new Error('Invalid geometry: null');\n      }\n\n      if (ctx.store.get(feature.id) === undefined || ctx.store.get(feature.id).type !== feature.geometry.type) {\n        // If the feature has not yet been created ...\n        const Model = featureTypes[feature.geometry.type];\n        if (Model === undefined) {\n          throw new Error(`Invalid geometry type: ${feature.geometry.type}.`);\n        }\n        const internalFeature = new Model(ctx, feature);\n        ctx.store.add(internalFeature);\n      } else {\n        // If a feature of that id has already been created, and we are swapping it out ...\n        const internalFeature = ctx.store.get(feature.id);\n        internalFeature.properties = feature.properties;\n        if (!isEqual(internalFeature.getCoordinates(), feature.geometry.coordinates)) {\n          internalFeature.incomingCoords(feature.geometry.coordinates);\n        }\n      }\n      return feature.id;\n    });\n\n    ctx.store.render();\n    return ids;\n  };\n\n\n  api.get = function (id) {\n    const feature = ctx.store.get(id);\n    if (feature) {\n      return feature.toGeoJSON();\n    }\n  };\n\n  api.getAll = function() {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getAll().map(feature => feature.toGeoJSON())\n    };\n  };\n\n  api.delete = function(featureIds) {\n    ctx.store.delete(featureIds, { silent: true });\n    // If we were in direct select mode and our selected feature no longer exists\n    // (because it was deleted), we need to get out of that mode.\n    if (api.getMode() === Constants.modes.DIRECT_SELECT && !ctx.store.getSelectedIds().length) {\n      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, { silent: true });\n    } else {\n      ctx.store.render();\n    }\n\n    return api;\n  };\n\n  api.deleteAll = function() {\n    ctx.store.delete(ctx.store.getAllIds(), { silent: true });\n    // If we were in direct select mode, now our selected feature no longer exists,\n    // so escape that mode.\n    if (api.getMode() === Constants.modes.DIRECT_SELECT) {\n      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, { silent: true });\n    } else {\n      ctx.store.render();\n    }\n\n    return api;\n  };\n\n  api.changeMode = function(mode, modeOptions = {}) {\n    // Avoid changing modes just to re-select what's already selected\n    if (mode === Constants.modes.SIMPLE_SELECT && api.getMode() === Constants.modes.SIMPLE_SELECT) {\n      if (stringSetsAreEqual((modeOptions.featureIds || []), ctx.store.getSelectedIds())) return api;\n      // And if we are changing the selection within simple_select mode, just change the selection,\n      // instead of stopping and re-starting the mode\n      ctx.store.setSelected(modeOptions.featureIds, { silent: true });\n      ctx.store.render();\n      return api;\n    }\n\n    if (mode === Constants.modes.DIRECT_SELECT && api.getMode() === Constants.modes.DIRECT_SELECT &&\n      modeOptions.featureId === ctx.store.getSelectedIds()[0]) {\n      return api;\n    }\n\n    ctx.events.changeMode(mode, modeOptions, { silent: true });\n    return api;\n  };\n\n  api.getMode = function() {\n    return ctx.events.getMode();\n  };\n\n  api.trash = function() {\n    ctx.events.trash({ silent: true });\n    return api;\n  };\n\n  api.combineFeatures = function() {\n    ctx.events.combineFeatures({ silent: true });\n    return api;\n  };\n\n  api.uncombineFeatures = function() {\n    ctx.events.uncombineFeatures({ silent: true });\n    return api;\n  };\n\n  api.setFeatureProperty = function(featureId, property, value) {\n    ctx.store.setFeatureProperty(featureId, property, value);\n    return api;\n  };\n\n  return api;\n}\n"]},"metadata":{},"sourceType":"module"}