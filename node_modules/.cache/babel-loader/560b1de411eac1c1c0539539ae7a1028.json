{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _awaitAsyncGenerator from \"@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nvar DEFAULT_CHUNK_SIZE = 1024 * 1024;\nexport function makeBlobIterator(_x) {\n  return _makeBlobIterator.apply(this, arguments);\n}\n\nfunction _makeBlobIterator() {\n  _makeBlobIterator = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee(file) {\n    var options,\n        chunkSize,\n        offset,\n        end,\n        slice,\n        chunk,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            chunkSize = options.chunkSize || DEFAULT_CHUNK_SIZE;\n            offset = 0;\n\n          case 3:\n            if (!(offset < file.size)) {\n              _context.next = 14;\n              break;\n            }\n\n            end = offset + chunkSize;\n            slice = file.slice(offset, end);\n            _context.next = 8;\n            return _awaitAsyncGenerator(readFileSlice(slice));\n\n          case 8:\n            chunk = _context.sent;\n            offset = end;\n            _context.next = 12;\n            return chunk;\n\n          case 12:\n            _context.next = 3;\n            break;\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _makeBlobIterator.apply(this, arguments);\n}\n\nfunction readFileSlice(_x2) {\n  return _readFileSlice.apply(this, arguments);\n}\n\nfunction _readFileSlice() {\n  _readFileSlice = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(slice) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return new Promise(function (resolve, reject) {\n              var fileReader = new FileReader();\n\n              fileReader.onloadend = function (event) {\n                return resolve(event.target.result);\n              };\n\n              fileReader.onerror = function (error) {\n                return reject(error);\n              };\n\n              fileReader.readAsArrayBuffer(slice);\n            });\n\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _readFileSlice.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/iterator-utils/make-iterator/blob-iterator.js"],"names":["DEFAULT_CHUNK_SIZE","options","chunkSize","offset","file","end","slice","chunk","readFileSlice","fileReader","resolve","event","reject"],"mappings":";;;;AAEA,IAAMA,kBAAkB,GAAG,OAA3B,IAAA;AAEA,OAAA,SAAA,gBAAA,CAAA,EAAA,EAAA;AAAA,SAAA,iBAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA;AAAA;;;mEAAO,SAAA,OAAA,CAAA,IAAA,EAAA;AAAA,QAAA,OAAA;AAAA,QAAA,SAAA;AAAA,QAAA,MAAA;AAAA,QAAA,GAAA;AAAA,QAAA,KAAA;AAAA,QAAA,KAAA;AAAA,QAAA,KAAA,GAAA,SAAA;AAAA,WAAA,mBAAA,CAAA,IAAA,CAAA,SAAA,QAAA,CAAA,QAAA,EAAA;AAAA,aAAA,CAAA,EAAA;AAAA,gBAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;AAAA,eAAA,CAAA;AAAuCC,YAAAA,OAAvC,GAAA,KAAA,CAAA,MAAA,GAAA,CAAA,IAAA,KAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,KAAA,CAAA,CAAA,CAAA,GAAA,EAAuCA;AACtCC,YAAAA,SADD,GACaD,OAAO,CAAPA,SAAAA,IADb,kBACCC;AAEFC,YAAAA,MAHC,GAAA,CAGDA;;AAHC,eAAA,CAAA;AAAA,gBAAA,EAIEA,MAAM,GAAGC,IAAI,CAJf,IAAA,CAAA,EAAA;AAAA,cAAA,QAAA,CAAA,IAAA,GAAA,EAAA;AAAA;AAAA;;AAKGC,YAAAA,GALH,GAKSF,MAAM,GALf,SAKGE;AAKAC,YAAAA,KAVH,GAUWF,IAAI,CAAJA,KAAAA,CAAAA,MAAAA,EAVX,GAUWA,CAARE;AAVH,YAAA,QAAA,CAAA,IAAA,GAAA,CAAA;AAAA,mBAAA,oBAAA,CAYiBE,aAAa,CAZ9B,KAY8B,CAZ9B,CAAA;;AAAA,eAAA,CAAA;AAYGD,YAAAA,KAZH,GAAA,QAAA,CAAA,IAYGA;AAENJ,YAAAA,MAAM,GAANA,GAAAA;AAdG,YAAA,QAAA,CAAA,IAAA,GAAA,EAAA;AAeH,mBAAA,KAAA;;AAfG,eAAA,EAAA;AAAA,YAAA,QAAA,CAAA,IAAA,GAAA,CAAA;AAAA;;AAAA,eAAA,EAAA;AAAA,eAAA,KAAA;AAAA,mBAAA,QAAA,CAAA,IAAA,EAAA;AAAA;AAAA;AAAA,KAAA,EAAA,OAAA,CAAA;;;;;SAmBQK,a;;;;;8DAAf,SAAA,QAAA,CAAA,KAAA,EAAA;AAAA,WAAA,mBAAA,CAAA,IAAA,CAAA,SAAA,SAAA,CAAA,SAAA,EAAA;AAAA,aAAA,CAAA,EAAA;AAAA,gBAAA,SAAA,CAAA,IAAA,GAAA,SAAA,CAAA,IAAA;AAAA,eAAA,CAAA;AAAA,YAAA,SAAA,CAAA,IAAA,GAAA,CAAA;AAAA,mBACe,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AAC5C,kBAAMC,UAAU,GAAG,IAAnB,UAAmB,EAAnB;;AACAA,cAAAA,UAAU,CAAVA,SAAAA,GAAuB,UAAA,KAAA,EAAK;AAAA,uBAAIC,OAAO,CAACC,KAAK,CAALA,MAAAA,CAAZ,MAAW,CAAX;AAA5BF,eAAAA;;AACAA,cAAAA,UAAU,CAAVA,OAAAA,GAAqB,UAAA,KAAA,EAAK;AAAA,uBAAIG,MAAM,CAAV,KAAU,CAAV;AAA1BH,eAAAA;;AACAA,cAAAA,UAAU,CAAVA,iBAAAA,CAAAA,KAAAA;AALJ,aACe,CADf;;AAAA,eAAA,CAAA;AAAA,mBAAA,SAAA,CAAA,MAAA,CAAA,QAAA,EAAA,SAAA,CAAA,IAAA,CAAA;;AAAA,eAAA,CAAA;AAAA,eAAA,KAAA;AAAA,mBAAA,SAAA,CAAA,IAAA,EAAA;AAAA;AAAA;AAAA,KAAA,EAAA,QAAA,CAAA","sourcesContent":["/* global FileReader */\n\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024; // 1MB â€” biggest value that keeps UI responsive\n\nexport async function* makeBlobIterator(file, options = {}) {\n  const chunkSize = options.chunkSize || DEFAULT_CHUNK_SIZE;\n\n  let offset = 0;\n  while (offset < file.size) {\n    const end = offset + chunkSize;\n\n    // The trick when reading File objects is to read successive \"slices\" of the File\n    // Per spec https://w3c.github.io/FileAPI/, slicing a File should only update the start and end fields\n    // Actually reading from file should happen in `readAsArrayBuffer` (and as far we can tell it does)\n    const slice = file.slice(offset, end);\n\n    const chunk = await readFileSlice(slice);\n\n    offset = end;\n    yield chunk;\n  }\n}\n\nasync function readFileSlice(slice) {\n  return await new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onloadend = event => resolve(event.target.result);\n    fileReader.onerror = error => reject(error);\n    fileReader.readAsArrayBuffer(slice);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}