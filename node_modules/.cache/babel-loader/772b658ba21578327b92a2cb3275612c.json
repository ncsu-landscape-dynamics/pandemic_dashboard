{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Matrix4 } from 'math.gl';\nimport Viewport from './viewport';\nimport { PROJECTION_MODE } from '../lib/constants';\nimport * as vec3 from 'gl-matrix/vec3';\nimport * as vec4 from 'gl-matrix/vec4';\nvar DEGREES_TO_RADIANS = Math.PI / 180;\nvar RADIANS_TO_DEGREES = 180 / Math.PI;\nvar EARTH_RADIUS = 6370972;\nvar GLOBE_RADIUS = 256;\n\nfunction getDistanceScales() {\n  var unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n  var unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;\n  return {\n    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n    unitsPerMeter2: [0, 0, 0],\n    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n    unitsPerDegree2: [0, 0, 0],\n    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n  };\n}\n\nvar GlobeViewport = function (_Viewport) {\n  _inherits(GlobeViewport, _Viewport);\n\n  function GlobeViewport() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GlobeViewport);\n\n    var _opts$latitude = opts.latitude,\n        latitude = _opts$latitude === void 0 ? 0 : _opts$latitude,\n        _opts$longitude = opts.longitude,\n        longitude = _opts$longitude === void 0 ? 0 : _opts$longitude,\n        _opts$zoom = opts.zoom,\n        zoom = _opts$zoom === void 0 ? 11 : _opts$zoom,\n        _opts$nearZMultiplier = opts.nearZMultiplier,\n        nearZMultiplier = _opts$nearZMultiplier === void 0 ? 0.1 : _opts$nearZMultiplier,\n        _opts$farZMultiplier = opts.farZMultiplier,\n        farZMultiplier = _opts$farZMultiplier === void 0 ? 1 : _opts$farZMultiplier,\n        _opts$resolution = opts.resolution,\n        resolution = _opts$resolution === void 0 ? 10 : _opts$resolution;\n    var width = opts.width,\n        height = opts.height,\n        _opts$altitude = opts.altitude,\n        altitude = _opts$altitude === void 0 ? 1.5 : _opts$altitude;\n    width = width || 1;\n    height = height || 1;\n    altitude = Math.max(0.75, altitude);\n    var viewMatrix = new Matrix4().lookAt({\n      eye: [0, -altitude, 0],\n      up: [0, 0, 1]\n    });\n    var scale = Math.pow(2, zoom);\n    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n    viewMatrix.scale(scale / height);\n    var halfFov = Math.atan(0.5 / altitude);\n    var relativeScale = GLOBE_RADIUS * 2 * scale / height;\n    var viewportOpts = Object.assign({}, opts, {\n      width: width,\n      height: height,\n      viewMatrix: viewMatrix,\n      longitude: longitude,\n      latitude: latitude,\n      zoom: zoom,\n      fovyRadians: halfFov * 2,\n      aspect: width / height,\n      focalDistance: altitude,\n      near: nearZMultiplier,\n      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier\n    });\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GlobeViewport).call(this, viewportOpts));\n    _this.resolution = resolution;\n    _this.distanceScales = getDistanceScales();\n    return _this;\n  }\n\n  _createClass(GlobeViewport, [{\n    key: \"getDistanceScales\",\n    value: function getDistanceScales() {\n      return this.distanceScales;\n    }\n  }, {\n    key: \"unproject\",\n    value: function unproject(xyz) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$topLeft = _ref.topLeft,\n          topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft,\n          targetZ = _ref.targetZ;\n\n      var _xyz = _slicedToArray(xyz, 3),\n          x = _xyz[0],\n          y = _xyz[1],\n          z = _xyz[2];\n\n      var y2 = topLeft ? y : this.height - y;\n      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;\n      var coord;\n\n      if (Number.isFinite(z)) {\n        coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n      } else {\n        var coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n        var coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n        var lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n        var lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n        var l0Sqr = vec3.sqrLen(coord0);\n        var l1Sqr = vec3.sqrLen(coord1);\n        var sSqr = (4 * l0Sqr * l1Sqr - Math.pow(lSqr - l0Sqr - l1Sqr, 2)) / 16;\n        var dSqr = 4 * sSqr / lSqr;\n        var r0 = Math.sqrt(l0Sqr - dSqr);\n        var dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n        var t = (r0 - dr) / Math.sqrt(lSqr);\n        coord = vec3.lerp([], coord0, coord1, t);\n      }\n\n      var _this$unprojectPositi = this.unprojectPosition(coord),\n          _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3),\n          X = _this$unprojectPositi2[0],\n          Y = _this$unprojectPositi2[1],\n          Z = _this$unprojectPositi2[2];\n\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    }\n  }, {\n    key: \"projectPosition\",\n    value: function projectPosition(xyz) {\n      var _xyz2 = _slicedToArray(xyz, 3),\n          lng = _xyz2[0],\n          lat = _xyz2[1],\n          _xyz2$ = _xyz2[2],\n          Z = _xyz2$ === void 0 ? 0 : _xyz2$;\n\n      var lambda = lng * DEGREES_TO_RADIANS;\n      var phi = lat * DEGREES_TO_RADIANS;\n      var cosPhi = Math.cos(phi);\n      var D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n      return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n    }\n  }, {\n    key: \"unprojectPosition\",\n    value: function unprojectPosition(xyz) {\n      var _xyz3 = _slicedToArray(xyz, 3),\n          x = _xyz3[0],\n          y = _xyz3[1],\n          z = _xyz3[2];\n\n      var D = vec3.len(xyz);\n      var phi = Math.asin(z / D);\n      var lambda = Math.atan2(x, -y);\n      var lng = lambda * RADIANS_TO_DEGREES;\n      var lat = phi * RADIANS_TO_DEGREES;\n      var Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n      return [lng, lat, Z];\n    }\n  }, {\n    key: \"projectFlat\",\n    value: function projectFlat(xyz) {\n      return xyz;\n    }\n  }, {\n    key: \"unprojectFlat\",\n    value: function unprojectFlat(xyz) {\n      return xyz;\n    }\n  }, {\n    key: \"getMapCenterByLngLatPosition\",\n    value: function getMapCenterByLngLatPosition(_ref2) {\n      var lngLat = _ref2.lngLat,\n          pos = _ref2.pos;\n      var fromPosition = this.unproject(pos);\n      return [lngLat[0] - fromPosition[0] + this.longitude, lngLat[1] - fromPosition[1] + this.latitude];\n    }\n  }, {\n    key: \"projectionMode\",\n    get: function get() {\n      return PROJECTION_MODE.GLOBE;\n    }\n  }]);\n\n  return GlobeViewport;\n}(Viewport);\n\nexport { GlobeViewport as default };\n\nfunction transformVector(matrix, vector) {\n  var result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}","map":{"version":3,"sources":["../../../src/viewports/globe-viewport.js"],"names":["DEGREES_TO_RADIANS","Math","RADIANS_TO_DEGREES","EARTH_RADIUS","GLOBE_RADIUS","unitsPerMeter","unitsPerDegree","unitsPerMeter2","metersPerUnit","unitsPerDegree2","degreesPerUnit","GlobeViewport","Viewport","opts","latitude","longitude","zoom","nearZMultiplier","farZMultiplier","resolution","width","height","altitude","viewMatrix","eye","up","scale","halfFov","relativeScale","viewportOpts","fovyRadians","aspect","focalDistance","near","far","getDistanceScales","PROJECTION_MODE","xyz","topLeft","targetZ","x","y","z","y2","pixelUnprojectionMatrix","Number","coord","transformVector","coord0","coord1","lt","lSqr","vec3","l0Sqr","l1Sqr","sSqr","dSqr","r0","dr","t","X","Y","Z","lng","lat","lambda","phi","cosPhi","D","lngLat","pos","fromPosition","result","vec4"],"mappings":"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","sourcesContent":["import {Matrix4} from 'math.gl';\nimport Viewport from './viewport';\nimport {PROJECTION_MODE} from '../lib/constants';\n\nimport * as vec3 from 'gl-matrix/vec3';\nimport * as vec4 from 'gl-matrix/vec4';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\nconst EARTH_RADIUS = 6370972;\nconst GLOBE_RADIUS = 256;\n\nfunction getDistanceScales() {\n  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n  const unitsPerDegree = (Math.PI / 180) * GLOBE_RADIUS;\n\n  return {\n    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n    unitsPerMeter2: [0, 0, 0],\n    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n    unitsPerDegree2: [0, 0, 0],\n    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n  };\n}\n\nexport default class GlobeViewport extends Viewport {\n  constructor(opts = {}) {\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 11,\n      nearZMultiplier = 0.1,\n      farZMultiplier = 1,\n      resolution = 10\n    } = opts;\n\n    let {width, height, altitude = 1.5} = opts;\n\n    width = width || 1;\n    height = height || 1;\n    altitude = Math.max(0.75, altitude);\n\n    // Calculate view matrix\n    const viewMatrix = new Matrix4().lookAt({eye: [0, -altitude, 0], up: [0, 0, 1]});\n    const scale = Math.pow(2, zoom);\n    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n    viewMatrix.scale(scale / height);\n\n    const halfFov = Math.atan(0.5 / altitude);\n    const relativeScale = (GLOBE_RADIUS * 2 * scale) / height;\n\n    const viewportOpts = Object.assign({}, opts, {\n      // x, y,\n      width,\n      height,\n\n      // view matrix\n      viewMatrix,\n      longitude,\n      latitude,\n      zoom,\n\n      // projection matrix parameters\n      fovyRadians: halfFov * 2,\n      aspect: width / height,\n      focalDistance: altitude,\n      near: nearZMultiplier,\n      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier\n    });\n\n    super(viewportOpts);\n\n    this.resolution = resolution;\n    this.distanceScales = getDistanceScales();\n  }\n\n  get projectionMode() {\n    return PROJECTION_MODE.GLOBE;\n  }\n\n  getDistanceScales() {\n    return this.distanceScales;\n  }\n\n  unproject(xyz, {topLeft = true, targetZ} = {}) {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const {pixelUnprojectionMatrix} = this;\n\n    let coord;\n    if (Number.isFinite(z)) {\n      // Has depth component\n      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n    } else {\n      // since we don't know the correct projected z value for the point,\n      // unproject two points to get a line and then find the point on that line that intersects with the sphere\n      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n\n      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n      const l0Sqr = vec3.sqrLen(coord0);\n      const l1Sqr = vec3.sqrLen(coord1);\n      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;\n      const dSqr = (4 * sSqr) / lSqr;\n      const r0 = Math.sqrt(l0Sqr - dSqr);\n      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n      const t = (r0 - dr) / Math.sqrt(lSqr);\n\n      coord = vec3.lerp([], coord0, coord1, t);\n    }\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  projectPosition(xyz) {\n    const [lng, lat, Z = 0] = xyz;\n    const lambda = lng * DEGREES_TO_RADIANS;\n    const phi = lat * DEGREES_TO_RADIANS;\n    const cosPhi = Math.cos(phi);\n    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n\n    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n  }\n\n  unprojectPosition(xyz) {\n    const [x, y, z] = xyz;\n    const D = vec3.len(xyz);\n    const phi = Math.asin(z / D);\n    const lambda = Math.atan2(x, -y);\n\n    const lng = lambda * RADIANS_TO_DEGREES;\n    const lat = phi * RADIANS_TO_DEGREES;\n    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n    return [lng, lat, Z];\n  }\n\n  projectFlat(xyz) {\n    return xyz;\n  }\n\n  unprojectFlat(xyz) {\n    return xyz;\n  }\n\n  getMapCenterByLngLatPosition({lngLat, pos}) {\n    const fromPosition = this.unproject(pos);\n    return [\n      lngLat[0] - fromPosition[0] + this.longitude,\n      lngLat[1] - fromPosition[1] + this.latitude\n    ];\n  }\n}\n\nfunction transformVector(matrix, vector) {\n  const result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}