{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _DEFAULT_TEXTURE_PARA;\n\nimport { Layer, project32, picking } from '@deck.gl/core';\nimport { Model, Geometry, Texture2D } from '@luma.gl/core';\nimport createMesh from './create-mesh';\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\nvar DEFAULT_TEXTURE_PARAMETERS = (_DEFAULT_TEXTURE_PARA = {}, _defineProperty(_DEFAULT_TEXTURE_PARA, 10241, 9987), _defineProperty(_DEFAULT_TEXTURE_PARA, 10240, 9729), _defineProperty(_DEFAULT_TEXTURE_PARA, 10242, 33071), _defineProperty(_DEFAULT_TEXTURE_PARA, 10243, 33071), _DEFAULT_TEXTURE_PARA);\nvar defaultProps = {\n  image: {\n    type: 'object',\n    value: null,\n    async: true\n  },\n  bounds: {\n    type: 'array',\n    value: [1, 0, 0, 1],\n    compare: true\n  },\n  desaturate: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0\n  },\n  transparentColor: {\n    type: 'color',\n    value: [0, 0, 0, 0]\n  },\n  tintColor: {\n    type: 'color',\n    value: [255, 255, 255]\n  }\n};\n\nvar BitmapLayer = function (_Layer) {\n  _inherits(BitmapLayer, _Layer);\n\n  function BitmapLayer() {\n    _classCallCheck(this, BitmapLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BitmapLayer).apply(this, arguments));\n  }\n\n  _createClass(BitmapLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return _get(_getPrototypeOf(BitmapLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        modules: [project32, picking]\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n\n      var attributeManager = this.getAttributeManager();\n      attributeManager.remove(['instancePickingColors']);\n      var noAlloc = true;\n      attributeManager.add({\n        indices: {\n          size: 1,\n          isIndexed: true,\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.indices;\n          },\n          noAlloc: noAlloc\n        },\n        positions: {\n          size: 3,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.positions;\n          },\n          noAlloc: noAlloc\n        },\n        texCoords: {\n          size: 2,\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.texCoords;\n          },\n          noAlloc: noAlloc\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      if (changeFlags.extensionsChanged) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model[\"delete\"]();\n        }\n\n        this.setState({\n          model: this._getModel(gl)\n        });\n        this.getAttributeManager().invalidateAll();\n      }\n\n      if (props.image !== oldProps.image) {\n        this.loadTexture(props.image);\n      }\n\n      var attributeManager = this.getAttributeManager();\n\n      if (props.bounds !== oldProps.bounds) {\n        var oldMesh = this.state.mesh;\n\n        var mesh = this._createMesh();\n\n        this.state.model.setVertexCount(mesh.vertexCount);\n\n        for (var key in mesh) {\n          if (oldMesh && oldMesh[key] !== mesh[key]) {\n            attributeManager.invalidate(key);\n          }\n        }\n\n        this.setState({\n          mesh: mesh\n        });\n      }\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      _get(_getPrototypeOf(BitmapLayer.prototype), \"finalizeState\", this).call(this);\n\n      if (this.state.bitmapTexture) {\n        this.state.bitmapTexture[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"_createMesh\",\n    value: function _createMesh() {\n      var bounds = this.props.bounds;\n      var normalizedBounds = bounds;\n\n      if (Number.isFinite(bounds[0])) {\n        normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];\n      }\n\n      return createMesh(normalizedBounds, this.context.viewport.resolution);\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      if (!gl) {\n        return null;\n      }\n\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 4,\n          vertexCount: 6\n        }),\n        isInstanced: false\n      }));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(opts) {\n      var uniforms = opts.uniforms;\n      var _this$state = this.state,\n          bitmapTexture = _this$state.bitmapTexture,\n          model = _this$state.model;\n      var _this$props = this.props,\n          image = _this$props.image,\n          desaturate = _this$props.desaturate,\n          transparentColor = _this$props.transparentColor,\n          tintColor = _this$props.tintColor;\n\n      if (bitmapTexture && image instanceof HTMLVideoElement && image.readyState > HTMLVideoElement.HAVE_METADATA) {\n        var sizeChanged = bitmapTexture.width !== image.videoWidth || bitmapTexture.height !== image.videoHeight;\n\n        if (sizeChanged) {\n          bitmapTexture.resize({\n            width: image.videoWidth,\n            height: image.videoHeight,\n            mipmaps: true\n          });\n          bitmapTexture.setSubImageData({\n            data: image,\n            paramters: DEFAULT_TEXTURE_PARAMETERS\n          });\n        } else {\n          bitmapTexture.setSubImageData({\n            data: image\n          });\n        }\n\n        bitmapTexture.generateMipmap();\n      }\n\n      if (bitmapTexture && model) {\n        model.setUniforms(Object.assign({}, uniforms, {\n          bitmapTexture: bitmapTexture,\n          desaturate: desaturate,\n          transparentColor: transparentColor.map(function (x) {\n            return x / 255;\n          }),\n          tintColor: tintColor.slice(0, 3).map(function (x) {\n            return x / 255;\n          })\n        })).draw();\n      }\n    }\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture(image) {\n      var gl = this.context.gl;\n\n      if (this.state.bitmapTexture) {\n        this.state.bitmapTexture[\"delete\"]();\n      }\n\n      if (image instanceof Texture2D) {\n        this.setState({\n          bitmapTexture: image\n        });\n      } else if (image instanceof HTMLVideoElement) {\n        this.setState({\n          bitmapTexture: new Texture2D(gl, {\n            width: 1,\n            height: 1,\n            parameters: DEFAULT_TEXTURE_PARAMETERS,\n            mipmaps: false\n          })\n        });\n      } else if (image) {\n        this.setState({\n          bitmapTexture: new Texture2D(gl, {\n            data: image,\n            parameters: DEFAULT_TEXTURE_PARAMETERS\n          })\n        });\n      }\n    }\n  }]);\n\n  return BitmapLayer;\n}(Layer);\n\nexport { BitmapLayer as default };\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/bitmap-layer/bitmap-layer.js"],"names":["DEFAULT_TEXTURE_PARAMETERS","defaultProps","image","type","value","async","bounds","compare","desaturate","min","max","transparentColor","tintColor","BitmapLayer","Layer","vs","fs","modules","attributeManager","noAlloc","indices","size","isIndexed","update","attribute","positions","fp64","texCoords","props","oldProps","changeFlags","gl","model","oldMesh","mesh","normalizedBounds","Number","createMesh","id","geometry","drawMode","vertexCount","isInstanced","opts","uniforms","bitmapTexture","HTMLVideoElement","sizeChanged","width","height","mipmaps","data","paramters","x","parameters"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global HTMLVideoElement */\nimport GL from '@luma.gl/constants';\nimport {Layer, project32, picking} from '@deck.gl/core';\nimport {Model, Geometry, Texture2D} from '@luma.gl/core';\nimport createMesh from './create-mesh';\n\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\nconst defaultProps = {\n  image: {type: 'object', value: null, async: true},\n  bounds: {type: 'array', value: [1, 0, 0, 1], compare: true},\n\n  desaturate: {type: 'number', min: 0, max: 1, value: 0},\n  // More context: because of the blending mode we're using for ground imagery,\n  // alpha is not effective when blending the bitmap layers with the base map.\n  // Instead we need to manually dim/blend rgb values with a background color.\n  transparentColor: {type: 'color', value: [0, 0, 0, 0]},\n  tintColor: {type: 'color', value: [255, 255, 255]}\n};\n\n/*\n * @class\n * @param {object} props\n * @param {number} props.transparentColor - color to interpret transparency to\n * @param {number} props.tintColor - color bias\n */\nexport default class BitmapLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => (attribute.value = this.state.mesh.indices),\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        update: attribute => (attribute.value = this.state.mesh.positions),\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => (attribute.value = this.state.mesh.texCoords),\n        noAlloc\n      }\n    });\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    // setup model first\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      this.getAttributeManager().invalidateAll();\n    }\n\n    if (props.image !== oldProps.image) {\n      this.loadTexture(props.image);\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n      const mesh = this._createMesh();\n      this.state.model.setVertexCount(mesh.vertexCount);\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n      this.setState({mesh});\n    }\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    if (this.state.bitmapTexture) {\n      this.state.bitmapTexture.delete();\n    }\n  }\n\n  _createMesh() {\n    const {bounds} = this.props;\n\n    let normalizedBounds = bounds;\n    // bounds as [minX, minY, maxX, maxY]\n    if (Number.isFinite(bounds[0])) {\n      /*\n        (minX0, maxY3) ---- (maxX2, maxY3)\n               |                  |\n               |                  |\n               |                  |\n        (minX0, minY1) ---- (maxX2, minY1)\n     */\n      normalizedBounds = [\n        [bounds[0], bounds[1]],\n        [bounds[0], bounds[3]],\n        [bounds[2], bounds[3]],\n        [bounds[2], bounds[1]]\n      ];\n    }\n\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n\n  _getModel(gl) {\n    if (!gl) {\n      return null;\n    }\n\n    /*\n      0,0 --- 1,0\n       |       |\n      0,1 --- 1,1\n    */\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLES,\n          vertexCount: 6\n        }),\n        isInstanced: false\n      })\n    );\n  }\n\n  draw(opts) {\n    const {uniforms} = opts;\n    const {bitmapTexture, model} = this.state;\n    const {image, desaturate, transparentColor, tintColor} = this.props;\n\n    // Update video frame\n    if (\n      bitmapTexture &&\n      image instanceof HTMLVideoElement &&\n      image.readyState > HTMLVideoElement.HAVE_METADATA\n    ) {\n      const sizeChanged =\n        bitmapTexture.width !== image.videoWidth || bitmapTexture.height !== image.videoHeight;\n      if (sizeChanged) {\n        // note clears image and mipmaps when resizing\n        bitmapTexture.resize({width: image.videoWidth, height: image.videoHeight, mipmaps: true});\n        bitmapTexture.setSubImageData({\n          data: image,\n          paramters: DEFAULT_TEXTURE_PARAMETERS\n        });\n      } else {\n        bitmapTexture.setSubImageData({\n          data: image\n        });\n      }\n\n      bitmapTexture.generateMipmap();\n    }\n\n    // // TODO fix zFighting\n    // Render the image\n    if (bitmapTexture && model) {\n      model\n        .setUniforms(\n          Object.assign({}, uniforms, {\n            bitmapTexture,\n            desaturate,\n            transparentColor: transparentColor.map(x => x / 255),\n            tintColor: tintColor.slice(0, 3).map(x => x / 255)\n          })\n        )\n        .draw();\n    }\n  }\n\n  loadTexture(image) {\n    const {gl} = this.context;\n\n    if (this.state.bitmapTexture) {\n      this.state.bitmapTexture.delete();\n    }\n\n    if (image instanceof Texture2D) {\n      this.setState({bitmapTexture: image});\n    } else if (image instanceof HTMLVideoElement) {\n      // Initialize an empty texture while we wait for the video to load\n      this.setState({\n        bitmapTexture: new Texture2D(gl, {\n          width: 1,\n          height: 1,\n          parameters: DEFAULT_TEXTURE_PARAMETERS,\n          mipmaps: false\n        })\n      });\n    } else if (image) {\n      // Browser object: Image, ImageData, HTMLCanvasElement, ImageBitmap\n      this.setState({\n        bitmapTexture: new Texture2D(gl, {\n          data: image,\n          parameters: DEFAULT_TEXTURE_PARAMETERS\n        })\n      });\n    }\n  }\n}\n\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}