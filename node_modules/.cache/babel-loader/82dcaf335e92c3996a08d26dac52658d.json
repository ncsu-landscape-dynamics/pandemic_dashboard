{"ast":null,"code":"'use strict';\n/**\n * Validators are functions which assert certain type.\n * They can return a string which can then be used\n * to display a helpful error message.\n * They can also return a function for a custom error message.\n */\n\nvar isPlainObject = require('is-plain-obj');\n\nvar xtend = require('xtend');\n\nvar DEFAULT_ERROR_PATH = 'value';\nvar NEWLINE_INDENT = '\\n  ';\nvar v = {};\n/**\n * Runners\n *\n * Take root validators and run assertion\n */\n\nv.assert = function (rootValidator, options) {\n  options = options || {};\n  return function (value) {\n    var message = validate(rootValidator, value); // all good\n\n    if (!message) {\n      return;\n    }\n\n    var errorMessage = processMessage(message, options);\n\n    if (options.apiName) {\n      errorMessage = options.apiName + ': ' + errorMessage;\n    }\n\n    throw new Error(errorMessage);\n  };\n};\n/**\n * Higher Order Validators\n *\n * validators which take other validators as input\n * and output a new validator\n */\n\n\nv.shape = function shape(validatorObj) {\n  var validators = objectEntries(validatorObj);\n  return function shapeValidator(value) {\n    var validationResult = validate(v.plainObject, value);\n\n    if (validationResult) {\n      return validationResult;\n    }\n\n    var key, validator;\n    var errorMessages = [];\n\n    for (var i = 0; i < validators.length; i++) {\n      key = validators[i].key;\n      validator = validators[i].value;\n      validationResult = validate(validator, value[key]);\n\n      if (validationResult) {\n        // return [key].concat(validationResult);\n        errorMessages.push([key].concat(validationResult));\n      }\n    }\n\n    if (errorMessages.length < 2) {\n      return errorMessages[0];\n    } // enumerate all the error messages\n\n\n    return function (options) {\n      errorMessages = errorMessages.map(function (message) {\n        var key = message[0];\n        var renderedMessage = processMessage(message, options).split('\\n').join(NEWLINE_INDENT); // indents any inner nesting\n\n        return '- ' + key + ': ' + renderedMessage;\n      });\n      var objectId = options.path.join('.');\n      var ofPhrase = objectId === DEFAULT_ERROR_PATH ? '' : ' of ' + objectId;\n      return 'The following properties' + ofPhrase + ' have invalid values:' + NEWLINE_INDENT + errorMessages.join(NEWLINE_INDENT);\n    };\n  };\n};\n\nv.strictShape = function strictShape(validatorObj) {\n  var shapeValidator = v.shape(validatorObj);\n  return function strictShapeValidator(value) {\n    var shapeResult = shapeValidator(value);\n\n    if (shapeResult) {\n      return shapeResult;\n    }\n\n    var invalidKeys = Object.keys(value).reduce(function (memo, valueKey) {\n      if (validatorObj[valueKey] === undefined) {\n        memo.push(valueKey);\n      }\n\n      return memo;\n    }, []);\n\n    if (invalidKeys.length !== 0) {\n      return function () {\n        return 'The following keys are invalid: ' + invalidKeys.join(', ');\n      };\n    }\n  };\n};\n\nv.arrayOf = function arrayOf(validator) {\n  return createArrayValidator(validator);\n};\n\nv.tuple = function tuple() {\n  var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);\n  return createArrayValidator(validators);\n}; // Currently array validation fails when the first invalid item is found.\n\n\nfunction createArrayValidator(validators) {\n  var validatingTuple = Array.isArray(validators);\n\n  var getValidator = function (index) {\n    if (validatingTuple) {\n      return validators[index];\n    }\n\n    return validators;\n  };\n\n  return function arrayValidator(value) {\n    var validationResult = validate(v.plainArray, value);\n\n    if (validationResult) {\n      return validationResult;\n    }\n\n    if (validatingTuple && value.length !== validators.length) {\n      return 'an array with ' + validators.length + ' items';\n    }\n\n    for (var i = 0; i < value.length; i++) {\n      validationResult = validate(getValidator(i), value[i]);\n\n      if (validationResult) {\n        return [i].concat(validationResult);\n      }\n    }\n  };\n}\n\nv.required = function required(validator) {\n  function requiredValidator(value) {\n    if (value == null) {\n      return function (options) {\n        return formatErrorMessage(options, isArrayCulprit(options.path) ? 'cannot be undefined/null.' : 'is required.');\n      };\n    }\n\n    return validator.apply(this, arguments);\n  }\n\n  requiredValidator.__required = true;\n  return requiredValidator;\n};\n\nv.oneOfType = function oneOfType() {\n  var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);\n  return function oneOfTypeValidator(value) {\n    var messages = validators.map(function (validator) {\n      return validate(validator, value);\n    }).filter(Boolean); // If we don't have as many messages as no. of validators,\n    // then at least one validator was ok with the value.\n\n    if (messages.length !== validators.length) {\n      return;\n    } // check primitive type\n\n\n    if (messages.every(function (message) {\n      return message.length === 1 && typeof message[0] === 'string';\n    })) {\n      return orList(messages.map(function (m) {\n        return m[0];\n      }));\n    } // Complex oneOfTypes like\n    // `v.oneOftypes(v.shape({name: v.string})`, `v.shape({name: v.number}))`\n    // are complex ¯\\_(ツ)_/¯. For the current scope only returning the longest message.\n\n\n    return messages.reduce(function (max, arr) {\n      return arr.length > max.length ? arr : max;\n    });\n  };\n};\n/**\n * Meta Validators\n * which take options as argument (not validators)\n * and return a new primitive validator\n */\n\n\nv.equal = function equal(compareWith) {\n  return function equalValidator(value) {\n    if (value !== compareWith) {\n      return JSON.stringify(compareWith);\n    }\n  };\n};\n\nv.oneOf = function oneOf() {\n  var options = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);\n  var validators = options.map(function (value) {\n    return v.equal(value);\n  });\n  return v.oneOfType.apply(this, validators);\n};\n\nv.range = function range(compareWith) {\n  var min = compareWith[0];\n  var max = compareWith[1];\n  return function rangeValidator(value) {\n    var validationResult = validate(v.number, value);\n\n    if (validationResult || value < min || value > max) {\n      return 'number between ' + min + ' & ' + max + ' (inclusive)';\n    }\n  };\n};\n/**\n * Primitive validators\n *\n * simple validators which return a string or undefined\n */\n\n\nv.any = function any() {\n  return;\n};\n\nv.boolean = function boolean(value) {\n  if (typeof value !== 'boolean') {\n    return 'boolean';\n  }\n};\n\nv.number = function number(value) {\n  if (typeof value !== 'number') {\n    return 'number';\n  }\n};\n\nv.plainArray = function plainArray(value) {\n  if (!Array.isArray(value)) {\n    return 'array';\n  }\n};\n\nv.plainObject = function plainObject(value) {\n  if (!isPlainObject(value)) {\n    return 'object';\n  }\n};\n\nv.string = function string(value) {\n  if (typeof value !== 'string') {\n    return 'string';\n  }\n};\n\nv.func = function func(value) {\n  if (typeof value !== 'function') {\n    return 'function';\n  }\n};\n\nfunction validate(validator, value) {\n  // assertions are optional by default unless wrapped in v.require\n  if (value == null && !validator.hasOwnProperty('__required')) {\n    return;\n  }\n\n  var result = validator(value);\n\n  if (result) {\n    return Array.isArray(result) ? result : [result];\n  }\n}\n\nfunction processMessage(message, options) {\n  // message array follows the convention\n  // [...path, result]\n  // path is an array of object keys / array indices\n  // result is output of the validator\n  var len = message.length;\n  var result = message[len - 1];\n  var path = message.slice(0, len - 1);\n\n  if (path.length === 0) {\n    path = [DEFAULT_ERROR_PATH];\n  }\n\n  options = xtend(options, {\n    path: path\n  });\n  return typeof result === 'function' ? result(options) // allows customization of result\n  : formatErrorMessage(options, prettifyResult(result));\n}\n\nfunction orList(list) {\n  if (list.length < 2) {\n    return list[0];\n  }\n\n  if (list.length === 2) {\n    return list.join(' or ');\n  }\n\n  return list.slice(0, -1).join(', ') + ', or ' + list.slice(-1);\n}\n\nfunction prettifyResult(result) {\n  return 'must be ' + addArticle(result) + '.';\n}\n\nfunction addArticle(nounPhrase) {\n  if (/^an? /.test(nounPhrase)) {\n    return nounPhrase;\n  }\n\n  if (/^[aeiou]/i.test(nounPhrase)) {\n    return 'an ' + nounPhrase;\n  }\n\n  if (/^[a-z]/i.test(nounPhrase)) {\n    return 'a ' + nounPhrase;\n  }\n\n  return nounPhrase;\n}\n\nfunction formatErrorMessage(options, prettyResult) {\n  var arrayCulprit = isArrayCulprit(options.path);\n  var output = options.path.join('.') + ' ' + prettyResult;\n  var prepend = arrayCulprit ? 'Item at position ' : '';\n  return prepend + output;\n}\n\nfunction isArrayCulprit(path) {\n  return typeof path[path.length - 1] == 'number' || typeof path[0] == 'number';\n}\n\nfunction objectEntries(obj) {\n  return Object.keys(obj || {}).map(function (key) {\n    return {\n      key: key,\n      value: obj[key]\n    };\n  });\n}\n\nv.validate = validate;\nv.processMessage = processMessage;\nmodule.exports = v;","map":{"version":3,"sources":["/Users/garrettmillar/pandemic_dashboard/node_modules/@mapbox/fusspot/lib/index.js"],"names":["isPlainObject","require","xtend","DEFAULT_ERROR_PATH","NEWLINE_INDENT","v","assert","rootValidator","options","value","message","validate","errorMessage","processMessage","apiName","Error","shape","validatorObj","validators","objectEntries","shapeValidator","validationResult","plainObject","key","validator","errorMessages","i","length","push","concat","map","renderedMessage","split","join","objectId","path","ofPhrase","strictShape","strictShapeValidator","shapeResult","invalidKeys","Object","keys","reduce","memo","valueKey","undefined","arrayOf","createArrayValidator","tuple","Array","isArray","arguments","prototype","slice","call","validatingTuple","getValidator","index","arrayValidator","plainArray","required","requiredValidator","formatErrorMessage","isArrayCulprit","apply","__required","oneOfType","oneOfTypeValidator","messages","filter","Boolean","every","orList","m","max","arr","equal","compareWith","equalValidator","JSON","stringify","oneOf","range","min","rangeValidator","number","any","boolean","string","func","hasOwnProperty","result","len","prettifyResult","list","addArticle","nounPhrase","test","prettyResult","arrayCulprit","output","prepend","obj","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n/**\n * Validators are functions which assert certain type.\n * They can return a string which can then be used\n * to display a helpful error message.\n * They can also return a function for a custom error message.\n */\nvar isPlainObject = require('is-plain-obj');\nvar xtend = require('xtend');\n\nvar DEFAULT_ERROR_PATH = 'value';\nvar NEWLINE_INDENT = '\\n  ';\n\nvar v = {};\n\n/**\n * Runners\n *\n * Take root validators and run assertion\n */\nv.assert = function(rootValidator, options) {\n  options = options || {};\n  return function(value) {\n    var message = validate(rootValidator, value);\n    // all good\n    if (!message) {\n      return;\n    }\n\n    var errorMessage = processMessage(message, options);\n\n    if (options.apiName) {\n      errorMessage = options.apiName + ': ' + errorMessage;\n    }\n\n    throw new Error(errorMessage);\n  };\n};\n\n/**\n * Higher Order Validators\n *\n * validators which take other validators as input\n * and output a new validator\n */\nv.shape = function shape(validatorObj) {\n  var validators = objectEntries(validatorObj);\n  return function shapeValidator(value) {\n    var validationResult = validate(v.plainObject, value);\n\n    if (validationResult) {\n      return validationResult;\n    }\n\n    var key, validator;\n    var errorMessages = [];\n\n    for (var i = 0; i < validators.length; i++) {\n      key = validators[i].key;\n      validator = validators[i].value;\n      validationResult = validate(validator, value[key]);\n\n      if (validationResult) {\n        // return [key].concat(validationResult);\n        errorMessages.push([key].concat(validationResult));\n      }\n    }\n\n    if (errorMessages.length < 2) {\n      return errorMessages[0];\n    }\n\n    // enumerate all the error messages\n    return function(options) {\n      errorMessages = errorMessages.map(function(message) {\n        var key = message[0];\n        var renderedMessage = processMessage(message, options)\n          .split('\\n')\n          .join(NEWLINE_INDENT); // indents any inner nesting\n        return '- ' + key + ': ' + renderedMessage;\n      });\n\n      var objectId = options.path.join('.');\n      var ofPhrase = objectId === DEFAULT_ERROR_PATH ? '' : ' of ' + objectId;\n\n      return (\n        'The following properties' +\n        ofPhrase +\n        ' have invalid values:' +\n        NEWLINE_INDENT +\n        errorMessages.join(NEWLINE_INDENT)\n      );\n    };\n  };\n};\n\nv.strictShape = function strictShape(validatorObj) {\n  var shapeValidator = v.shape(validatorObj);\n  return function strictShapeValidator(value) {\n    var shapeResult = shapeValidator(value);\n    if (shapeResult) {\n      return shapeResult;\n    }\n\n    var invalidKeys = Object.keys(value).reduce(function(memo, valueKey) {\n      if (validatorObj[valueKey] === undefined) {\n        memo.push(valueKey);\n      }\n      return memo;\n    }, []);\n\n    if (invalidKeys.length !== 0) {\n      return function() {\n        return 'The following keys are invalid: ' + invalidKeys.join(', ');\n      };\n    }\n  };\n};\n\nv.arrayOf = function arrayOf(validator) {\n  return createArrayValidator(validator);\n};\n\nv.tuple = function tuple() {\n  var validators = Array.isArray(arguments[0])\n    ? arguments[0]\n    : Array.prototype.slice.call(arguments);\n  return createArrayValidator(validators);\n};\n\n// Currently array validation fails when the first invalid item is found.\nfunction createArrayValidator(validators) {\n  var validatingTuple = Array.isArray(validators);\n  var getValidator = function(index) {\n    if (validatingTuple) {\n      return validators[index];\n    }\n    return validators;\n  };\n\n  return function arrayValidator(value) {\n    var validationResult = validate(v.plainArray, value);\n    if (validationResult) {\n      return validationResult;\n    }\n\n    if (validatingTuple && value.length !== validators.length) {\n      return 'an array with ' + validators.length + ' items';\n    }\n\n    for (var i = 0; i < value.length; i++) {\n      validationResult = validate(getValidator(i), value[i]);\n      if (validationResult) {\n        return [i].concat(validationResult);\n      }\n    }\n  };\n}\n\nv.required = function required(validator) {\n  function requiredValidator(value) {\n    if (value == null) {\n      return function(options) {\n        return formatErrorMessage(\n          options,\n          isArrayCulprit(options.path)\n            ? 'cannot be undefined/null.'\n            : 'is required.'\n        );\n      };\n    }\n    return validator.apply(this, arguments);\n  }\n  requiredValidator.__required = true;\n\n  return requiredValidator;\n};\n\nv.oneOfType = function oneOfType() {\n  var validators = Array.isArray(arguments[0])\n    ? arguments[0]\n    : Array.prototype.slice.call(arguments);\n  return function oneOfTypeValidator(value) {\n    var messages = validators\n      .map(function(validator) {\n        return validate(validator, value);\n      })\n      .filter(Boolean);\n\n    // If we don't have as many messages as no. of validators,\n    // then at least one validator was ok with the value.\n    if (messages.length !== validators.length) {\n      return;\n    }\n\n    // check primitive type\n    if (\n      messages.every(function(message) {\n        return message.length === 1 && typeof message[0] === 'string';\n      })\n    ) {\n      return orList(\n        messages.map(function(m) {\n          return m[0];\n        })\n      );\n    }\n\n    // Complex oneOfTypes like\n    // `v.oneOftypes(v.shape({name: v.string})`, `v.shape({name: v.number}))`\n    // are complex ¯\\_(ツ)_/¯. For the current scope only returning the longest message.\n    return messages.reduce(function(max, arr) {\n      return arr.length > max.length ? arr : max;\n    });\n  };\n};\n\n/**\n * Meta Validators\n * which take options as argument (not validators)\n * and return a new primitive validator\n */\nv.equal = function equal(compareWith) {\n  return function equalValidator(value) {\n    if (value !== compareWith) {\n      return JSON.stringify(compareWith);\n    }\n  };\n};\n\nv.oneOf = function oneOf() {\n  var options = Array.isArray(arguments[0])\n    ? arguments[0]\n    : Array.prototype.slice.call(arguments);\n  var validators = options.map(function(value) {\n    return v.equal(value);\n  });\n\n  return v.oneOfType.apply(this, validators);\n};\n\nv.range = function range(compareWith) {\n  var min = compareWith[0];\n  var max = compareWith[1];\n  return function rangeValidator(value) {\n    var validationResult = validate(v.number, value);\n\n    if (validationResult || value < min || value > max) {\n      return 'number between ' + min + ' & ' + max + ' (inclusive)';\n    }\n  };\n};\n\n/**\n * Primitive validators\n *\n * simple validators which return a string or undefined\n */\nv.any = function any() {\n  return;\n};\n\nv.boolean = function boolean(value) {\n  if (typeof value !== 'boolean') {\n    return 'boolean';\n  }\n};\n\nv.number = function number(value) {\n  if (typeof value !== 'number') {\n    return 'number';\n  }\n};\n\nv.plainArray = function plainArray(value) {\n  if (!Array.isArray(value)) {\n    return 'array';\n  }\n};\n\nv.plainObject = function plainObject(value) {\n  if (!isPlainObject(value)) {\n    return 'object';\n  }\n};\n\nv.string = function string(value) {\n  if (typeof value !== 'string') {\n    return 'string';\n  }\n};\n\nv.func = function func(value) {\n  if (typeof value !== 'function') {\n    return 'function';\n  }\n};\n\nfunction validate(validator, value) {\n  // assertions are optional by default unless wrapped in v.require\n  if (value == null && !validator.hasOwnProperty('__required')) {\n    return;\n  }\n\n  var result = validator(value);\n\n  if (result) {\n    return Array.isArray(result) ? result : [result];\n  }\n}\n\nfunction processMessage(message, options) {\n  // message array follows the convention\n  // [...path, result]\n  // path is an array of object keys / array indices\n  // result is output of the validator\n  var len = message.length;\n\n  var result = message[len - 1];\n  var path = message.slice(0, len - 1);\n\n  if (path.length === 0) {\n    path = [DEFAULT_ERROR_PATH];\n  }\n  options = xtend(options, { path: path });\n\n  return typeof result === 'function'\n    ? result(options) // allows customization of result\n    : formatErrorMessage(options, prettifyResult(result));\n}\n\nfunction orList(list) {\n  if (list.length < 2) {\n    return list[0];\n  }\n  if (list.length === 2) {\n    return list.join(' or ');\n  }\n  return list.slice(0, -1).join(', ') + ', or ' + list.slice(-1);\n}\n\nfunction prettifyResult(result) {\n  return 'must be ' + addArticle(result) + '.';\n}\n\nfunction addArticle(nounPhrase) {\n  if (/^an? /.test(nounPhrase)) {\n    return nounPhrase;\n  }\n  if (/^[aeiou]/i.test(nounPhrase)) {\n    return 'an ' + nounPhrase;\n  }\n  if (/^[a-z]/i.test(nounPhrase)) {\n    return 'a ' + nounPhrase;\n  }\n  return nounPhrase;\n}\n\nfunction formatErrorMessage(options, prettyResult) {\n  var arrayCulprit = isArrayCulprit(options.path);\n  var output = options.path.join('.') + ' ' + prettyResult;\n  var prepend = arrayCulprit ? 'Item at position ' : '';\n\n  return prepend + output;\n}\n\nfunction isArrayCulprit(path) {\n  return typeof path[path.length - 1] == 'number' || typeof path[0] == 'number';\n}\n\nfunction objectEntries(obj) {\n  return Object.keys(obj || {}).map(function(key) {\n    return { key: key, value: obj[key] };\n  });\n}\n\nv.validate = validate;\nv.processMessage = processMessage;\n\nmodule.exports = v;\n"]},"metadata":{},"sourceType":"script"}