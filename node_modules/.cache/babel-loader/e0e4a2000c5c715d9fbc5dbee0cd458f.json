{"ast":null,"code":"'use strict';\n\nvar nanoid = require('nanoid');\n/**\n * Construct a new mapbox event client to send interaction events to the mapbox event service\n * @param {Object} options options with which to create the service\n * @param {String} options.accessToken the mapbox access token to make requests\n * @param {Number} [options.flushInterval=1000] the number of ms after which to flush the event queue\n * @param {Number} [options.maxQueueSize=100] the number of events to queue before flushing\n * @private\n */\n\n\nfunction MapboxEventManager(options) {\n  this.origin = options.origin || 'https://api.mapbox.com';\n  this.endpoint = 'events/v2';\n  this.access_token = options.accessToken;\n  this.version = '0.2.0';\n  this.sessionID = this.generateSessionID();\n  this.userAgent = this.getUserAgent();\n  this.options = options;\n  this.send = this.send.bind(this); // parse global options to be sent with each request\n\n  this.countries = options.countries ? options.countries.split(\",\") : null;\n  this.types = options.types ? options.types.split(\",\") : null;\n  this.bbox = options.bbox ? options.bbox : null;\n  this.language = options.language ? options.language.split(\",\") : null;\n  this.limit = options.limit ? +options.limit : null;\n  this.locale = navigator.language || null;\n  this.enableEventLogging = this.shouldEnableLogging(options);\n  this.eventQueue = new Array();\n  this.flushInterval = options.flushInterval || 1000;\n  this.maxQueueSize = options.maxQueueSize || 100;\n  this.timer = this.flushInterval ? setTimeout(this.flush.bind(this), this.flushInterval) : null; // keep some state to deduplicate requests if necessary\n\n  this.lastSentInput = \"\";\n  this.lastSentIndex = 0;\n}\n\nMapboxEventManager.prototype = {\n  /**\n     * Send a search.select event to the mapbox events service\n     * This event marks the array index of the item selected by the user out of the array of possible options\n     * @private\n     * @param {Object} selected the geojson feature selected by the user\n     * @param {Object} geocoder a mapbox-gl-geocoder instance\n     * @returns {Promise}\n     */\n  select: function select(selected, geocoder) {\n    var resultIndex = this.getSelectedIndex(selected, geocoder);\n    var payload = this.getEventPayload('search.select', geocoder);\n    payload.resultIndex = resultIndex;\n    payload.resultPlaceName = selected.place_name;\n    payload.resultId = selected.id;\n\n    if (resultIndex === this.lastSentIndex && payload.queryString === this.lastSentInput || resultIndex == -1) {\n      // don't log duplicate events if the user re-selected the same feature on the same search\n      return;\n    }\n\n    this.lastSentIndex = resultIndex;\n    this.lastSentInput = payload.queryString;\n    if (!payload.queryString) return; // will be rejected\n\n    return this.push(payload);\n  },\n\n  /**\n     * Send a search-start event to the mapbox events service\n     * This turnstile event marks when a user starts a new search\n     * @private\n     * @param {Object} geocoder a mapbox-gl-geocoder instance\n     * @returns {Promise}\n     */\n  start: function start(geocoder) {\n    var payload = this.getEventPayload('search.start', geocoder);\n    if (!payload.queryString) return; // will be rejected\n\n    return this.push(payload);\n  },\n\n  /**\n   * Send a search-keyevent event to the mapbox events service\n   * This event records each keypress in sequence\n   * @private\n   * @param {Object} keyEvent the keydown event to log\n   * @param {Object} geocoder a mapbox-gl-geocoder instance\n   * \n   */\n  keyevent: function keyevent(keyEvent, geocoder) {\n    //pass invalid event\n    if (!keyEvent.key) return; // don't send events for keys that don't change the input\n    // TAB, ESC, LEFT, RIGHT, ENTER, UP, DOWN\n\n    if (keyEvent.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(keyEvent.keyCode) !== -1) return;\n    var payload = this.getEventPayload('search.keystroke', geocoder);\n    payload.lastAction = keyEvent.key;\n    if (!payload.queryString) return; // will be rejected\n\n    return this.push(payload);\n  },\n\n  /**\n   * Send an event to the events service\n   *\n   * The event is skipped if the instance is not enabled to send logging events\n   *\n   * @private\n   * @param {Object} payload the http POST body of the event\n   * @param {Function} [callback] a callback function to invoke when the send has completed\n   * @returns {Promise}\n   */\n  send: function send(payload, callback) {\n    if (!this.enableEventLogging) {\n      if (callback) return callback();\n      return;\n    }\n\n    var options = this.getRequestOptions(payload);\n    this.request(options, function (err) {\n      if (err) return this.handleError(err, callback);\n\n      if (callback) {\n        return callback();\n      }\n    }.bind(this));\n  },\n\n  /**\n   * Get http request options\n   * @private\n   * @param {*} payload\n   */\n  getRequestOptions: function getRequestOptions(payload) {\n    if (!Array.isArray(payload)) payload = [payload];\n    var options = {\n      // events must be sent with POST\n      method: \"POST\",\n      host: this.origin,\n      path: this.endpoint + \"?access_token=\" + this.access_token,\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(payload) //events are arrays\n\n    };\n    return options;\n  },\n\n  /**\n   * Get the event payload to send to the events service\n   * Most payload properties are shared across all events\n   * @private\n   * @param {String} event the name of the event to send to the events service. Valid options are 'search.start', 'search.select', 'search.feedback'.\n   * @param {Object} geocoder a mapbox-gl-geocoder instance\n   * @returns {Object} an event payload\n   */\n  getEventPayload: function getEventPayload(event, geocoder) {\n    var proximity;\n    if (!geocoder.options.proximity) proximity = null;else proximity = [geocoder.options.proximity.longitude, geocoder.options.proximity.latitude];\n    var zoom = geocoder._map ? geocoder._map.getZoom() : undefined;\n    var payload = {\n      event: event,\n      created: +new Date(),\n      sessionIdentifier: this.sessionID,\n      country: this.countries,\n      userAgent: this.userAgent,\n      language: this.language,\n      bbox: this.bbox,\n      types: this.types,\n      endpoint: 'mapbox.places',\n      // fuzzyMatch: search.fuzzy, //todo  --> add to plugin\n      proximity: proximity,\n      limit: geocoder.options.limit,\n      // routing: search.routing, //todo --> add to plugin\n      mapZoom: zoom,\n      keyboardLocale: this.locale\n    }; // get the text in the search bar\n\n    if (event === \"search.select\") {\n      payload.queryString = geocoder.inputString;\n    } else if (event != \"search.select\" && geocoder._inputEl) {\n      payload.queryString = geocoder._inputEl.value;\n    } else {\n      payload.queryString = geocoder.inputString;\n    }\n\n    return payload;\n  },\n\n  /**\n   * Wraps the request function for easier testing\n   * Make an http request and invoke a callback\n   * @private\n   * @param {Object} opts options describing the http request to be made\n   * @param {Function} callback the callback to invoke when the http request is completed\n   */\n  request: function request(opts, callback) {\n    var xhttp = new XMLHttpRequest();\n\n    xhttp.onreadystatechange = function () {\n      if (this.readyState == 4) {\n        if (this.status == 204) {\n          //success\n          return callback(null);\n        } else {\n          return callback(this.statusText);\n        }\n      }\n    };\n\n    xhttp.open(opts.method, opts.host + '/' + opts.path, true);\n\n    for (var header in opts.headers) {\n      var headerValue = opts.headers[header];\n      xhttp.setRequestHeader(header, headerValue);\n    }\n\n    xhttp.send(opts.body);\n  },\n\n  /**\n   * Handle an error that occurred while making a request\n   * @param {Object} err an error instance to log\n   * @private\n   */\n  handleError: function handleError(err, callback) {\n    if (callback) return callback(err);\n  },\n\n  /**\n   * Generate a session ID to be returned with all of the searches made by this geocoder instance\n   * ID is random and cannot be tracked across sessions\n   * @private\n   */\n  generateSessionID: function generateSessionID() {\n    return nanoid();\n  },\n\n  /**\n   * Get a user agent string to send with the request to the events service\n   * @private\n   */\n  getUserAgent: function getUserAgent() {\n    return 'mapbox-gl-geocoder.' + this.version + \".\" + navigator.userAgent;\n  },\n\n  /**\n     * Get the 0-based numeric index of the item that the user selected out of the list of options\n     * @private\n     * @param {Object} selected the geojson feature selected by the user\n     * @param {Object} geocoder a Mapbox-GL-Geocoder instance\n     * @returns {Number} the index of the selected result\n     */\n  getSelectedIndex: function getSelectedIndex(selected, geocoder) {\n    if (!geocoder._typeahead) return;\n    var results = geocoder._typeahead.data;\n    var selectedID = selected.id;\n    var resultIDs = results.map(function (feature) {\n      return feature.id;\n    });\n    var selectedIdx = resultIDs.indexOf(selectedID);\n    return selectedIdx;\n  },\n\n  /**\n     * Check whether events should be logged\n     * Clients using a localGeocoder or an origin other than mapbox should not have events logged\n     * @private\n     */\n  shouldEnableLogging: function shouldEnableLogging(options) {\n    if (options.enableEventLogging === false) return false;\n    if (options.origin && options.origin.indexOf('api.mapbox.com') == -1) return false; // hard to make sense of events when a local instance is suplementing results from origin\n\n    if (options.localGeocoder) return false; // hard to make sense of events when a custom filter is in use\n\n    if (options.filter) return false;\n    return true;\n  },\n\n  /**\n   * Flush out the event queue by sending events to the events service\n   * @private\n   */\n  flush: function flush() {\n    if (this.eventQueue.length > 0) {\n      this.send(this.eventQueue);\n      this.eventQueue = new Array();\n    } // //reset the timer\n\n\n    if (this.timer) clearTimeout(this.timer);\n    if (this.flushInterval) this.timer = setTimeout(this.flush.bind(this), this.flushInterval);\n  },\n\n  /**\n   * Push event into the pending queue\n   * @param {Object} evt the event to send to the events service\n   * @param {Boolean} forceFlush indicates that the event queue should be flushed after adding this event regardless of size of the queue\n   * @private\n   */\n  push: function push(evt, forceFlush) {\n    this.eventQueue.push(evt);\n\n    if (this.eventQueue.length >= this.maxQueueSize || forceFlush) {\n      this.flush();\n    }\n  },\n\n  /**\n   * Flush any remaining events from the queue before it is removed\n   * @private\n   */\n  remove: function remove() {\n    this.flush();\n  }\n};\nmodule.exports = MapboxEventManager;","map":{"version":3,"sources":["/Users/garrettmillar/pandemic_dashboard/node_modules/@mapbox/mapbox-gl-geocoder/lib/events.js"],"names":["nanoid","require","MapboxEventManager","options","origin","endpoint","access_token","accessToken","version","sessionID","generateSessionID","userAgent","getUserAgent","send","bind","countries","split","types","bbox","language","limit","locale","navigator","enableEventLogging","shouldEnableLogging","eventQueue","Array","flushInterval","maxQueueSize","timer","setTimeout","flush","lastSentInput","lastSentIndex","prototype","select","selected","geocoder","resultIndex","getSelectedIndex","payload","getEventPayload","resultPlaceName","place_name","resultId","id","queryString","push","start","keyevent","keyEvent","key","metaKey","indexOf","keyCode","lastAction","callback","getRequestOptions","request","err","handleError","isArray","method","host","path","headers","body","JSON","stringify","event","proximity","longitude","latitude","zoom","_map","getZoom","undefined","created","Date","sessionIdentifier","country","mapZoom","keyboardLocale","inputString","_inputEl","value","opts","xhttp","XMLHttpRequest","onreadystatechange","readyState","status","statusText","open","header","headerValue","setRequestHeader","_typeahead","results","data","selectedID","resultIDs","map","feature","selectedIdx","localGeocoder","filter","length","clearTimeout","evt","forceFlush","remove","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nvar nanoid = require('nanoid')\n\n/**\n * Construct a new mapbox event client to send interaction events to the mapbox event service\n * @param {Object} options options with which to create the service\n * @param {String} options.accessToken the mapbox access token to make requests\n * @param {Number} [options.flushInterval=1000] the number of ms after which to flush the event queue\n * @param {Number} [options.maxQueueSize=100] the number of events to queue before flushing\n * @private\n */\nfunction MapboxEventManager(options) {\n  this.origin = options.origin || 'https://api.mapbox.com';\n  this.endpoint = 'events/v2';\n  this.access_token = options.accessToken;\n  this.version = '0.2.0'\n  this.sessionID = this.generateSessionID();\n  this.userAgent = this.getUserAgent();\n\n  this.options = options;\n  this.send = this.send.bind(this);\n\n\n  // parse global options to be sent with each request\n  this.countries = (options.countries) ? options.countries.split(\",\") : null;\n  this.types = (options.types) ? options.types.split(\",\") : null;\n  this.bbox = (options.bbox) ? options.bbox : null;\n  this.language = (options.language) ? options.language.split(\",\") : null;\n  this.limit = (options.limit) ? +options.limit : null;\n  this.locale = navigator.language || null;\n  this.enableEventLogging = this.shouldEnableLogging(options);\n  this.eventQueue = new Array();\n  this.flushInterval = options.flushInterval || 1000;\n  this.maxQueueSize = options.maxQueueSize || 100;\n  this.timer = (this.flushInterval) ? setTimeout(this.flush.bind(this), this.flushInterval) : null;\n  // keep some state to deduplicate requests if necessary\n  this.lastSentInput = \"\";\n  this.lastSentIndex = 0;\n}\n\nMapboxEventManager.prototype = {\n  /**\n     * Send a search.select event to the mapbox events service\n     * This event marks the array index of the item selected by the user out of the array of possible options\n     * @private\n     * @param {Object} selected the geojson feature selected by the user\n     * @param {Object} geocoder a mapbox-gl-geocoder instance\n     * @returns {Promise}\n     */\n  select: function(selected, geocoder){\n    var resultIndex = this.getSelectedIndex(selected, geocoder);\n    var payload = this.getEventPayload('search.select', geocoder);\n    payload.resultIndex = resultIndex;\n    payload.resultPlaceName  = selected.place_name;\n    payload.resultId = selected.id;\n    if ((resultIndex === this.lastSentIndex && payload.queryString === this.lastSentInput) || resultIndex == -1) {\n      // don't log duplicate events if the user re-selected the same feature on the same search\n      return;\n    }\n    this.lastSentIndex = resultIndex;\n    this.lastSentInput = payload.queryString;\n    if (!payload.queryString) return; // will be rejected\n    return this.push(payload)\n  },\n\n  /**\n     * Send a search-start event to the mapbox events service\n     * This turnstile event marks when a user starts a new search\n     * @private\n     * @param {Object} geocoder a mapbox-gl-geocoder instance\n     * @returns {Promise}\n     */\n  start: function(geocoder){\n    var payload = this.getEventPayload('search.start', geocoder);\n    if (!payload.queryString) return; // will be rejected\n    return this.push(payload);\n  },\n\n  /**\n   * Send a search-keyevent event to the mapbox events service\n   * This event records each keypress in sequence\n   * @private\n   * @param {Object} keyEvent the keydown event to log\n   * @param {Object} geocoder a mapbox-gl-geocoder instance\n   * \n   */\n  keyevent: function(keyEvent, geocoder){\n\n    //pass invalid event\n    if (!keyEvent.key) return;\n    // don't send events for keys that don't change the input\n    // TAB, ESC, LEFT, RIGHT, ENTER, UP, DOWN\n    if (keyEvent.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(keyEvent.keyCode) !== -1) return;\n    var payload = this.getEventPayload('search.keystroke', geocoder);\n    payload.lastAction = keyEvent.key;\n    if (!payload.queryString) return; // will be rejected\n    return this.push(payload);\n  },\n\n  /**\n   * Send an event to the events service\n   *\n   * The event is skipped if the instance is not enabled to send logging events\n   *\n   * @private\n   * @param {Object} payload the http POST body of the event\n   * @param {Function} [callback] a callback function to invoke when the send has completed\n   * @returns {Promise}\n   */\n  send: function (payload, callback) {\n    if (!this.enableEventLogging) {\n      if (callback) return callback();\n      return;\n    }\n    var options = this.getRequestOptions(payload);\n    this.request(options, function(err){\n      if (err) return this.handleError(err, callback);\n      if (callback) {\n        return callback();\n      }\n    }.bind(this))\n  },\n  /**\n   * Get http request options\n   * @private\n   * @param {*} payload\n   */\n  getRequestOptions: function(payload){\n    if (!Array.isArray(payload)) payload = [payload];\n    var options = {\n      // events must be sent with POST\n      method: \"POST\",\n      host: this.origin,\n      path: this.endpoint +  \"?access_token=\" + this.access_token,\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body:JSON.stringify(payload) //events are arrays\n    }\n    return options\n  },\n\n  /**\n   * Get the event payload to send to the events service\n   * Most payload properties are shared across all events\n   * @private\n   * @param {String} event the name of the event to send to the events service. Valid options are 'search.start', 'search.select', 'search.feedback'.\n   * @param {Object} geocoder a mapbox-gl-geocoder instance\n   * @returns {Object} an event payload\n   */\n  getEventPayload: function (event, geocoder) {\n    var proximity;\n    if (!geocoder.options.proximity) proximity = null;\n    else proximity = [geocoder.options.proximity.longitude, geocoder.options.proximity.latitude];\n\n    var zoom = (geocoder._map) ? geocoder._map.getZoom() : undefined;\n    var payload = {\n      event: event,\n      created: +new Date(),\n      sessionIdentifier: this.sessionID,\n      country: this.countries,\n      userAgent: this.userAgent,\n      language: this.language,\n      bbox: this.bbox,\n      types: this.types,\n      endpoint: 'mapbox.places',\n      // fuzzyMatch: search.fuzzy, //todo  --> add to plugin\n      proximity: proximity,\n      limit: geocoder.options.limit,\n      // routing: search.routing, //todo --> add to plugin\n      mapZoom: zoom,\n      keyboardLocale: this.locale\n    }\n\n    // get the text in the search bar\n    if (event === \"search.select\"){\n      payload.queryString = geocoder.inputString;\n    }else if (event != \"search.select\" && geocoder._inputEl){\n      payload.queryString = geocoder._inputEl.value;\n    }else{\n      payload.queryString = geocoder.inputString;\n    }\n    return payload;\n  },\n\n  /**\n   * Wraps the request function for easier testing\n   * Make an http request and invoke a callback\n   * @private\n   * @param {Object} opts options describing the http request to be made\n   * @param {Function} callback the callback to invoke when the http request is completed\n   */\n  request: function (opts, callback) {\n    var xhttp = new XMLHttpRequest();\n    xhttp.onreadystatechange = function() {\n      if (this.readyState == 4 ) {\n        if (this.status == 204){\n          //success\n          return callback(null);\n        }else {\n          return callback(this.statusText);\n        }\n      }\n    };\n\n    xhttp.open(opts.method, opts.host + '/' + opts.path, true);\n    for (var header in opts.headers){\n      var headerValue = opts.headers[header];\n      xhttp.setRequestHeader(header, headerValue)\n    }\n    xhttp.send(opts.body);\n  },\n\n  /**\n   * Handle an error that occurred while making a request\n   * @param {Object} err an error instance to log\n   * @private\n   */\n  handleError: function (err, callback) {\n    if (callback) return callback(err);\n  },\n\n  /**\n   * Generate a session ID to be returned with all of the searches made by this geocoder instance\n   * ID is random and cannot be tracked across sessions\n   * @private\n   */\n  generateSessionID: function () {\n    return nanoid();\n  },\n\n  /**\n   * Get a user agent string to send with the request to the events service\n   * @private\n   */\n  getUserAgent: function () {\n    return 'mapbox-gl-geocoder.' + this.version + \".\" + navigator.userAgent;\n  },\n\n  /**\n     * Get the 0-based numeric index of the item that the user selected out of the list of options\n     * @private\n     * @param {Object} selected the geojson feature selected by the user\n     * @param {Object} geocoder a Mapbox-GL-Geocoder instance\n     * @returns {Number} the index of the selected result\n     */\n  getSelectedIndex: function(selected, geocoder){\n    if (!geocoder._typeahead) return;\n    var results = geocoder._typeahead.data;\n    var selectedID = selected.id;\n    var resultIDs = results.map(function (feature) {\n      return feature.id;\n    });\n    var selectedIdx = resultIDs.indexOf(selectedID);\n    return selectedIdx;\n  },\n\n  /**\n     * Check whether events should be logged\n     * Clients using a localGeocoder or an origin other than mapbox should not have events logged\n     * @private\n     */\n  shouldEnableLogging: function(options){\n    if (options.enableEventLogging === false) return false;\n    if (options.origin && options.origin.indexOf('api.mapbox.com') == -1) return false;\n    // hard to make sense of events when a local instance is suplementing results from origin\n    if (options.localGeocoder) return false;\n    // hard to make sense of events when a custom filter is in use\n    if (options.filter) return false;\n    return true;\n  },\n\n  /**\n   * Flush out the event queue by sending events to the events service\n   * @private\n   */\n  flush: function(){\n    if (this.eventQueue.length > 0){\n      this.send(this.eventQueue);\n      this.eventQueue = new Array();\n    }\n    // //reset the timer\n    if (this.timer)  clearTimeout(this.timer);\n    if (this.flushInterval) this.timer = setTimeout(this.flush.bind(this), this.flushInterval)\n  },\n\n  /**\n   * Push event into the pending queue\n   * @param {Object} evt the event to send to the events service\n   * @param {Boolean} forceFlush indicates that the event queue should be flushed after adding this event regardless of size of the queue\n   * @private\n   */\n  push: function(evt, forceFlush){\n    this.eventQueue.push(evt);\n    if (this.eventQueue.length >= this.maxQueueSize || forceFlush){\n      this.flush();\n    }\n  },\n\n  /**\n   * Flush any remaining events from the queue before it is removed\n   * @private\n   */\n  remove: function(){\n    this.flush();\n  }\n}\n\n\n\nmodule.exports = MapboxEventManager;\n"]},"metadata":{},"sourceType":"script"}