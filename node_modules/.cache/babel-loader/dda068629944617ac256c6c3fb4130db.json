{"ast":null,"code":"import { log } from '@deck.gl/core';\nimport { ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP } from './marching-squares-codes';\nexport var CONTOUR_TYPE = {\n  ISO_LINES: 1,\n  ISO_BANDS: 2\n};\nvar DEFAULT_THRESHOLD_DATA = {\n  zIndex: 0,\n  zOffset: 0.005\n};\n\nfunction getVertexCode(weight, threshold) {\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n\n    return weight < threshold[1] ? 1 : 2;\n  }\n\n  return weight >= threshold ? 1 : 0;\n}\n\nexport function getCode(opts) {\n  var cellWeights = opts.cellWeights,\n      x = opts.x,\n      y = opts.y,\n      width = opts.width,\n      height = opts.height;\n  var threshold = opts.threshold;\n\n  if (opts.thresholdValue) {\n    log.deprecated('thresholdValue', 'threshold')();\n    threshold = opts.thresholdValue;\n  }\n\n  var isLeftBoundary = x < 0;\n  var isRightBoundary = x >= width - 1;\n  var isBottomBoundary = y < 0;\n  var isTopBoundary = y >= height - 1;\n  var isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n  var weights = {};\n  var codes = {};\n\n  if (isLeftBoundary || isTopBoundary) {\n    codes.top = 0;\n  } else {\n    weights.top = cellWeights[(y + 1) * width + x];\n    codes.top = getVertexCode(weights.top, threshold);\n  }\n\n  if (isRightBoundary || isTopBoundary) {\n    codes.topRight = 0;\n  } else {\n    weights.topRight = cellWeights[(y + 1) * width + x + 1];\n    codes.topRight = getVertexCode(weights.topRight, threshold);\n  }\n\n  if (isRightBoundary || isBottomBoundary) {\n    codes.right = 0;\n  } else {\n    weights.right = cellWeights[y * width + x + 1];\n    codes.right = getVertexCode(weights.right, threshold);\n  }\n\n  if (isLeftBoundary || isBottomBoundary) {\n    codes.current = 0;\n  } else {\n    weights.current = cellWeights[y * width + x];\n    codes.current = getVertexCode(weights.current, threshold);\n  }\n\n  var top = codes.top,\n      topRight = codes.topRight,\n      right = codes.right,\n      current = codes.current;\n  var code = -1;\n\n  if (Number.isFinite(threshold)) {\n    code = top << 3 | topRight << 2 | right << 1 | current;\n  }\n\n  if (Array.isArray(threshold)) {\n    code = top << 6 | topRight << 4 | right << 2 | current;\n  }\n\n  var meanCode = 0;\n\n  if (!isBoundary) {\n    meanCode = getVertexCode((weights.top + weights.topRight + weights.right + weights.current) / 4, threshold);\n  }\n\n  return {\n    code: code,\n    meanCode: meanCode\n  };\n}\nexport function getVertices(opts) {\n  var gridOrigin = opts.gridOrigin,\n      cellSize = opts.cellSize,\n      x = opts.x,\n      y = opts.y,\n      code = opts.code,\n      meanCode = opts.meanCode,\n      _opts$type = opts.type,\n      type = _opts$type === void 0 ? CONTOUR_TYPE.ISO_LINES : _opts$type;\n  var thresholdData = Object.assign({}, DEFAULT_THRESHOLD_DATA, opts.thresholdData);\n  var offsets = type === CONTOUR_TYPE.ISO_BANDS ? ISOBANDS_CODE_OFFSET_MAP[code] : ISOLINES_CODE_OFFSET_MAP[code];\n\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  var vZ = thresholdData.zIndex * thresholdData.zOffset;\n  var rX = (x + 1) * cellSize[0];\n  var rY = (y + 1) * cellSize[1];\n  var refVertexX = gridOrigin[0] + rX;\n  var refVertexY = gridOrigin[1] + rY;\n\n  if (type === CONTOUR_TYPE.ISO_BANDS) {\n    var polygons = [];\n    offsets.forEach(function (polygonOffsets) {\n      var polygon = [];\n      polygonOffsets.forEach(function (xyOffset) {\n        var vX = refVertexX + xyOffset[0] * cellSize[0];\n        var vY = refVertexY + xyOffset[1] * cellSize[1];\n        polygon.push([vX, vY, vZ]);\n      });\n      polygons.push(polygon);\n    });\n    return polygons;\n  }\n\n  var lines = [];\n  offsets.forEach(function (xyOffsets) {\n    xyOffsets.forEach(function (offset) {\n      var vX = refVertexX + offset[0] * cellSize[0];\n      var vY = refVertexY + offset[1] * cellSize[1];\n      lines.push([vX, vY, vZ]);\n    });\n  });\n  return lines;\n}","map":{"version":3,"sources":["../../../src/contour-layer/marching-squares.js"],"names":["CONTOUR_TYPE","ISO_LINES","ISO_BANDS","DEFAULT_THRESHOLD_DATA","zIndex","zOffset","Array","weight","threshold","cellWeights","x","y","width","height","opts","log","isLeftBoundary","isRightBoundary","isBottomBoundary","isTopBoundary","isBoundary","weights","codes","getVertexCode","top","topRight","right","current","code","Number","meanCode","gridOrigin","cellSize","type","thresholdData","Object","offsets","ISOBANDS_CODE_OFFSET_MAP","ISOLINES_CODE_OFFSET_MAP","vZ","rX","rY","refVertexX","refVertexY","polygons","polygon","polygonOffsets","vX","xyOffset","vY","lines","xyOffsets","offset"],"mappings":"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","sourcesContent":["// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n\nimport {log} from '@deck.gl/core';\nimport {ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP} from './marching-squares-codes';\n\nexport const CONTOUR_TYPE = {\n  ISO_LINES: 1,\n  ISO_BANDS: 2\n};\n\nconst DEFAULT_THRESHOLD_DATA = {\n  zIndex: 0,\n  zOffset: 0.005\n};\n\n// Utility methods\n\nfunction getVertexCode(weight, threshold) {\n  // threshold must be a single value or a range (array of size 2)\n\n  // Iso-bands\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  // Iso-lines\n  return weight >= threshold ? 1 : 0;\n}\n\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts) {\n  // Assumptions\n  // Origin is on bottom-left , and X increase to right, Y to top\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\n  // to create a 2X2 cell grid\n  const {cellWeights, x, y, width, height} = opts;\n  let threshold = opts.threshold;\n  if (opts.thresholdValue) {\n    log.deprecated('thresholdValue', 'threshold')();\n    threshold = opts.thresholdValue;\n  }\n\n  const isLeftBoundary = x < 0;\n  const isRightBoundary = x >= width - 1;\n  const isBottomBoundary = y < 0;\n  const isTopBoundary = y >= height - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n\n  const weights = {};\n  const codes = {};\n\n  // TOP\n  if (isLeftBoundary || isTopBoundary) {\n    codes.top = 0;\n  } else {\n    weights.top = cellWeights[(y + 1) * width + x];\n    codes.top = getVertexCode(weights.top, threshold);\n  }\n\n  // TOP-RIGHT\n  if (isRightBoundary || isTopBoundary) {\n    codes.topRight = 0;\n  } else {\n    weights.topRight = cellWeights[(y + 1) * width + x + 1];\n    codes.topRight = getVertexCode(weights.topRight, threshold);\n  }\n\n  // RIGHT\n  if (isRightBoundary || isBottomBoundary) {\n    codes.right = 0;\n  } else {\n    weights.right = cellWeights[y * width + x + 1];\n    codes.right = getVertexCode(weights.right, threshold);\n  }\n\n  // CURRENT\n  if (isLeftBoundary || isBottomBoundary) {\n    codes.current = 0;\n  } else {\n    weights.current = cellWeights[y * width + x];\n    codes.current = getVertexCode(weights.current, threshold);\n  }\n\n  const {top, topRight, right, current} = codes;\n  let code = -1;\n  if (Number.isFinite(threshold)) {\n    code = (top << 3) | (topRight << 2) | (right << 1) | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = (top << 6) | (topRight << 4) | (right << 2) | current;\n  }\n\n  let meanCode = 0;\n  // meanCode is only needed for saddle cases, and they should\n  // only occur when we are not processing a cell on boundary\n  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n  if (!isBoundary) {\n    meanCode = getVertexCode(\n      (weights.top + weights.topRight + weights.right + weights.current) / 4,\n      threshold\n    );\n  }\n  return {code, meanCode};\n}\n/* eslint-enable complexity, max-statements*/\n\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getVertices(opts) {\n  const {gridOrigin, cellSize, x, y, code, meanCode, type = CONTOUR_TYPE.ISO_LINES} = opts;\n  const thresholdData = Object.assign({}, DEFAULT_THRESHOLD_DATA, opts.thresholdData);\n  let offsets =\n    type === CONTOUR_TYPE.ISO_BANDS\n      ? ISOBANDS_CODE_OFFSET_MAP[code]\n      : ISOLINES_CODE_OFFSET_MAP[code];\n\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  // Reference vertex is at top-right move to top-right corner\n\n  const vZ = thresholdData.zIndex * thresholdData.zOffset;\n  const rX = (x + 1) * cellSize[0];\n  const rY = (y + 1) * cellSize[1];\n\n  const refVertexX = gridOrigin[0] + rX;\n  const refVertexY = gridOrigin[1] + rY;\n\n  // offsets format\n  // ISO_LINES: [[1A, 1B], [2A, 2B]],\n  // ISO_BANDS: [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n\n  // vertices format\n\n  // ISO_LINES: [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n\n  // ISO_BANDS:  => confirms to SolidPolygonLayer's simple polygon format\n  //      [\n  //        [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n  //        ...\n  //      ]\n\n  if (type === CONTOUR_TYPE.ISO_BANDS) {\n    const polygons = [];\n    offsets.forEach(polygonOffsets => {\n      const polygon = [];\n      polygonOffsets.forEach(xyOffset => {\n        const vX = refVertexX + xyOffset[0] * cellSize[0];\n        const vY = refVertexY + xyOffset[1] * cellSize[1];\n        polygon.push([vX, vY, vZ]);\n      });\n      polygons.push(polygon);\n    });\n    return polygons;\n  }\n\n  // default case is ISO_LINES\n  const lines = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = refVertexX + offset[0] * cellSize[0];\n      const vY = refVertexY + offset[1] * cellSize[1];\n      lines.push([vX, vY, vZ]);\n    });\n  });\n  return lines;\n}\n"]},"metadata":{},"sourceType":"module"}