{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { Model, Transform, FEATURES, hasFeatures, isWebGL2, readPixelsToBuffer, withParameters } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { log, project32, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE } from './gpu-grid-aggregator-constants';\nimport { AGGREGATION_OPERATION } from '../aggregation-operation-utils';\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport { getFloatTexture, getFramebuffer } from './../resource-utils.js';\nvar BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nvar ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\nvar REQUIRED_FEATURES = [FEATURES.WEBGL2, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.FLOAT_BLEND, FEATURES.TEXTURE_FLOAT];\n\nvar GPUGridAggregator = function () {\n  _createClass(GPUGridAggregator, null, [{\n    key: \"getAggregationData\",\n    value: function getAggregationData(_ref) {\n      var aggregationData = _ref.aggregationData,\n          maxData = _ref.maxData,\n          minData = _ref.minData,\n          maxMinData = _ref.maxMinData,\n          pixelIndex = _ref.pixelIndex;\n      var index = pixelIndex * PIXEL_SIZE;\n      var results = {};\n\n      if (aggregationData) {\n        results.cellCount = aggregationData[index + 3];\n        results.cellWeight = aggregationData[index];\n      }\n\n      if (maxMinData) {\n        results.maxCellWieght = maxMinData[0];\n        results.minCellWeight = maxMinData[3];\n      } else {\n        if (maxData) {\n          results.maxCellWieght = maxData[0];\n          results.totalCount = maxData[3];\n        }\n\n        if (minData) {\n          results.minCellWeight = minData[0];\n          results.totalCount = maxData[3];\n        }\n      }\n\n      return results;\n    }\n  }, {\n    key: \"getCellData\",\n    value: function getCellData(_ref2) {\n      var countsData = _ref2.countsData,\n          _ref2$size = _ref2.size,\n          size = _ref2$size === void 0 ? 1 : _ref2$size;\n      var numCells = countsData.length / 4;\n      var cellWeights = new Float32Array(numCells * size);\n      var cellCounts = new Uint32Array(numCells);\n\n      for (var i = 0; i < numCells; i++) {\n        for (var sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n          cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n        }\n\n        cellCounts[i] = countsData[i * 4 + 3];\n      }\n\n      return {\n        cellCounts: cellCounts,\n        cellWeights: cellWeights\n      };\n    }\n  }, {\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return hasFeatures(gl, REQUIRED_FEATURES);\n    }\n  }]);\n\n  function GPUGridAggregator(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, GPUGridAggregator);\n\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n      resources: {},\n      results: {}\n    };\n    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FLOAT);\n\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  _createClass(GPUGridAggregator, [{\n    key: \"delete\",\n    value: function _delete() {\n      var gridAggregationModel = this.gridAggregationModel,\n          allAggregationModel = this.allAggregationModel,\n          meanTransform = this.meanTransform;\n      var _this$state = this.state,\n          textures = _this$state.textures,\n          framebuffers = _this$state.framebuffers,\n          maxMinFramebuffers = _this$state.maxMinFramebuffers,\n          minFramebuffers = _this$state.minFramebuffers,\n          maxFramebuffers = _this$state.maxFramebuffers,\n          meanTextures = _this$state.meanTextures,\n          resources = _this$state.resources;\n      gridAggregationModel && gridAggregationModel[\"delete\"]();\n      allAggregationModel && allAggregationModel[\"delete\"]();\n      meanTransform && meanTransform[\"delete\"]();\n      deleteResources([framebuffers, textures, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources]);\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.setState({\n        results: {}\n      });\n\n      var aggregationParams = this._normalizeAggregationParams(opts);\n\n      if (!this._hasGPUSupport) {\n        log.log(1, 'GPUGridAggregator: not supported')();\n      }\n\n      return this._runAggregation(aggregationParams);\n    }\n  }, {\n    key: \"getData\",\n    value: function getData(weightId) {\n      var data = {};\n      var results = this.state.results;\n\n      if (!results[weightId].aggregationData) {\n        results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n      }\n\n      data.aggregationData = results[weightId].aggregationData;\n\n      for (var arrayName in ARRAY_BUFFER_MAP) {\n        var bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n        if (results[weightId][arrayName] || results[weightId][bufferName]) {\n          results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();\n          data[arrayName] = results[weightId][arrayName];\n        }\n      }\n\n      return data;\n    }\n  }, {\n    key: \"updateShaders\",\n    value: function updateShaders() {\n      var shaderOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.setState({\n        shaderOptions: shaderOptions,\n        modelDirty: true\n      });\n    }\n  }, {\n    key: \"_normalizeAggregationParams\",\n    value: function _normalizeAggregationParams(opts) {\n      var aggregationParams = Object.assign({}, DEFAULT_RUN_PARAMS, opts);\n      var weights = aggregationParams.weights;\n\n      if (weights) {\n        aggregationParams.weights = normalizeWeightParams(weights);\n      }\n\n      return aggregationParams;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      Object.assign(this.state, updateObject);\n    }\n  }, {\n    key: \"_getAggregateData\",\n    value: function _getAggregateData(opts) {\n      var results = {};\n      var _this$state2 = this.state,\n          textures = _this$state2.textures,\n          framebuffers = _this$state2.framebuffers,\n          maxMinFramebuffers = _this$state2.maxMinFramebuffers,\n          minFramebuffers = _this$state2.minFramebuffers,\n          maxFramebuffers = _this$state2.maxFramebuffers,\n          resources = _this$state2.resources;\n      var weights = opts.weights;\n\n      for (var id in weights) {\n        results[id] = {};\n        var _weights$id = weights[id],\n            needMin = _weights$id.needMin,\n            needMax = _weights$id.needMax,\n            combineMaxMin = _weights$id.combineMaxMin;\n        results[id].aggregationTexture = textures[id];\n        results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n          target: weights[id].aggregationBuffer,\n          sourceType: 5126\n        });\n\n        if (needMin && needMax && combineMaxMin) {\n          results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n            target: weights[id].maxMinBuffer,\n            sourceType: 5126\n          });\n          results[id].maxMinTexture = resources[\"\".concat(id, \"-maxMinTexture\")];\n        } else {\n          if (needMin) {\n            results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n              target: weights[id].minBuffer,\n              sourceType: 5126\n            });\n            results[id].minTexture = resources[\"\".concat(id, \"-minTexture\")];\n          }\n\n          if (needMax) {\n            results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n              target: weights[id].maxBuffer,\n              sourceType: 5126\n            });\n            results[id].maxTexture = resources[\"\".concat(id, \"-maxTexture\")];\n          }\n        }\n      }\n\n      this._trackGPUResultBuffers(results, weights);\n\n      return results;\n    }\n  }, {\n    key: \"_renderAggregateData\",\n    value: function _renderAggregateData(opts) {\n      var cellSize = opts.cellSize,\n          projectPoints = opts.projectPoints,\n          attributes = opts.attributes,\n          moduleSettings = opts.moduleSettings,\n          numCol = opts.numCol,\n          numRow = opts.numRow,\n          weights = opts.weights,\n          translation = opts.translation,\n          scaling = opts.scaling;\n      var _this$state3 = this.state,\n          maxMinFramebuffers = _this$state3.maxMinFramebuffers,\n          minFramebuffers = _this$state3.minFramebuffers,\n          maxFramebuffers = _this$state3.maxFramebuffers;\n      var gridSize = [numCol, numRow];\n      var parameters = {\n        blend: true,\n        depthTest: false,\n        blendFunc: [1, 1]\n      };\n      var uniforms = {\n        cellSize: cellSize,\n        gridSize: gridSize,\n        projectPoints: projectPoints,\n        translation: translation,\n        scaling: scaling\n      };\n\n      for (var id in weights) {\n        var _weights$id2 = weights[id],\n            needMin = _weights$id2.needMin,\n            needMax = _weights$id2.needMax;\n        var combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n\n        this._renderToWeightsTexture({\n          id: id,\n          parameters: parameters,\n          moduleSettings: moduleSettings,\n          uniforms: uniforms,\n          gridSize: gridSize,\n          attributes: attributes,\n          weights: weights\n        });\n\n        if (combineMaxMin) {\n          this._renderToMaxMinTexture({\n            id: id,\n            parameters: Object.assign({}, parameters, {\n              blendEquation: MAX_MIN_BLEND_EQUATION\n            }),\n            gridSize: gridSize,\n            minOrMaxFb: maxMinFramebuffers[id],\n            clearParams: {\n              clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]\n            },\n            combineMaxMin: combineMaxMin\n          });\n        } else {\n          if (needMin) {\n            this._renderToMaxMinTexture({\n              id: id,\n              parameters: Object.assign({}, parameters, {\n                blendEquation: MIN_BLEND_EQUATION\n              }),\n              gridSize: gridSize,\n              minOrMaxFb: minFramebuffers[id],\n              clearParams: {\n                clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n              },\n              combineMaxMin: combineMaxMin\n            });\n          }\n\n          if (needMax) {\n            this._renderToMaxMinTexture({\n              id: id,\n              parameters: Object.assign({}, parameters, {\n                blendEquation: MAX_BLEND_EQUATION\n              }),\n              gridSize: gridSize,\n              minOrMaxFb: maxFramebuffers[id],\n              clearParams: {\n                clearColor: [0, 0, 0, 0]\n              },\n              combineMaxMin: combineMaxMin\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_renderToMaxMinTexture\",\n    value: function _renderToMaxMinTexture(opts) {\n      var id = opts.id,\n          parameters = opts.parameters,\n          gridSize = opts.gridSize,\n          minOrMaxFb = opts.minOrMaxFb,\n          combineMaxMin = opts.combineMaxMin,\n          _opts$clearParams = opts.clearParams,\n          clearParams = _opts$clearParams === void 0 ? {} : _opts$clearParams;\n      var framebuffers = this.state.framebuffers;\n      var gl = this.gl,\n          allAggregationModel = this.allAggregationModel;\n      withParameters(gl, _objectSpread({}, clearParams, {\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      }), function () {\n        gl.clear(16384);\n        allAggregationModel.draw({\n          parameters: parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize: gridSize,\n            combineMaxMin: combineMaxMin\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_renderToWeightsTexture\",\n    value: function _renderToWeightsTexture(opts) {\n      var id = opts.id,\n          parameters = opts.parameters,\n          moduleSettings = opts.moduleSettings,\n          uniforms = opts.uniforms,\n          gridSize = opts.gridSize,\n          weights = opts.weights;\n      var _this$state4 = this.state,\n          framebuffers = _this$state4.framebuffers,\n          equations = _this$state4.equations,\n          weightAttributes = _this$state4.weightAttributes;\n      var gl = this.gl,\n          gridAggregationModel = this.gridAggregationModel;\n      var operation = weights[id].operation;\n      var clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];\n      withParameters(gl, {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor: clearColor\n      }, function () {\n        gl.clear(16384);\n        var attributes = {\n          weights: weightAttributes[id]\n        };\n        gridAggregationModel.draw({\n          parameters: Object.assign({}, parameters, {\n            blendEquation: equations[id]\n          }),\n          moduleSettings: moduleSettings,\n          uniforms: uniforms,\n          attributes: attributes\n        });\n      });\n\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        var _this$state5 = this.state,\n            meanTextures = _this$state5.meanTextures,\n            textures = _this$state5.textures;\n        var transformOptions = {\n          _sourceTextures: {\n            aggregationValues: meanTextures[id]\n          },\n          _targetTexture: textures[id],\n          elementCount: textures[id].width * textures[id].height\n        };\n\n        if (this.meanTransform) {\n          this.meanTransform.update(transformOptions);\n        } else {\n          this.meanTransform = getMeanTransform(gl, transformOptions);\n        }\n\n        this.meanTransform.run({\n          parameters: {\n            blend: false,\n            depthTest: false\n          }\n        });\n        framebuffers[id].attach(_defineProperty({}, 36064, textures[id]));\n      }\n    }\n  }, {\n    key: \"_runAggregation\",\n    value: function _runAggregation(opts) {\n      this._updateModels(opts);\n\n      this._setupFramebuffers(opts);\n\n      this._renderAggregateData(opts);\n\n      var results = this._getAggregateData(opts);\n\n      this.setState({\n        results: results\n      });\n      return results;\n    }\n  }, {\n    key: \"_setupFramebuffers\",\n    value: function _setupFramebuffers(opts) {\n      var _this$state6 = this.state,\n          textures = _this$state6.textures,\n          framebuffers = _this$state6.framebuffers,\n          maxMinFramebuffers = _this$state6.maxMinFramebuffers,\n          minFramebuffers = _this$state6.minFramebuffers,\n          maxFramebuffers = _this$state6.maxFramebuffers,\n          meanTextures = _this$state6.meanTextures,\n          equations = _this$state6.equations;\n      var weights = opts.weights;\n      var numCol = opts.numCol,\n          numRow = opts.numRow;\n      var framebufferSize = {\n        width: numCol,\n        height: numRow\n      };\n\n      for (var id in weights) {\n        var _weights$id3 = weights[id],\n            needMin = _weights$id3.needMin,\n            needMax = _weights$id3.needMax,\n            combineMaxMin = _weights$id3.combineMaxMin,\n            operation = _weights$id3.operation;\n        textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.gl, {\n          id: \"\".concat(id, \"-texture\"),\n          width: numCol,\n          height: numRow\n        });\n        textures[id].resize(framebufferSize);\n        var texture = textures[id];\n\n        if (operation === AGGREGATION_OPERATION.MEAN) {\n          meanTextures[id] = meanTextures[id] || getFloatTexture(this.gl, {\n            id: \"\".concat(id, \"-mean-texture\"),\n            width: numCol,\n            height: numRow\n          });\n          meanTextures[id].resize(framebufferSize);\n          texture = meanTextures[id];\n        }\n\n        if (framebuffers[id]) {\n          framebuffers[id].attach(_defineProperty({}, 36064, texture));\n        } else {\n          framebuffers[id] = getFramebuffer(this.gl, {\n            id: \"\".concat(id, \"-fb\"),\n            width: numCol,\n            height: numRow,\n            texture: texture\n          });\n        }\n\n        framebuffers[id].resize(framebufferSize);\n        equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n\n        if (needMin || needMax) {\n          if (needMin && needMax && combineMaxMin) {\n            if (!maxMinFramebuffers[id]) {\n              texture = weights[id].maxMinTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxMinTexture\"));\n              maxMinFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-maxMinFb\"),\n                texture: texture\n              });\n            }\n          } else {\n            if (needMin) {\n              if (!minFramebuffers[id]) {\n                texture = weights[id].minTexture || this._getMinMaxTexture(\"\".concat(id, \"-minTexture\"));\n                minFramebuffers[id] = getFramebuffer(this.gl, {\n                  id: \"\".concat(id, \"-minFb\"),\n                  texture: texture\n                });\n              }\n            }\n\n            if (needMax) {\n              if (!maxFramebuffers[id]) {\n                texture = weights[id].maxTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxTexture\"));\n                maxFramebuffers[id] = getFramebuffer(this.gl, {\n                  id: \"\".concat(id, \"-maxFb\"),\n                  texture: texture\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_getMinMaxTexture\",\n    value: function _getMinMaxTexture(name) {\n      var resources = this.state.resources;\n\n      if (!resources[name]) {\n        resources[name] = getFloatTexture(this.gl, {\n          id: \"resourceName\"\n        });\n      }\n\n      return resources[name];\n    }\n  }, {\n    key: \"_setupModels\",\n    value: function _setupModels() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$numCol = _ref3.numCol,\n          numCol = _ref3$numCol === void 0 ? 0 : _ref3$numCol,\n          _ref3$numRow = _ref3.numRow,\n          numRow = _ref3$numRow === void 0 ? 0 : _ref3$numRow;\n\n      var gl = this.gl;\n      var shaderOptions = this.state.shaderOptions;\n\n      if (this.gridAggregationModel) {\n        this.gridAggregationModel[\"delete\"]();\n      }\n\n      this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n\n      if (!this.allAggregationModel) {\n        var instanceCount = numCol * numRow;\n        this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n      }\n    }\n  }, {\n    key: \"_setupWeightAttributes\",\n    value: function _setupWeightAttributes(opts) {\n      var weightAttributes = this.state.weightAttributes;\n      var weights = opts.weights;\n\n      for (var id in weights) {\n        weightAttributes[id] = opts.attributes[id];\n      }\n    }\n  }, {\n    key: \"_trackGPUResultBuffers\",\n    value: function _trackGPUResultBuffers(results, weights) {\n      var resources = this.state.resources;\n\n      for (var id in results) {\n        if (results[id]) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = BUFFER_NAMES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var bufferName = _step.value;\n\n              if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n                var name = \"gpu-result-\".concat(id, \"-\").concat(bufferName);\n\n                if (resources[name]) {\n                  resources[name][\"delete\"]();\n                }\n\n                resources[name] = results[id][bufferName];\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateModels\",\n    value: function _updateModels(opts) {\n      var vertexCount = opts.vertexCount,\n          attributes = opts.attributes,\n          numCol = opts.numCol,\n          numRow = opts.numRow;\n      var modelDirty = this.state.modelDirty;\n\n      if (modelDirty) {\n        this._setupModels(opts);\n\n        this.setState({\n          modelDirty: false\n        });\n      }\n\n      this._setupWeightAttributes(opts);\n\n      this.gridAggregationModel.setVertexCount(vertexCount);\n      this.gridAggregationModel.setAttributes(attributes);\n      this.allAggregationModel.setInstanceCount(numCol * numRow);\n    }\n  }]);\n\n  return GPUGridAggregator;\n}();\n\nexport { GPUGridAggregator as default };\n\nfunction normalizeWeightParams(weights) {\n  var result = {};\n\n  for (var id in weights) {\n    result[id] = Object.assign({}, DEFAULT_WEIGHT_PARAMS, weights[id]);\n  }\n\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(function (obj) {\n    for (var name in obj) {\n      obj[name][\"delete\"]();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  var shaders = mergeShaders({\n    vs: AGGREGATE_TO_GRID_VS,\n    fs: AGGREGATE_TO_GRID_FS,\n    modules: [fp64arithmetic, project32]\n  }, shaderOptions);\n  return new Model(gl, _objectSpread({\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: 0\n  }, shaders));\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: 0,\n    isInstanced: true,\n    instanceCount: instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, Object.assign({}, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues'\n  }, opts));\n}","map":{"version":3,"sources":["../../../../src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js"],"names":["_mergeShaders","BUFFER_NAMES","ARRAY_BUFFER_MAP","maxData","minData","maxMinData","REQUIRED_FEATURES","FEATURES","GPUGridAggregator","aggregationData","pixelIndex","index","results","countsData","size","numCells","cellWeights","cellCounts","i","sizeIndex","gl","hasFeatures","opts","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","isWebGL2","gridAggregationModel","allAggregationModel","meanTransform","deleteResources","aggregationParams","log","weightId","data","bufferName","shaderOptions","modelDirty","Object","weights","normalizeWeightParams","updateObject","needMin","needMax","combineMaxMin","readPixelsToBuffer","target","sourceType","cellSize","projectPoints","attributes","moduleSettings","numCol","numRow","translation","scaling","gridSize","parameters","blend","depthTest","blendFunc","uniforms","id","blendEquation","MAX_MIN_BLEND_EQUATION","minOrMaxFb","clearParams","clearColor","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","withParameters","framebuffer","viewport","uSampler","operation","AGGREGATION_OPERATION","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","height","getMeanTransform","framebufferSize","width","getFloatTexture","texture","getFramebuffer","EQUATION_MAP","name","getAggregationModel","instanceCount","getAllAggregationModel","vertexCount","result","Array","obj","shaders","mergeShaders","vs","fs","modules","drawMode","isInstanced","position","_targetTextureVarying"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Model,\n  Transform,\n  FEATURES,\n  hasFeatures,\n  isWebGL2,\n  readPixelsToBuffer,\n  withParameters\n} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {log, project32, _mergeShaders as mergeShaders} from '@deck.gl/core';\n\nimport {\n  DEFAULT_RUN_PARAMS,\n  MAX_32_BIT_FLOAT,\n  MIN_BLEND_EQUATION,\n  MAX_BLEND_EQUATION,\n  MAX_MIN_BLEND_EQUATION,\n  EQUATION_MAP,\n  DEFAULT_WEIGHT_PARAMS,\n  PIXEL_SIZE\n} from './gpu-grid-aggregator-constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport {getFloatTexture, getFramebuffer} from './../resource-utils.js';\n\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.WEBGL2, // TODO: Remove after trannsform refactor\n  FEATURES.COLOR_ATTACHMENT_RGBA32F,\n  FEATURES.BLEND_EQUATION_MINMAX,\n  FEATURES.FLOAT_BLEND,\n  FEATURES.TEXTURE_FLOAT\n];\n\nexport default class GPUGridAggregator {\n  // Decode and return aggregation data of given pixel.\n  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n\n  // Decodes and retuns counts and weights of all cells\n  static getCellData({countsData, size = 1}) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      // weights in RGB channels\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      // count in Alpha channel\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {cellCounts, cellWeights};\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  // DEBUG ONLY\n  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n  //   if (aggregationBuffer) {\n  //     console.log('Aggregation Data:');\n  //     const agrData = aggregationBuffer.getData();\n  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n  //       if (agrData[index + 3] > 0) {\n  //         console.log(\n  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n  //             agrData[index + 2]\n  //           } count: ${agrData[index + 3]}`\n  //         );\n  //         limit--;\n  //       }\n  //     }\n  //   }\n  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n  //   for (const key in obj) {\n  //     if (obj[key]) {\n  //       const data = obj[key].getData();\n  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n  //     }\n  //   }\n  // }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      // per weight GPU resources\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n\n      // common resources to be deleted\n      resources: {},\n\n      // results\n      results: {}\n    };\n    this._hasGPUSupport =\n      isWebGL2(gl) && // gl_InstanceID usage in min/max calculation shaders\n      hasFeatures(\n        this.gl,\n        FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes\n        FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture\n        FEATURES.TEXTURE_FLOAT // sample from a float texture\n      );\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  // Delete owned resources.\n  /* eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true }] */\n  delete() {\n    const {gridAggregationModel, allAggregationModel, meanTransform} = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n\n    gridAggregationModel && gridAggregationModel.delete();\n    allAggregationModel && allAggregationModel.delete();\n    meanTransform && meanTransform.delete();\n\n    deleteResources([\n      framebuffers,\n      textures,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    ]);\n  }\n\n  // Perform aggregation and retun the results\n  run(opts = {}) {\n    // reset results\n    this.setState({results: {}});\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n\n  // Reads aggregation data into JS Array object\n  // For WebGL1, data is available in JS Array objects already.\n  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      // cache the results if reading from the buffer (WebGL2 path)\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n\n    // Check for optional results\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        // cache the result\n        results[weightId][arrayName] =\n          results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({shaderOptions, modelDirty: true});\n  }\n\n  // PRIVATE\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = Object.assign({}, DEFAULT_RUN_PARAMS, opts);\n    const {weights} = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n\n  // Update priveate state\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  // GPU Aggregation methods\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {weights} = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {needMin, needMax, combineMaxMin} = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer, // update if a buffer is provided\n        sourceType: GL.FLOAT\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer, // update if a buffer is provided\n          sourceType: GL.FLOAT\n        });\n        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].minTexture = resources[`${id}-minTexture`];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].maxTexture = resources[`${id}-maxTexture`];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {maxMinFramebuffers, minFramebuffers, maxFramebuffers} = this.state;\n\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [GL.ONE, GL.ONE]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: Object.assign({}, parameters, {blendEquation: MAX_MIN_BLEND_EQUATION}),\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]},\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: Object.assign({}, parameters, {blendEquation: MIN_BLEND_EQUATION}),\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]},\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: Object.assign({}, parameters, {blendEquation: MAX_BLEND_EQUATION}),\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {clearColor: [0, 0, 0, 0]},\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n  _renderToMaxMinTexture(opts) {\n    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;\n    const {framebuffers} = this.state;\n    const {gl, allAggregationModel} = this;\n\n    withParameters(\n      gl,\n      {\n        ...clearParams,\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        allAggregationModel.draw({\n          parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize,\n            combineMaxMin\n          }\n        });\n      }\n    );\n  }\n\n  // render all data points to aggregate weights\n  _renderToWeightsTexture(opts) {\n    const {id, parameters, moduleSettings, uniforms, gridSize, weights} = opts;\n    const {framebuffers, equations, weightAttributes} = this.state;\n    const {gl, gridAggregationModel} = this;\n    const {operation} = weights[id];\n\n    const clearColor =\n      operation === AGGREGATION_OPERATION.MIN\n        ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n        : [0, 0, 0, 0];\n    withParameters(\n      gl,\n      {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        const attributes = {weights: weightAttributes[id]};\n        gridAggregationModel.draw({\n          parameters: Object.assign({}, parameters, {blendEquation: equations[id]}),\n          moduleSettings,\n          uniforms,\n          attributes\n        });\n      }\n    );\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {meanTextures, textures} = this.state;\n      const transformOptions = {\n        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data\n        _targetTexture: textures[id], // store mean values,\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n\n      // update framebuffer with mean results so readPixelsToBuffer returns mean values\n      framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: textures[id]});\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({results});\n    return results;\n  }\n\n  // set up framebuffer for each weight\n  /* eslint-disable complexity, max-depth, max-statements*/\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {weights} = opts;\n    const {numCol, numRow} = opts;\n    const framebufferSize = {width: numCol, height: numRow};\n    for (const id in weights) {\n      const {needMin, needMax, combineMaxMin, operation} = weights[id];\n      textures[id] =\n        weights[id].aggregationTexture ||\n        textures[id] ||\n        getFloatTexture(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        // For MEAN, we first aggregatet into a temp texture\n        meanTextures[id] =\n          meanTextures[id] ||\n          getFloatTexture(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: texture});\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: `${id}-fb`,\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      // For min/max framebuffers will use default size 1X1\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {id: `${id}-maxMinFb`, texture});\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-minFb`,\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-maxFb`,\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable complexity, max-depth, max-statements */\n\n  _getMinMaxTexture(name) {\n    const {resources} = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {id: `resourceName`});\n    }\n    return resources[name];\n  }\n\n  _setupModels({numCol = 0, numRow = 0} = {}) {\n    const {gl} = this;\n    const {shaderOptions} = this.state;\n    if (this.gridAggregationModel) {\n      this.gridAggregationModel.delete();\n    }\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  // set up buffers for all weights\n  _setupWeightAttributes(opts) {\n    const {weightAttributes} = this.state;\n    const {weights} = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.\n  /* eslint-disable max-depth */\n  _trackGPUResultBuffers(results, weights) {\n    const {resources} = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object\n            // collect the new buffer for garabge collection\n            const name = `gpu-result-${id}-${bufferName}`;\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable max-depth */\n\n  _updateModels(opts) {\n    const {vertexCount, attributes, numCol, numRow} = opts;\n    const {modelDirty} = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({modelDirty: false});\n    }\n\n    // this maps color/elevation to weight name.\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\n\n// HELPER METHODS\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = Object.assign({}, DEFAULT_WEIGHT_PARAMS, weights[id]);\n  }\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders(\n    {\n      vs: AGGREGATE_TO_GRID_VS,\n      fs: AGGREGATE_TO_GRID_FS,\n      modules: [fp64arithmetic, project32]\n    },\n    shaderOptions\n  );\n\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(\n    gl,\n    Object.assign(\n      {},\n      {\n        vs: TRANSFORM_MEAN_VS,\n        _targetTextureVarying: 'meanValues'\n      },\n      opts\n    )\n  );\n}\n"]},"metadata":{},"sourceType":"module"}