{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { getMeshBoundingBox } from '@loaders.gl/loader-utils';\nvar GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\nvar DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\nvar DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nvar DracoParser = function () {\n  function DracoParser(draco) {\n    _classCallCheck(this, DracoParser);\n\n    this.draco = draco;\n    this.drawMode = 'TRIANGLE';\n  }\n\n  _createClass(DracoParser, [{\n    key: \"destroy\",\n    value: function destroy() {}\n  }, {\n    key: \"destroyGeometry\",\n    value: function destroyGeometry(dracoGeometry) {\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry.dracoGeometry);\n      }\n    }\n  }, {\n    key: \"parseSync\",\n    value: function parseSync(arrayBuffer, options) {\n      var buffer = new this.draco.DecoderBuffer();\n      buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n      var decoder = new this.draco.Decoder();\n      var data = {};\n      var dracoStatus;\n      var dracoGeometry;\n      var header;\n\n      try {\n        var geometryType = decoder.GetEncodedGeometryType(buffer);\n\n        switch (geometryType) {\n          case this.draco.TRIANGULAR_MESH:\n            dracoGeometry = new this.draco.Mesh();\n            dracoStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n            header = {\n              type: GEOMETRY_TYPE.TRIANGULAR_MESH,\n              faceCount: dracoGeometry.num_faces(),\n              attributeCount: dracoGeometry.num_attributes(),\n              vertexCount: dracoGeometry.num_points()\n            };\n            break;\n\n          case this.draco.POINT_CLOUD:\n            dracoGeometry = new this.draco.PointCloud();\n            dracoStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n            header = {\n              type: GEOMETRY_TYPE.POINT_CLOUD,\n              attributeCount: dracoGeometry.num_attributes(),\n              vertexCount: dracoGeometry.num_points()\n            };\n            break;\n\n          default:\n            throw new Error('Unknown DRACO geometry type.');\n        }\n\n        if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n          var message = \"DRACO decompression failed: \".concat(dracoStatus.error_msg());\n\n          if (dracoGeometry) {\n            this.draco.destroy(dracoGeometry);\n          }\n\n          throw new Error(message);\n        }\n\n        data.loaderData = {\n          header: header\n        };\n        this.extractDRACOGeometry(decoder, dracoGeometry, geometryType, data);\n        data.header = {\n          vertexCount: header.vertexCount,\n          boundingBox: getMeshBoundingBox(data.attributes)\n        };\n      } finally {\n        this.draco.destroy(decoder);\n        this.draco.destroy(buffer);\n      }\n\n      return data;\n    }\n  }, {\n    key: \"extractDRACOGeometry\",\n    value: function extractDRACOGeometry(decoder, dracoGeometry, geometryType, geometry) {\n      var attributes = this.getAttributes(decoder, dracoGeometry);\n      var positionAttribute = attributes.POSITION;\n\n      if (!positionAttribute) {\n        throw new Error('DRACO decompressor: No position attribute found.');\n      }\n\n      this.getPositionAttributeMetadata(positionAttribute);\n\n      if (geometryType === this.draco.TRIANGULAR_MESH) {\n        attributes.indices = this.drawMode === 'TRIANGLE_STRIP' ? this.getMeshStripIndices(decoder, dracoGeometry) : this.getMeshFaceIndices(decoder, dracoGeometry);\n        geometry.mode = this.drawMode === 'TRIANGLE_STRIP' ? 5 : 4;\n      } else {\n        geometry.mode = 0;\n      }\n\n      if (attributes.indices) {\n        geometry.indices = {\n          value: attributes.indices,\n          size: 1\n        };\n        delete attributes.indices;\n      }\n\n      geometry.attributes = attributes;\n      return geometry;\n    }\n  }, {\n    key: \"getPositionAttributeMetadata\",\n    value: function getPositionAttributeMetadata(positionAttribute) {\n      this.metadata = this.metadata || {};\n      this.metadata.attributes = this.metadata.attributes || {};\n      var posTransform = new this.draco.AttributeQuantizationTransform();\n\n      if (posTransform.InitFromAttribute(positionAttribute)) {\n        this.metadata.attributes.position.isQuantized = true;\n        this.metadata.attributes.position.maxRange = posTransform.range();\n        this.metadata.attributes.position.numQuantizationBits = posTransform.quantization_bits();\n        this.metadata.attributes.position.minValues = new Float32Array(3);\n\n        for (var i = 0; i < 3; ++i) {\n          this.metadata.attributes.position.minValues[i] = posTransform.min_value(i);\n        }\n      }\n\n      this.draco.destroy(posTransform);\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes(decoder, dracoGeometry) {\n      var attributes = {};\n      var numPoints = dracoGeometry.num_points();\n\n      for (var attributeName in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n        var attributeType = this.draco[attributeName];\n        var attributeId = decoder.GetAttributeId(dracoGeometry, attributeType);\n\n        if (attributeId !== -1) {\n          var dracoAttribute = decoder.GetAttribute(dracoGeometry, attributeId);\n\n          var _this$getAttributeTyp = this.getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName),\n              typedArray = _this$getAttributeTyp.typedArray;\n\n          attributes[DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[attributeName]] = {\n            value: typedArray,\n            size: typedArray.length / numPoints\n          };\n        }\n      }\n\n      return attributes;\n    }\n  }, {\n    key: \"getMeshFaceIndices\",\n    value: function getMeshFaceIndices(decoder, dracoGeometry) {\n      var numFaces = dracoGeometry.num_faces();\n      var numIndices = numFaces * 3;\n      var indices = new Uint32Array(numIndices);\n      var dracoArray = new this.draco.DracoInt32Array();\n\n      for (var i = 0; i < numFaces; ++i) {\n        decoder.GetFaceFromMesh(dracoGeometry, i, dracoArray);\n        var index = i * 3;\n        indices[index] = dracoArray.GetValue(0);\n        indices[index + 1] = dracoArray.GetValue(1);\n        indices[index + 2] = dracoArray.GetValue(2);\n      }\n\n      this.draco.destroy(dracoArray);\n      return indices;\n    }\n  }, {\n    key: \"getMeshStripIndices\",\n    value: function getMeshStripIndices(decoder, dracoGeometry) {\n      var dracoArray = new this.draco.DracoInt32Array();\n      decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      var indices = new Uint32Array(dracoArray.size());\n\n      for (var i = 0; i < dracoArray.size(); ++i) {\n        indices[i] = dracoArray.GetValue(i);\n      }\n\n      this.draco.destroy(dracoArray);\n      return indices;\n    }\n  }, {\n    key: \"getAttributeTypedArray\",\n    value: function getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName) {\n      if (dracoAttribute.ptr === 0) {\n        var message = \"DRACO decode bad attribute \".concat(attributeName);\n        throw new Error(message);\n      }\n\n      var attributeType = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];\n      var numComponents = dracoAttribute.num_components();\n      var numPoints = dracoGeometry.num_points();\n      var numValues = numPoints * numComponents;\n      var dracoArray;\n      var typedArray;\n\n      switch (attributeType) {\n        case Float32Array:\n          dracoArray = new this.draco.DracoFloat32Array();\n          decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Float32Array(numValues);\n          break;\n\n        case Int8Array:\n          dracoArray = new this.draco.DracoInt8Array();\n          decoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Int8Array(numValues);\n          break;\n\n        case Int16Array:\n          dracoArray = new this.draco.DracoInt16Array();\n          decoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Int16Array(numValues);\n          break;\n\n        case Int32Array:\n          dracoArray = new this.draco.DracoInt32Array();\n          decoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Int32Array(numValues);\n          break;\n\n        case Uint8Array:\n          dracoArray = new this.draco.DracoUInt8Array();\n          decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Uint8Array(numValues);\n          break;\n\n        case Uint16Array:\n          dracoArray = new this.draco.DracoUInt16Array();\n          decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Uint16Array(numValues);\n          break;\n\n        case Uint32Array:\n          dracoArray = new this.draco.DracoUInt32Array();\n          decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Uint32Array(numValues);\n          break;\n\n        default:\n          var errorMsg = 'DRACO decoder: unexpected attribute type.';\n          throw new Error(errorMsg);\n      }\n\n      for (var i = 0; i < numValues; i++) {\n        typedArray[i] = dracoArray.GetValue(i);\n      }\n\n      this.draco.destroy(dracoArray);\n      return {\n        typedArray: typedArray,\n        components: numComponents\n      };\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(arrayBuffer, options) {\n      return this.parseSync(arrayBuffer, options);\n    }\n  }]);\n\n  return DracoParser;\n}();\n\nexport { DracoParser as default };","map":{"version":3,"sources":["../../../src/lib/draco-parser.js"],"names":["GEOMETRY_TYPE","TRIANGULAR_MESH","POINT_CLOUD","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","Float32Array","DracoParser","dracoGeometry","arrayBuffer","options","buffer","decoder","data","geometryType","dracoStatus","header","type","faceCount","attributeCount","vertexCount","message","boundingBox","getMeshBoundingBox","geometry","attributes","positionAttribute","value","size","posTransform","i","numPoints","attributeType","attributeId","dracoAttribute","typedArray","numFaces","numIndices","indices","dracoArray","index","attributeName","numComponents","numValues","errorMsg","components"],"mappings":"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","sourcesContent":["// This code is a fork of example code from the DRACO repository\n// Copyright 2017 The Draco Authors.\n// Licensed under the Apache License, Version 2.0 (the 'License');\nimport {getMeshBoundingBox} from '@loaders.gl/loader-utils';\n\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nexport default class DracoParser {\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco) {\n    this.draco = draco;\n    this.drawMode = 'TRIANGLE';\n  }\n\n  destroy() {}\n\n  destroyGeometry(dracoGeometry) {\n    if (dracoGeometry) {\n      this.draco.destroy(dracoGeometry.dracoGeometry);\n    }\n  }\n\n  // NOTE: caller must call `destroyGeometry` on the return value after using it\n  parseSync(arrayBuffer, options) {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    const decoder = new this.draco.Decoder();\n\n    const data = {};\n    let dracoStatus;\n    let dracoGeometry;\n    let header;\n\n    try {\n      const geometryType = decoder.GetEncodedGeometryType(buffer);\n      switch (geometryType) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoGeometry = new this.draco.Mesh();\n          dracoStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n          header = {\n            type: GEOMETRY_TYPE.TRIANGULAR_MESH,\n            faceCount: dracoGeometry.num_faces(),\n            attributeCount: dracoGeometry.num_attributes(),\n            vertexCount: dracoGeometry.num_points()\n          };\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoGeometry = new this.draco.PointCloud();\n          dracoStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          header = {\n            type: GEOMETRY_TYPE.POINT_CLOUD,\n            attributeCount: dracoGeometry.num_attributes(),\n            vertexCount: dracoGeometry.num_points()\n          };\n          break;\n\n        default:\n          throw new Error('Unknown DRACO geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        if (dracoGeometry) {\n          this.draco.destroy(dracoGeometry);\n        }\n        throw new Error(message);\n      }\n\n      data.loaderData = {header};\n\n      this.extractDRACOGeometry(decoder, dracoGeometry, geometryType, data);\n\n      data.header = {\n        vertexCount: header.vertexCount,\n        boundingBox: getMeshBoundingBox(data.attributes)\n      };\n    } finally {\n      this.draco.destroy(decoder);\n      this.draco.destroy(buffer);\n    }\n\n    return data;\n  }\n\n  extractDRACOGeometry(decoder, dracoGeometry, geometryType, geometry) {\n    // const numPoints = dracoGeometry.num_points();\n    // const numAttributes = dracoGeometry.num_attributes();\n\n    // Structure for converting to WebGL framework specific attributes later\n    const attributes = this.getAttributes(decoder, dracoGeometry);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO decompressor: No position attribute found.');\n    }\n\n    this.getPositionAttributeMetadata(positionAttribute);\n\n    // For meshes, we need indices to define the faces.\n    if (geometryType === this.draco.TRIANGULAR_MESH) {\n      attributes.indices =\n        this.drawMode === 'TRIANGLE_STRIP'\n          ? this.getMeshStripIndices(decoder, dracoGeometry)\n          : this.getMeshFaceIndices(decoder, dracoGeometry);\n      geometry.mode =\n        this.drawMode === 'TRIANGLE_STRIP'\n          ? 5 // GL.TRIANGLE_STRIP\n          : 4; // GL.TRIANGLES\n    } else {\n      geometry.mode = 0; // GL.POINTS\n    }\n\n    if (attributes.indices) {\n      geometry.indices = {value: attributes.indices, size: 1};\n      delete attributes.indices;\n    }\n    geometry.attributes = attributes;\n\n    return geometry;\n  }\n\n  getPositionAttributeMetadata(positionAttribute) {\n    this.metadata = this.metadata || {};\n    this.metadata.attributes = this.metadata.attributes || {};\n\n    const posTransform = new this.draco.AttributeQuantizationTransform();\n    if (posTransform.InitFromAttribute(positionAttribute)) {\n      // Quantized attribute. Store the quantization parameters into the attribute\n      this.metadata.attributes.position.isQuantized = true;\n      this.metadata.attributes.position.maxRange = posTransform.range();\n      this.metadata.attributes.position.numQuantizationBits = posTransform.quantization_bits();\n      this.metadata.attributes.position.minValues = new Float32Array(3);\n      for (let i = 0; i < 3; ++i) {\n        this.metadata.attributes.position.minValues[i] = posTransform.min_value(i);\n      }\n    }\n    this.draco.destroy(posTransform);\n  }\n\n  getAttributes(decoder, dracoGeometry) {\n    const attributes = {};\n    const numPoints = dracoGeometry.num_points();\n    // const attributeUniqueIdMap = {};\n\n    // Add native Draco attribute type to geometry.\n    for (const attributeName in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      // The native attribute type is only used when no unique Id is provided.\n      // For example, loading .drc files.\n\n      // if (attributeUniqueIdMap[attributeName] === undefined) {\n      const attributeType = this.draco[attributeName];\n      const attributeId = decoder.GetAttributeId(dracoGeometry, attributeType);\n      if (attributeId !== -1) {\n        const dracoAttribute = decoder.GetAttribute(dracoGeometry, attributeId);\n        const {typedArray} = this.getAttributeTypedArray(\n          decoder,\n          dracoGeometry,\n          dracoAttribute,\n          attributeName\n        );\n        attributes[DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[attributeName]] = {\n          value: typedArray,\n          size: typedArray.length / numPoints\n        };\n      }\n      // }\n    }\n\n    // // Add attributes of user specified unique id. E.g. GLTF models.\n    // for (const attributeName in attributeUniqueIdMap) {\n    //   const attributeType = attributeTypeMap[attributeName] || Float32Array;\n    //   const attributeId = attributeUniqueIdMap[attributeName];\n    //   const attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeId);\n    //   this.getAttributeTypedArray(decoder, dracoGeometry, attribute,attributeName,attributeType);\n    // }\n\n    return attributes;\n  }\n\n  // For meshes, we need indices to define the faces.\n  getMeshFaceIndices(decoder, dracoGeometry) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n\n    const numIndices = numFaces * 3;\n    const indices = new Uint32Array(numIndices);\n    const dracoArray = new this.draco.DracoInt32Array();\n    for (let i = 0; i < numFaces; ++i) {\n      decoder.GetFaceFromMesh(dracoGeometry, i, dracoArray);\n      const index = i * 3;\n      indices[index] = dracoArray.GetValue(0);\n      indices[index + 1] = dracoArray.GetValue(1);\n      indices[index + 2] = dracoArray.GetValue(2);\n    }\n\n    this.draco.destroy(dracoArray);\n    return indices;\n  }\n\n  // For meshes, we need indices to define the faces.\n  getMeshStripIndices(decoder, dracoGeometry) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    /* const numStrips = */ decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n    const indices = new Uint32Array(dracoArray.size());\n    for (let i = 0; i < dracoArray.size(); ++i) {\n      indices[i] = dracoArray.GetValue(i);\n    }\n    this.draco.destroy(dracoArray);\n    return indices;\n  }\n\n  getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName) {\n    if (dracoAttribute.ptr === 0) {\n      const message = `DRACO decode bad attribute ${attributeName}`;\n      // console.error(message);\n      throw new Error(message);\n    }\n\n    const attributeType = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];\n    const numComponents = dracoAttribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    let dracoArray;\n    let typedArray;\n\n    switch (attributeType) {\n      case Float32Array:\n        dracoArray = new this.draco.DracoFloat32Array();\n        decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Float32Array(numValues);\n        break;\n\n      case Int8Array:\n        dracoArray = new this.draco.DracoInt8Array();\n        decoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int8Array(numValues);\n        break;\n\n      case Int16Array:\n        dracoArray = new this.draco.DracoInt16Array();\n        decoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int16Array(numValues);\n        break;\n\n      case Int32Array:\n        dracoArray = new this.draco.DracoInt32Array();\n        decoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int32Array(numValues);\n        break;\n\n      case Uint8Array:\n        dracoArray = new this.draco.DracoUInt8Array();\n        decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint8Array(numValues);\n        break;\n\n      case Uint16Array:\n        dracoArray = new this.draco.DracoUInt16Array();\n        decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint16Array(numValues);\n        break;\n\n      case Uint32Array:\n        dracoArray = new this.draco.DracoUInt32Array();\n        decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint32Array(numValues);\n        break;\n\n      default:\n        const errorMsg = 'DRACO decoder: unexpected attribute type.';\n        // console.error(errorMsg);\n        throw new Error(errorMsg);\n    }\n\n    // Copy data from decoder.\n    for (let i = 0; i < numValues; i++) {\n      typedArray[i] = dracoArray.GetValue(i);\n    }\n\n    this.draco.destroy(dracoArray);\n\n    return {typedArray, components: numComponents};\n  }\n\n  // DEPRECATED\n\n  decode(arrayBuffer, options) {\n    return this.parseSync(arrayBuffer, options);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}