{"ast":null,"code":"import toDenseArray from './lib/to_dense_array';\nimport StringSet from './lib/string_set';\nimport render from './render';\nimport { interactions } from './constants';\nexport default function Store(ctx) {\n  this._features = {};\n  this._featureIds = new StringSet();\n  this._selectedFeatureIds = new StringSet();\n  this._selectedCoordinates = [];\n  this._changedFeatureIds = new StringSet();\n  this._deletedFeaturesToEmit = [];\n  this._emitSelectionChange = false;\n  this._mapInitialConfig = {};\n  this.ctx = ctx;\n  this.sources = {\n    hot: [],\n    cold: []\n  }; // Deduplicate requests to render and tie them to animation frames.\n\n  let renderRequest;\n\n  this.render = () => {\n    if (!renderRequest) {\n      renderRequest = requestAnimationFrame(() => {\n        renderRequest = null;\n        render.call(this);\n      });\n    }\n  };\n\n  this.isDirty = false;\n}\n/**\n * Delays all rendering until the returned function is invoked\n * @return {Function} renderBatch\n */\n\nStore.prototype.createRenderBatch = function () {\n  const holdRender = this.render;\n  let numRenders = 0;\n\n  this.render = function () {\n    numRenders++;\n  };\n\n  return () => {\n    this.render = holdRender;\n\n    if (numRenders > 0) {\n      this.render();\n    }\n  };\n};\n/**\n * Sets the store's state to dirty.\n * @return {Store} this\n */\n\n\nStore.prototype.setDirty = function () {\n  this.isDirty = true;\n  return this;\n};\n/**\n * Sets a feature's state to changed.\n * @param {string} featureId\n * @return {Store} this\n */\n\n\nStore.prototype.featureChanged = function (featureId) {\n  this._changedFeatureIds.add(featureId);\n\n  return this;\n};\n/**\n * Gets the ids of all features currently in changed state.\n * @return {Store} this\n */\n\n\nStore.prototype.getChangedIds = function () {\n  return this._changedFeatureIds.values();\n};\n/**\n * Sets all features to unchanged state.\n * @return {Store} this\n */\n\n\nStore.prototype.clearChangedIds = function () {\n  this._changedFeatureIds.clear();\n\n  return this;\n};\n/**\n * Gets the ids of all features in the store.\n * @return {Store} this\n */\n\n\nStore.prototype.getAllIds = function () {\n  return this._featureIds.values();\n};\n/**\n * Adds a feature to the store.\n * @param {Object} feature\n *\n * @return {Store} this\n */\n\n\nStore.prototype.add = function (feature) {\n  this.featureChanged(feature.id);\n  this._features[feature.id] = feature;\n\n  this._featureIds.add(feature.id);\n\n  return this;\n};\n/**\n * Deletes a feature or array of features from the store.\n * Cleans up after the deletion by deselecting the features.\n * If changes were made, sets the state to the dirty\n * and fires an event.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\n\n\nStore.prototype.delete = function (featureIds, options = {}) {\n  toDenseArray(featureIds).forEach(id => {\n    if (!this._featureIds.has(id)) return;\n\n    this._featureIds.delete(id);\n\n    this._selectedFeatureIds.delete(id);\n\n    if (!options.silent) {\n      if (this._deletedFeaturesToEmit.indexOf(this._features[id]) === -1) {\n        this._deletedFeaturesToEmit.push(this._features[id]);\n      }\n    }\n\n    delete this._features[id];\n    this.isDirty = true;\n  });\n  refreshSelectedCoordinates(this, options);\n  return this;\n};\n/**\n * Returns a feature in the store matching the specified value.\n * @return {Object | undefined} feature\n */\n\n\nStore.prototype.get = function (id) {\n  return this._features[id];\n};\n/**\n * Returns all features in the store.\n * @return {Array<Object>}\n */\n\n\nStore.prototype.getAll = function () {\n  return Object.keys(this._features).map(id => this._features[id]);\n};\n/**\n * Adds features to the current selection.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\n\n\nStore.prototype.select = function (featureIds, options = {}) {\n  toDenseArray(featureIds).forEach(id => {\n    if (this._selectedFeatureIds.has(id)) return;\n\n    this._selectedFeatureIds.add(id);\n\n    this._changedFeatureIds.add(id);\n\n    if (!options.silent) {\n      this._emitSelectionChange = true;\n    }\n  });\n  return this;\n};\n/**\n * Deletes features from the current selection.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\n\n\nStore.prototype.deselect = function (featureIds, options = {}) {\n  toDenseArray(featureIds).forEach(id => {\n    if (!this._selectedFeatureIds.has(id)) return;\n\n    this._selectedFeatureIds.delete(id);\n\n    this._changedFeatureIds.add(id);\n\n    if (!options.silent) {\n      this._emitSelectionChange = true;\n    }\n  });\n  refreshSelectedCoordinates(this, options);\n  return this;\n};\n/**\n * Clears the current selection.\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\n\n\nStore.prototype.clearSelected = function (options = {}) {\n  this.deselect(this._selectedFeatureIds.values(), {\n    silent: options.silent\n  });\n  return this;\n};\n/**\n * Sets the store's selection, clearing any prior values.\n * If no feature ids are passed, the store is just cleared.\n * @param {string | Array<string> | undefined} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\n\n\nStore.prototype.setSelected = function (featureIds, options = {}) {\n  featureIds = toDenseArray(featureIds); // Deselect any features not in the new selection\n\n  this.deselect(this._selectedFeatureIds.values().filter(id => featureIds.indexOf(id) === -1), {\n    silent: options.silent\n  }); // Select any features in the new selection that were not already selected\n\n  this.select(featureIds.filter(id => !this._selectedFeatureIds.has(id)), {\n    silent: options.silent\n  });\n  return this;\n};\n/**\n * Sets the store's coordinates selection, clearing any prior values.\n * @param {Array<Array<string>>} coordinates\n * @return {Store} this\n */\n\n\nStore.prototype.setSelectedCoordinates = function (coordinates) {\n  this._selectedCoordinates = coordinates;\n  this._emitSelectionChange = true;\n  return this;\n};\n/**\n * Clears the current coordinates selection.\n * @param {Object} [options]\n * @return {Store} this\n */\n\n\nStore.prototype.clearSelectedCoordinates = function () {\n  this._selectedCoordinates = [];\n  this._emitSelectionChange = true;\n  return this;\n};\n/**\n * Returns the ids of features in the current selection.\n * @return {Array<string>} Selected feature ids.\n */\n\n\nStore.prototype.getSelectedIds = function () {\n  return this._selectedFeatureIds.values();\n};\n/**\n * Returns features in the current selection.\n * @return {Array<Object>} Selected features.\n */\n\n\nStore.prototype.getSelected = function () {\n  return this._selectedFeatureIds.values().map(id => this.get(id));\n};\n/**\n * Returns selected coordinates in the currently selected feature.\n * @return {Array<Object>} Selected coordinates.\n */\n\n\nStore.prototype.getSelectedCoordinates = function () {\n  const selected = this._selectedCoordinates.map(coordinate => {\n    const feature = this.get(coordinate.feature_id);\n    return {\n      coordinates: feature.getCoordinate(coordinate.coord_path)\n    };\n  });\n\n  return selected;\n};\n/**\n * Indicates whether a feature is selected.\n * @param {string} featureId\n * @return {boolean} `true` if the feature is selected, `false` if not.\n */\n\n\nStore.prototype.isSelected = function (featureId) {\n  return this._selectedFeatureIds.has(featureId);\n};\n/**\n * Sets a property on the given feature\n * @param {string} featureId\n * @param {string} property property\n * @param {string} property value\n*/\n\n\nStore.prototype.setFeatureProperty = function (featureId, property, value) {\n  this.get(featureId).setProperty(property, value);\n  this.featureChanged(featureId);\n};\n\nfunction refreshSelectedCoordinates(store, options) {\n  const newSelectedCoordinates = store._selectedCoordinates.filter(point => store._selectedFeatureIds.has(point.feature_id));\n\n  if (store._selectedCoordinates.length !== newSelectedCoordinates.length && !options.silent) {\n    store._emitSelectionChange = true;\n  }\n\n  store._selectedCoordinates = newSelectedCoordinates;\n}\n/**\n * Stores the initial config for a map, so that we can set it again after we're done.\n*/\n\n\nStore.prototype.storeMapConfig = function () {\n  interactions.forEach(interaction => {\n    const interactionSet = this.ctx.map[interaction];\n\n    if (interactionSet) {\n      this._mapInitialConfig[interaction] = this.ctx.map[interaction].isEnabled();\n    }\n  });\n};\n/**\n * Restores the initial config for a map, ensuring all is well.\n*/\n\n\nStore.prototype.restoreMapConfig = function () {\n  Object.keys(this._mapInitialConfig).forEach(key => {\n    const value = this._mapInitialConfig[key];\n\n    if (value) {\n      this.ctx.map[key].enable();\n    } else {\n      this.ctx.map[key].disable();\n    }\n  });\n};\n/**\n * Returns the initial state of an interaction setting.\n * @param {string} interaction\n * @return {boolean} `true` if the interaction is enabled, `false` if not.\n * Defaults to `true`. (Todo: include defaults.)\n*/\n\n\nStore.prototype.getInitialConfigValue = function (interaction) {\n  if (this._mapInitialConfig[interaction] !== undefined) {\n    return this._mapInitialConfig[interaction];\n  } else {\n    // This needs to be set to whatever the default is for that interaction\n    // It seems to be true for all cases currently, so let's send back `true`.\n    return true;\n  }\n};","map":{"version":3,"sources":["/Users/garrettmillar/pandemic_dashboard/node_modules/@mapbox/mapbox-gl-draw/src/store.js"],"names":["toDenseArray","StringSet","render","interactions","Store","ctx","_features","_featureIds","_selectedFeatureIds","_selectedCoordinates","_changedFeatureIds","_deletedFeaturesToEmit","_emitSelectionChange","_mapInitialConfig","sources","hot","cold","renderRequest","requestAnimationFrame","call","isDirty","prototype","createRenderBatch","holdRender","numRenders","setDirty","featureChanged","featureId","add","getChangedIds","values","clearChangedIds","clear","getAllIds","feature","id","delete","featureIds","options","forEach","has","silent","indexOf","push","refreshSelectedCoordinates","get","getAll","Object","keys","map","select","deselect","clearSelected","setSelected","filter","setSelectedCoordinates","coordinates","clearSelectedCoordinates","getSelectedIds","getSelected","getSelectedCoordinates","selected","coordinate","feature_id","getCoordinate","coord_path","isSelected","setFeatureProperty","property","value","setProperty","store","newSelectedCoordinates","point","length","storeMapConfig","interaction","interactionSet","isEnabled","restoreMapConfig","key","enable","disable","getInitialConfigValue","undefined"],"mappings":"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","sourcesContent":["import toDenseArray from './lib/to_dense_array';\nimport StringSet from './lib/string_set';\nimport render from './render';\nimport {interactions} from './constants';\n\nexport default function Store(ctx) {\n  this._features = {};\n  this._featureIds = new StringSet();\n  this._selectedFeatureIds = new StringSet();\n  this._selectedCoordinates = [];\n  this._changedFeatureIds = new StringSet();\n  this._deletedFeaturesToEmit = [];\n  this._emitSelectionChange = false;\n  this._mapInitialConfig = {};\n  this.ctx = ctx;\n  this.sources = {\n    hot: [],\n    cold: []\n  };\n\n  // Deduplicate requests to render and tie them to animation frames.\n  let renderRequest;\n  this.render = () => {\n    if (!renderRequest) {\n      renderRequest = requestAnimationFrame(() => {\n        renderRequest = null;\n        render.call(this);\n      });\n    }\n  };\n  this.isDirty = false;\n}\n\n\n/**\n * Delays all rendering until the returned function is invoked\n * @return {Function} renderBatch\n */\nStore.prototype.createRenderBatch = function() {\n  const holdRender = this.render;\n  let numRenders = 0;\n  this.render = function() {\n    numRenders++;\n  };\n\n  return () => {\n    this.render = holdRender;\n    if (numRenders > 0) {\n      this.render();\n    }\n  };\n};\n\n/**\n * Sets the store's state to dirty.\n * @return {Store} this\n */\nStore.prototype.setDirty = function() {\n  this.isDirty = true;\n  return this;\n};\n\n/**\n * Sets a feature's state to changed.\n * @param {string} featureId\n * @return {Store} this\n */\nStore.prototype.featureChanged = function(featureId) {\n  this._changedFeatureIds.add(featureId);\n  return this;\n};\n\n/**\n * Gets the ids of all features currently in changed state.\n * @return {Store} this\n */\nStore.prototype.getChangedIds = function() {\n  return this._changedFeatureIds.values();\n};\n\n/**\n * Sets all features to unchanged state.\n * @return {Store} this\n */\nStore.prototype.clearChangedIds = function() {\n  this._changedFeatureIds.clear();\n  return this;\n};\n\n/**\n * Gets the ids of all features in the store.\n * @return {Store} this\n */\nStore.prototype.getAllIds = function() {\n  return this._featureIds.values();\n};\n\n/**\n * Adds a feature to the store.\n * @param {Object} feature\n *\n * @return {Store} this\n */\nStore.prototype.add = function(feature) {\n  this.featureChanged(feature.id);\n  this._features[feature.id] = feature;\n  this._featureIds.add(feature.id);\n  return this;\n};\n\n/**\n * Deletes a feature or array of features from the store.\n * Cleans up after the deletion by deselecting the features.\n * If changes were made, sets the state to the dirty\n * and fires an event.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.delete = function(featureIds, options = {}) {\n  toDenseArray(featureIds).forEach((id) => {\n    if (!this._featureIds.has(id)) return;\n    this._featureIds.delete(id);\n    this._selectedFeatureIds.delete(id);\n    if (!options.silent) {\n      if (this._deletedFeaturesToEmit.indexOf(this._features[id]) === -1) {\n        this._deletedFeaturesToEmit.push(this._features[id]);\n      }\n    }\n    delete this._features[id];\n    this.isDirty = true;\n  });\n  refreshSelectedCoordinates(this, options);\n  return this;\n};\n\n/**\n * Returns a feature in the store matching the specified value.\n * @return {Object | undefined} feature\n */\nStore.prototype.get = function(id) {\n  return this._features[id];\n};\n\n/**\n * Returns all features in the store.\n * @return {Array<Object>}\n */\nStore.prototype.getAll = function() {\n  return Object.keys(this._features).map(id => this._features[id]);\n};\n\n/**\n * Adds features to the current selection.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.select = function(featureIds, options = {}) {\n  toDenseArray(featureIds).forEach((id) => {\n    if (this._selectedFeatureIds.has(id)) return;\n    this._selectedFeatureIds.add(id);\n    this._changedFeatureIds.add(id);\n    if (!options.silent) {\n      this._emitSelectionChange = true;\n    }\n  });\n  return this;\n};\n\n/**\n * Deletes features from the current selection.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.deselect = function(featureIds, options = {}) {\n  toDenseArray(featureIds).forEach((id) => {\n    if (!this._selectedFeatureIds.has(id)) return;\n    this._selectedFeatureIds.delete(id);\n    this._changedFeatureIds.add(id);\n    if (!options.silent) {\n      this._emitSelectionChange = true;\n    }\n  });\n  refreshSelectedCoordinates(this, options);\n  return this;\n};\n\n/**\n * Clears the current selection.\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.clearSelected = function(options = {}) {\n  this.deselect(this._selectedFeatureIds.values(), { silent: options.silent });\n  return this;\n};\n\n/**\n * Sets the store's selection, clearing any prior values.\n * If no feature ids are passed, the store is just cleared.\n * @param {string | Array<string> | undefined} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.setSelected = function(featureIds, options = {}) {\n  featureIds = toDenseArray(featureIds);\n\n  // Deselect any features not in the new selection\n  this.deselect(this._selectedFeatureIds.values().filter(id => featureIds.indexOf(id) === -1), { silent: options.silent });\n\n  // Select any features in the new selection that were not already selected\n  this.select(featureIds.filter(id => !this._selectedFeatureIds.has(id)), { silent: options.silent });\n\n  return this;\n};\n\n/**\n * Sets the store's coordinates selection, clearing any prior values.\n * @param {Array<Array<string>>} coordinates\n * @return {Store} this\n */\nStore.prototype.setSelectedCoordinates = function(coordinates) {\n  this._selectedCoordinates = coordinates;\n  this._emitSelectionChange = true;\n  return this;\n};\n\n/**\n * Clears the current coordinates selection.\n * @param {Object} [options]\n * @return {Store} this\n */\nStore.prototype.clearSelectedCoordinates = function() {\n  this._selectedCoordinates = [];\n  this._emitSelectionChange = true;\n  return this;\n};\n\n/**\n * Returns the ids of features in the current selection.\n * @return {Array<string>} Selected feature ids.\n */\nStore.prototype.getSelectedIds = function() {\n  return this._selectedFeatureIds.values();\n};\n\n/**\n * Returns features in the current selection.\n * @return {Array<Object>} Selected features.\n */\nStore.prototype.getSelected = function() {\n  return this._selectedFeatureIds.values().map(id => this.get(id));\n};\n\n/**\n * Returns selected coordinates in the currently selected feature.\n * @return {Array<Object>} Selected coordinates.\n */\nStore.prototype.getSelectedCoordinates = function() {\n  const selected = this._selectedCoordinates.map((coordinate) => {\n    const feature = this.get(coordinate.feature_id);\n    return {\n      coordinates: feature.getCoordinate(coordinate.coord_path)\n    };\n  });\n  return selected;\n};\n\n/**\n * Indicates whether a feature is selected.\n * @param {string} featureId\n * @return {boolean} `true` if the feature is selected, `false` if not.\n */\nStore.prototype.isSelected = function(featureId) {\n  return this._selectedFeatureIds.has(featureId);\n};\n\n/**\n * Sets a property on the given feature\n * @param {string} featureId\n * @param {string} property property\n * @param {string} property value\n*/\nStore.prototype.setFeatureProperty = function(featureId, property, value) {\n  this.get(featureId).setProperty(property, value);\n  this.featureChanged(featureId);\n};\n\nfunction refreshSelectedCoordinates(store, options) {\n  const newSelectedCoordinates = store._selectedCoordinates.filter(point => store._selectedFeatureIds.has(point.feature_id));\n  if (store._selectedCoordinates.length !== newSelectedCoordinates.length && !options.silent) {\n    store._emitSelectionChange = true;\n  }\n  store._selectedCoordinates = newSelectedCoordinates;\n}\n\n/**\n * Stores the initial config for a map, so that we can set it again after we're done.\n*/\nStore.prototype.storeMapConfig = function() {\n  interactions.forEach((interaction) => {\n    const interactionSet = this.ctx.map[interaction];\n    if (interactionSet) {\n      this._mapInitialConfig[interaction] = this.ctx.map[interaction].isEnabled();\n    }\n  });\n};\n\n/**\n * Restores the initial config for a map, ensuring all is well.\n*/\nStore.prototype.restoreMapConfig = function() {\n  Object.keys(this._mapInitialConfig).forEach((key) => {\n    const value = this._mapInitialConfig[key];\n    if (value) {\n      this.ctx.map[key].enable();\n    } else {\n      this.ctx.map[key].disable();\n    }\n  });\n};\n\n/**\n * Returns the initial state of an interaction setting.\n * @param {string} interaction\n * @return {boolean} `true` if the interaction is enabled, `false` if not.\n * Defaults to `true`. (Todo: include defaults.)\n*/\nStore.prototype.getInitialConfigValue = function(interaction) {\n  if (this._mapInitialConfig[interaction] !== undefined) {\n    return this._mapInitialConfig[interaction];\n  } else {\n    // This needs to be set to whatever the default is for that interaction\n    // It seems to be true for all cases currently, so let's send back `true`.\n    return true;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}