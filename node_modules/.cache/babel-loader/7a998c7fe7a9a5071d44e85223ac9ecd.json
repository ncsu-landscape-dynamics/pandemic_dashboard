{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION } from '../utils/aggregation-operation-utils';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport { pointToDensityGridDataCPU } from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nvar defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {\n    type: 'accessor',\n    value: function value(x) {\n      return 1;\n    }\n  },\n  colorAggregation: 'SUM',\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {\n    type: 'accessor',\n    value: function value(x) {\n      return 1;\n    }\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  extruded: false,\n  material: true\n};\nvar DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n};\nvar POSITION_ATTRIBUTE_NAME = 'positions';\n\nvar GPUGridLayer = function (_GridAggregationLayer) {\n  _inherits(GPUGridLayer, _GridAggregationLayer);\n\n  function GPUGridLayer() {\n    _classCallCheck(this, GPUGridLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GPUGridLayer).apply(this, arguments));\n  }\n\n  _createClass(GPUGridLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _attributeManager$add;\n\n      var gl = this.context.gl;\n      var isSupported = GPUGridAggregator.isSupported(gl);\n\n      if (!isSupported) {\n        log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n      }\n\n      _get(_getPrototypeOf(GPUGridLayer.prototype), \"initializeState\", this).call(this, {\n        dimensions: DIMENSIONS\n      });\n\n      this.setState({\n        gpuAggregation: true,\n        projectPoints: false,\n        isSupported: isSupported,\n        weights: {\n          color: {\n            needMin: true,\n            needMax: true,\n            combineMaxMin: true,\n            maxMinBuffer: new Buffer(gl, {\n              byteLength: 4 * 4,\n              accessor: {\n                size: 4,\n                type: 5126,\n                divisor: 1\n              }\n            })\n          },\n          elevation: {\n            needMin: true,\n            needMax: true,\n            combineMaxMin: true,\n            maxMinBuffer: new Buffer(gl, {\n              byteLength: 4 * 4,\n              accessor: {\n                size: 4,\n                type: 5126,\n                divisor: 1\n              }\n            })\n          }\n        },\n        positionAttributeName: 'positions'\n      });\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add((_attributeManager$add = {}, _defineProperty(_attributeManager$add, POSITION_ATTRIBUTE_NAME, {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      }), _defineProperty(_attributeManager$add, \"color\", {\n        size: 3,\n        accessor: 'getColorWeight'\n      }), _defineProperty(_attributeManager$add, \"elevation\", {\n        size: 3,\n        accessor: 'getElevationWeight'\n      }), _attributeManager$add));\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      if (this.state.isSupported === false) {\n        return;\n      }\n\n      _get(_getPrototypeOf(GPUGridLayer.prototype), \"updateState\", this).call(this, opts);\n\n      var aggregationDirty = this.state.aggregationDirty;\n\n      if (aggregationDirty) {\n        this.setState({\n          gridHash: null\n        });\n      }\n    }\n  }, {\n    key: \"getHashKeyForIndex\",\n    value: function getHashKeyForIndex(index) {\n      var _this$state = this.state,\n          numRow = _this$state.numRow,\n          numCol = _this$state.numCol,\n          boundingBox = _this$state.boundingBox,\n          gridOffset = _this$state.gridOffset;\n      var gridSize = [numCol, numRow];\n      var gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n      var cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n      var yIndex = Math.floor(index / gridSize[0]);\n      var xIndex = index - yIndex * gridSize[0];\n      var latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);\n      var lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);\n      return \"\".concat(latIdx, \"-\").concat(lonIdx);\n    }\n  }, {\n    key: \"getPositionForIndex\",\n    value: function getPositionForIndex(index) {\n      var _this$state2 = this.state,\n          numRow = _this$state2.numRow,\n          numCol = _this$state2.numCol,\n          boundingBox = _this$state2.boundingBox,\n          gridOffset = _this$state2.gridOffset;\n      var gridSize = [numCol, numRow];\n      var gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n      var cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n      var yIndex = Math.floor(index / gridSize[0]);\n      var xIndex = index - yIndex * gridSize[0];\n      var yPos = yIndex * cellSize[1] + gridOrigin[1];\n      var xPos = xIndex * cellSize[0] + gridOrigin[0];\n      return [xPos, yPos];\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref) {\n      var info = _ref.info,\n          mode = _ref.mode;\n      var index = info.index;\n      var object = null;\n\n      if (index >= 0) {\n        var gpuGridAggregator = this.state.gpuGridAggregator;\n        var position = this.getPositionForIndex(index);\n        var colorInfo = GPUGridAggregator.getAggregationData(Object.assign({\n          pixelIndex: index\n        }, gpuGridAggregator.getData('color')));\n        var elevationInfo = GPUGridAggregator.getAggregationData(Object.assign({\n          pixelIndex: index\n        }, gpuGridAggregator.getData('elevation')));\n        object = {\n          colorValue: colorInfo.cellWeight,\n          elevationValue: elevationInfo.cellWeight,\n          count: colorInfo.cellCount || elevationInfo.cellCount,\n          position: position,\n          totalCount: colorInfo.totalCount || elevationInfo.totalCount\n        };\n\n        if (mode !== 'hover') {\n          var props = this.props;\n          var gridHash = this.state.gridHash;\n\n          if (!gridHash) {\n            var _this$state3 = this.state,\n                gridOffset = _this$state3.gridOffset,\n                translation = _this$state3.translation,\n                boundingBox = _this$state3.boundingBox;\n            var viewport = this.context.viewport;\n            var attributes = this.getAttributes();\n            var cpuAggregation = pointToDensityGridDataCPU(props, {\n              gridOffset: gridOffset,\n              attributes: attributes,\n              viewport: viewport,\n              translation: translation,\n              boundingBox: boundingBox\n            });\n            gridHash = cpuAggregation.gridHash;\n            this.setState({\n              gridHash: gridHash\n            });\n          }\n\n          var key = this.getHashKeyForIndex(index);\n          var cpuAggregationData = gridHash[key];\n          Object.assign(object, cpuAggregationData);\n        }\n      }\n\n      return Object.assign(info, {\n        picked: Boolean(object),\n        object: object\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      if (!this.state.isSupported) {\n        return null;\n      }\n\n      var _this$props = this.props,\n          elevationScale = _this$props.elevationScale,\n          extruded = _this$props.extruded,\n          cellSizeMeters = _this$props.cellSize,\n          coverage = _this$props.coverage,\n          material = _this$props.material,\n          elevationRange = _this$props.elevationRange,\n          colorDomain = _this$props.colorDomain,\n          elevationDomain = _this$props.elevationDomain;\n      var _this$state4 = this.state,\n          weights = _this$state4.weights,\n          numRow = _this$state4.numRow,\n          numCol = _this$state4.numCol,\n          gridOrigin = _this$state4.gridOrigin,\n          gridOffset = _this$state4.gridOffset;\n      var color = weights.color,\n          elevation = weights.elevation;\n      var colorRange = colorRangeToFlatArray(this.props.colorRange);\n      var SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n      return new SubLayerClass({\n        gridSize: [numCol, numRow],\n        gridOrigin: gridOrigin,\n        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n        colorRange: colorRange,\n        elevationRange: elevationRange,\n        colorDomain: colorDomain,\n        elevationDomain: elevationDomain,\n        cellSize: cellSizeMeters,\n        coverage: coverage,\n        material: material,\n        elevationScale: elevationScale,\n        extruded: extruded\n      }, this.getSubLayerProps({\n        id: 'gpu-grid-cell'\n      }), {\n        data: {\n          attributes: {\n            colors: color.aggregationBuffer,\n            elevations: elevation.aggregationBuffer\n          }\n        },\n        colorMaxMinBuffer: color.maxMinBuffer,\n        elevationMaxMinBuffer: elevation.maxMinBuffer,\n        numInstances: numCol * numRow\n      });\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      var _this$state$weights = this.state.weights,\n          color = _this$state$weights.color,\n          elevation = _this$state$weights.elevation;\n      [color, elevation].forEach(function (weight) {\n        var aggregationBuffer = weight.aggregationBuffer,\n            maxMinBuffer = weight.maxMinBuffer;\n        maxMinBuffer[\"delete\"]();\n\n        if (aggregationBuffer) {\n          aggregationBuffer[\"delete\"]();\n        }\n      });\n\n      _get(_getPrototypeOf(GPUGridLayer.prototype), \"finalizeState\", this).call(this);\n    }\n  }, {\n    key: \"updateAggregationState\",\n    value: function updateAggregationState(opts) {\n      var props = opts.props,\n          oldProps = opts.oldProps;\n      var cellSize = props.cellSize,\n          coordinateSystem = props.coordinateSystem;\n      var viewport = this.context.viewport;\n      var cellSizeChanged = oldProps.cellSize !== cellSize;\n      var dimensions = this.state.dimensions;\n      var positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n      var attributesChanged = positionsChanged || this.isAttributeChanged();\n      var boundingBox = this.state.boundingBox;\n\n      if (positionsChanged) {\n        boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n        this.setState({\n          boundingBox: boundingBox\n        });\n      }\n\n      if (positionsChanged || cellSizeChanged) {\n        var _getGridParams = getGridParams(boundingBox, cellSize, viewport, coordinateSystem),\n            gridOffset = _getGridParams.gridOffset,\n            translation = _getGridParams.translation,\n            width = _getGridParams.width,\n            height = _getGridParams.height,\n            numCol = _getGridParams.numCol,\n            numRow = _getGridParams.numRow;\n\n        this.allocateResources(numRow, numCol);\n        this.setState({\n          gridOffset: gridOffset,\n          translation: translation,\n          gridOrigin: [-1 * translation[0], -1 * translation[1]],\n          width: width,\n          height: height,\n          numCol: numCol,\n          numRow: numRow\n        });\n      }\n\n      var aggregationDataDirty = attributesChanged || this.isAggregationDirty(opts, {\n        dimension: dimensions.data,\n        compareAll: true\n      });\n\n      if (aggregationDataDirty) {\n        this._updateAccessors(opts);\n      }\n\n      this.setState({\n        aggregationDataDirty: aggregationDataDirty\n      });\n    }\n  }, {\n    key: \"_updateAccessors\",\n    value: function _updateAccessors(opts) {\n      var _opts$props = opts.props,\n          colorAggregation = _opts$props.colorAggregation,\n          elevationAggregation = _opts$props.elevationAggregation;\n      var _this$state$weights2 = this.state.weights,\n          color = _this$state$weights2.color,\n          elevation = _this$state$weights2.elevation;\n      color.operation = AGGREGATION_OPERATION[colorAggregation];\n      elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n    }\n  }]);\n\n  return GPUGridLayer;\n}(GridAggregationLayer);\n\nexport { GPUGridLayer as default };\nGPUGridLayer.layerName = 'GPUGridLayer';\nGPUGridLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/gpu-grid-layer/gpu-grid-layer.js"],"names":["defaultProps","colorDomain","colorRange","getColorWeight","type","value","colorAggregation","elevationDomain","elevationRange","getElevationWeight","elevationAggregation","elevationScale","min","cellSize","max","coverage","getPosition","x","extruded","material","DIMENSIONS","data","props","POSITION_ATTRIBUTE_NAME","GPUGridLayer","GridAggregationLayer","gl","isSupported","GPUGridAggregator","log","dimensions","gpuAggregation","projectPoints","weights","color","needMin","needMax","combineMaxMin","maxMinBuffer","byteLength","accessor","size","divisor","elevation","positionAttributeName","attributeManager","fp64","opts","aggregationDirty","gridHash","index","numRow","numCol","boundingBox","gridOffset","gridSize","gridOrigin","yIndex","Math","xIndex","latIdx","lonIdx","yPos","xPos","info","mode","object","gpuGridAggregator","position","colorInfo","pixelIndex","elevationInfo","colorValue","elevationValue","count","totalCount","translation","viewport","attributes","cpuAggregation","pointToDensityGridDataCPU","key","cpuAggregationData","Object","picked","Boolean","cellSizeMeters","colorRangeToFlatArray","SubLayerClass","id","colors","elevations","aggregationBuffer","colorMaxMinBuffer","elevationMaxMinBuffer","numInstances","weight","oldProps","coordinateSystem","cellSizeChanged","positionsChanged","attributesChanged","getBoundingBox","width","height","getGridParams","aggregationDataDirty","dimension","compareAll","AGGREGATION_OPERATION"],"mappings":";;;;;;;AAoBA,SAAA,MAAA,QAAA,eAAA;AAEA,SAAA,GAAA,QAAA,eAAA;AAEA,OAAA,iBAAA,MAAA,mDAAA;AACA,SAAA,qBAAA,QAAA,sCAAA;AACA,SAAA,iBAAA,EAAA,qBAAA,QAAA,sBAAA;AACA,OAAA,gBAAA,MAAA,uBAAA;AACA,SAAA,yBAAA,QAAA,qCAAA;AACA,OAAA,oBAAA,MAAA,2BAAA;AACA,SAAA,cAAA,EAAA,aAAA,QAAA,iCAAA;AAEA,IAAMA,YAAY,GAAG;AAEnBC,EAAAA,WAAW,EAFQ,IAAA;AAGnBC,EAAAA,UAAU,EAHS,iBAAA;AAInBC,EAAAA,cAAc,EAAE;AAACC,IAAAA,IAAI,EAAL,UAAA;AAAmBC,IAAAA,KAAK,EAAE,SAAA,KAAA,CAAA,CAAA,EAAC;AAAA,aAAA,CAAA;AAAA;AAA3B,GAJG;AAKnBC,EAAAA,gBAAgB,EALG,KAAA;AAQnBC,EAAAA,eAAe,EARI,IAAA;AASnBC,EAAAA,cAAc,EAAE,CAAA,CAAA,EATG,IASH,CATG;AAUnBC,EAAAA,kBAAkB,EAAE;AAACL,IAAAA,IAAI,EAAL,UAAA;AAAmBC,IAAAA,KAAK,EAAE,SAAA,KAAA,CAAA,CAAA,EAAC;AAAA,aAAA,CAAA;AAAA;AAA3B,GAVD;AAWnBK,EAAAA,oBAAoB,EAXD,KAAA;AAYnBC,EAAAA,cAAc,EAAE;AAACP,IAAAA,IAAI,EAAL,QAAA;AAAiBQ,IAAAA,GAAG,EAApB,CAAA;AAAyBP,IAAAA,KAAK,EAAE;AAAhC,GAZG;AAenBQ,EAAAA,QAAQ,EAAE;AAACT,IAAAA,IAAI,EAAL,QAAA;AAAiBQ,IAAAA,GAAG,EAApB,CAAA;AAAyBE,IAAAA,GAAG,EAA5B,IAAA;AAAoCT,IAAAA,KAAK,EAAE;AAA3C,GAfS;AAgBnBU,EAAAA,QAAQ,EAAE;AAACX,IAAAA,IAAI,EAAL,QAAA;AAAiBQ,IAAAA,GAAG,EAApB,CAAA;AAAyBE,IAAAA,GAAG,EAA5B,CAAA;AAAiCT,IAAAA,KAAK,EAAE;AAAxC,GAhBS;AAiBnBW,EAAAA,WAAW,EAAE;AAACZ,IAAAA,IAAI,EAAL,UAAA;AAAmBC,IAAAA,KAAK,EAAE,SAAA,KAAA,CAAA,CAAA,EAAC;AAAA,aAAIY,CAAC,CAAL,QAAA;AAAA;AAA3B,GAjBM;AAkBnBC,EAAAA,QAAQ,EAlBW,KAAA;AAqBnBC,EAAAA,QAAQ,EAAE;AArBS,CAArB;AA2BA,IAAMC,UAAU,GAAG;AACjBC,EAAAA,IAAI,EAAE;AACJC,IAAAA,KAAK,EAAE,CAAA,UAAA,EAAA,kBAAA,EAAA,sBAAA;AADH;AADW,CAAnB;AAMA,IAAMC,uBAAuB,GAA7B,WAAA;;IAEqBC,Y;;;;;;;;;;;sCACD;AAAA,UAAA,qBAAA;;AAAA,UACTE,EADS,GACH,KADG,OACH,CADG,EAAA;AAEhB,UAAMC,WAAW,GAAGC,iBAAiB,CAAjBA,WAAAA,CAApB,EAAoBA,CAApB;;AACA,UAAI,CAAJ,WAAA,EAAkB;AAChBC,QAAAA,GAAG,CAAHA,KAAAA,CAAAA,sEAAAA;AACD;;AACD,MAAA,IAAA,CAAA,eAAA,CAAA,YAAA,CAAA,SAAA,CAAA,EAAA,iBAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAsB;AACpBC,QAAAA,UAAU,EAAEV;AADQ,OAAtB;;AAGA,WAAA,QAAA,CAAc;AACZW,QAAAA,cAAc,EADF,IAAA;AAEZC,QAAAA,aAAa,EAFD,KAAA;AAGZL,QAAAA,WAAW,EAHC,WAAA;AAIZM,QAAAA,OAAO,EAAE;AACPC,UAAAA,KAAK,EAAE;AACLC,YAAAA,OAAO,EADF,IAAA;AAELC,YAAAA,OAAO,EAFF,IAAA;AAGLC,YAAAA,aAAa,EAHR,IAAA;AAILC,YAAAA,YAAY,EAAE,IAAA,MAAA,CAAA,EAAA,EAAe;AAC3BC,cAAAA,UAAU,EAAE,IADe,CAAA;AAE3BC,cAAAA,QAAQ,EAAE;AAACC,gBAAAA,IAAI,EAAL,CAAA;AAAUrC,gBAAAA,IAAI,EAAd,IAAA;AAA0BsC,gBAAAA,OAAO,EAAE;AAAnC;AAFiB,aAAf;AAJT,WADA;AAUPC,UAAAA,SAAS,EAAE;AACTR,YAAAA,OAAO,EADE,IAAA;AAETC,YAAAA,OAAO,EAFE,IAAA;AAGTC,YAAAA,aAAa,EAHJ,IAAA;AAITC,YAAAA,YAAY,EAAE,IAAA,MAAA,CAAA,EAAA,EAAe;AAC3BC,cAAAA,UAAU,EAAE,IADe,CAAA;AAE3BC,cAAAA,QAAQ,EAAE;AAACC,gBAAAA,IAAI,EAAL,CAAA;AAAUrC,gBAAAA,IAAI,EAAd,IAAA;AAA0BsC,gBAAAA,OAAO,EAAE;AAAnC;AAFiB,aAAf;AAJL;AAVJ,SAJG;AAwBZE,QAAAA,qBAAqB,EAAE;AAxBX,OAAd;AA0BA,UAAMC,gBAAgB,GAAG,KAAzB,mBAAyB,EAAzB;AACAA,MAAAA,gBAAgB,CAAhBA,GAAAA,EAAAA,qBAAAA,GAAAA,EAAAA,EAAAA,eAAAA,CAAAA,qBAAAA,EAAAA,uBAAAA,EAC6B;AACzBJ,QAAAA,IAAI,EADqB,CAAA;AAEzBD,QAAAA,QAAQ,EAFiB,aAAA;AAGzBpC,QAAAA,IAAI,EAHqB,IAAA;AAIzB0C,QAAAA,IAAI,EAAE,KAAA,iBAAA;AAJmB,OAD7BD,CAAAA,EAAAA,eAAAA,CAAAA,qBAAAA,EAAAA,OAAAA,EAOS;AAACJ,QAAAA,IAAI,EAAL,CAAA;AAAUD,QAAAA,QAAQ,EAAE;AAApB,OAPTK,CAAAA,EAAAA,eAAAA,CAAAA,qBAAAA,EAAAA,WAAAA,EAQa;AAACJ,QAAAA,IAAI,EAAL,CAAA;AAAUD,QAAAA,QAAQ,EAAE;AAApB,OARbK,CAAAA,EAAAA,qBAAAA;AAUD;;;gCAEWE,I,EAAM;AAChB,UAAI,KAAA,KAAA,CAAA,WAAA,KAAJ,KAAA,EAAsC;AAEpC;AACD;;AACD,MAAA,IAAA,CAAA,eAAA,CAAA,YAAA,CAAA,SAAA,CAAA,EAAA,aAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,IAAA;;AALgB,UAMTC,gBANS,GAMW,KANX,KAMW,CANX,gBAAA;;AAOhB,UAAA,gBAAA,EAAsB;AAEpB,aAAA,QAAA,CAAc;AACZC,UAAAA,QAAQ,EAAE;AADE,SAAd;AAGD;AACF;;;uCAEkBC,K,EAAO;AAAA,UAAA,WAAA,GAC0B,KAD1B,KAAA;AAAA,UACjBC,MADiB,GAAA,WAAA,CAAA,MAAA;AAAA,UACTC,MADS,GAAA,WAAA,CAAA,MAAA;AAAA,UACDC,WADC,GAAA,WAAA,CAAA,WAAA;AAAA,UACYC,UADZ,GAAA,WAAA,CAAA,UAAA;AAExB,UAAMC,QAAQ,GAAG,CAAA,MAAA,EAAjB,MAAiB,CAAjB;AACA,UAAMC,UAAU,GAAG,CAACH,WAAW,CAAZ,IAAA,EAAmBA,WAAW,CAAjD,IAAmB,CAAnB;AACA,UAAMxC,QAAQ,GAAG,CAACyC,UAAU,CAAX,OAAA,EAAqBA,UAAU,CAAhD,OAAiB,CAAjB;AAEA,UAAMG,MAAM,GAAGC,IAAI,CAAJA,KAAAA,CAAWR,KAAK,GAAGK,QAAQ,CAA1C,CAA0C,CAA3BG,CAAf;AACA,UAAMC,MAAM,GAAGT,KAAK,GAAGO,MAAM,GAAGF,QAAQ,CAAxC,CAAwC,CAAxC;AAEA,UAAMK,MAAM,GAAGF,IAAI,CAAJA,KAAAA,CACb,CAACD,MAAM,GAAG5C,QAAQ,CAAjB4C,CAAiB,CAAjBA,GAAuBD,UAAU,CAAjCC,CAAiC,CAAjCA,GAAAA,EAAAA,GAA4C5C,QAAQ,CAARA,CAAQ,CAARA,GAA7C,CAAA,IAAgEA,QAAQ,CAD1E,CAC0E,CAD3D6C,CAAf;AAGA,UAAMG,MAAM,GAAGH,IAAI,CAAJA,KAAAA,CACb,CAACC,MAAM,GAAG9C,QAAQ,CAAjB8C,CAAiB,CAAjBA,GAAuBH,UAAU,CAAjCG,CAAiC,CAAjCA,GAAAA,GAAAA,GAA6C9C,QAAQ,CAARA,CAAQ,CAARA,GAA9C,CAAA,IAAiEA,QAAQ,CAD3E,CAC2E,CAD5D6C,CAAf;AAGA,aAAA,GAAA,MAAA,CAAA,MAAA,EAAA,GAAA,EAAA,MAAA,CAAA,MAAA,CAAA;AACD;;;wCAEmBR,K,EAAO;AAAA,UAAA,YAAA,GACyB,KADzB,KAAA;AAAA,UAClBC,MADkB,GAAA,YAAA,CAAA,MAAA;AAAA,UACVC,MADU,GAAA,YAAA,CAAA,MAAA;AAAA,UACFC,WADE,GAAA,YAAA,CAAA,WAAA;AAAA,UACWC,UADX,GAAA,YAAA,CAAA,UAAA;AAEzB,UAAMC,QAAQ,GAAG,CAAA,MAAA,EAAjB,MAAiB,CAAjB;AACA,UAAMC,UAAU,GAAG,CAACH,WAAW,CAAZ,IAAA,EAAmBA,WAAW,CAAjD,IAAmB,CAAnB;AACA,UAAMxC,QAAQ,GAAG,CAACyC,UAAU,CAAX,OAAA,EAAqBA,UAAU,CAAhD,OAAiB,CAAjB;AAEA,UAAMG,MAAM,GAAGC,IAAI,CAAJA,KAAAA,CAAWR,KAAK,GAAGK,QAAQ,CAA1C,CAA0C,CAA3BG,CAAf;AACA,UAAMC,MAAM,GAAGT,KAAK,GAAGO,MAAM,GAAGF,QAAQ,CAAxC,CAAwC,CAAxC;AACA,UAAMO,IAAI,GAAGL,MAAM,GAAG5C,QAAQ,CAAjB4C,CAAiB,CAAjBA,GAAuBD,UAAU,CAA9C,CAA8C,CAA9C;AACA,UAAMO,IAAI,GAAGJ,MAAM,GAAG9C,QAAQ,CAAjB8C,CAAiB,CAAjBA,GAAuBH,UAAU,CAA9C,CAA8C,CAA9C;AACA,aAAO,CAAA,IAAA,EAAP,IAAO,CAAP;AACD;;;yCAE4B;AAAA,UAAbQ,IAAa,GAAA,IAAA,CAAbA,IAAa;AAAA,UAAPC,IAAO,GAAA,IAAA,CAAPA,IAAO;AAAA,UACpBf,KADoB,GACXc,IADW,CAAA,KAAA;AAE3B,UAAIE,MAAM,GAAV,IAAA;;AACA,UAAIhB,KAAK,IAAT,CAAA,EAAgB;AAAA,YACPiB,iBADO,GACc,KADd,KACc,CADd,iBAAA;AAEd,YAAMC,QAAQ,GAAG,KAAA,mBAAA,CAAjB,KAAiB,CAAjB;AACA,YAAMC,SAAS,GAAGzC,iBAAiB,CAAjBA,kBAAAA,CAChB,MAAM,CAAN,MAAA,CAAc;AAAC0C,UAAAA,UAAU,EAAEpB;AAAb,SAAd,EAAmCiB,iBAAiB,CAAjBA,OAAAA,CADrC,OACqCA,CAAnC,CADgBvC,CAAlB;AAGA,YAAM2C,aAAa,GAAG3C,iBAAiB,CAAjBA,kBAAAA,CACpB,MAAM,CAAN,MAAA,CAAc;AAAC0C,UAAAA,UAAU,EAAEpB;AAAb,SAAd,EAAmCiB,iBAAiB,CAAjBA,OAAAA,CADrC,WACqCA,CAAnC,CADoBvC,CAAtB;AAIAsC,QAAAA,MAAM,GAAG;AACPM,UAAAA,UAAU,EAAEH,SAAS,CADd,UAAA;AAEPI,UAAAA,cAAc,EAAEF,aAAa,CAFtB,UAAA;AAGPG,UAAAA,KAAK,EAAEL,SAAS,CAATA,SAAAA,IAAuBE,aAAa,CAHpC,SAAA;AAIPH,UAAAA,QAAQ,EAJD,QAAA;AAKPO,UAAAA,UAAU,EAAEN,SAAS,CAATA,UAAAA,IAAwBE,aAAa,CAACI;AAL3C,SAATT;;AAOA,YAAID,IAAI,KAAR,OAAA,EAAsB;AAAA,cAEb3C,KAFa,GAAA,KAAA,KAAA;AAAA,cAGf2B,QAHe,GAGH,KAHG,KAGH,CAHG,QAAA;;AAIpB,cAAI,CAAJ,QAAA,EAAe;AAAA,gBAAA,YAAA,GACkC,KADlC,KAAA;AAAA,gBACNK,UADM,GAAA,YAAA,CAAA,UAAA;AAAA,gBACMsB,WADN,GAAA,YAAA,CAAA,WAAA;AAAA,gBACmBvB,WADnB,GAAA,YAAA,CAAA,WAAA;AAAA,gBAENwB,QAFM,GAEM,KAFN,OAEM,CAFN,QAAA;AAGb,gBAAMC,UAAU,GAAG,KAAnB,aAAmB,EAAnB;AACA,gBAAMC,cAAc,GAAGC,yBAAyB,CAAA,KAAA,EAAQ;AACtD1B,cAAAA,UAAU,EAD4C,UAAA;AAEtDwB,cAAAA,UAAU,EAF4C,UAAA;AAGtDD,cAAAA,QAAQ,EAH8C,QAAA;AAItDD,cAAAA,WAAW,EAJ2C,WAAA;AAKtDvB,cAAAA,WAAW,EAAXA;AALsD,aAAR,CAAhD;AAOAJ,YAAAA,QAAQ,GAAG8B,cAAc,CAAzB9B,QAAAA;AACA,iBAAA,QAAA,CAAc;AAACA,cAAAA,QAAQ,EAARA;AAAD,aAAd;AACD;;AACD,cAAMgC,GAAG,GAAG,KAAA,kBAAA,CAAZ,KAAY,CAAZ;AACA,cAAMC,kBAAkB,GAAGjC,QAAQ,CAAnC,GAAmC,CAAnC;AACAkC,UAAAA,MAAM,CAANA,MAAAA,CAAAA,MAAAA,EAAAA,kBAAAA;AACD;AACF;;AAED,aAAO,MAAM,CAAN,MAAA,CAAA,IAAA,EAAoB;AACzBC,QAAAA,MAAM,EAAEC,OAAO,CADU,MACV,CADU;AAGzBnB,QAAAA,MAAM,EAANA;AAHyB,OAApB,CAAP;AAKD;;;mCAEc;AACb,UAAI,CAAC,KAAA,KAAA,CAAL,WAAA,EAA6B;AAC3B,eAAA,IAAA;AACD;;AAHY,UAAA,WAAA,GAaT,KAbS,KAAA;AAAA,UAKXvD,cALW,GAAA,WAAA,CAAA,cAAA;AAAA,UAMXO,QANW,GAAA,WAAA,CAAA,QAAA;AAAA,UAODoE,cAPC,GAAA,WAAA,CAAA,QAAA;AAAA,UAQXvE,QARW,GAAA,WAAA,CAAA,QAAA;AAAA,UASXI,QATW,GAAA,WAAA,CAAA,QAAA;AAAA,UAUXX,cAVW,GAAA,WAAA,CAAA,cAAA;AAAA,UAWXP,WAXW,GAAA,WAAA,CAAA,WAAA;AAAA,UAYXM,eAZW,GAAA,WAAA,CAAA,eAAA;AAAA,UAAA,YAAA,GAe6C,KAf7C,KAAA;AAAA,UAeN0B,OAfM,GAAA,YAAA,CAAA,OAAA;AAAA,UAeGkB,MAfH,GAAA,YAAA,CAAA,MAAA;AAAA,UAeWC,MAfX,GAAA,YAAA,CAAA,MAAA;AAAA,UAemBI,UAfnB,GAAA,YAAA,CAAA,UAAA;AAAA,UAe+BF,UAf/B,GAAA,YAAA,CAAA,UAAA;AAAA,UAgBNpB,KAhBM,GAgBcD,OAhBd,CAAA,KAAA;AAAA,UAgBCU,SAhBD,GAgBcV,OAhBd,CAAA,SAAA;AAiBb,UAAM/B,UAAU,GAAGqF,qBAAqB,CAAC,KAAA,KAAA,CAAzC,UAAwC,CAAxC;AAEA,UAAMC,aAAa,GAAG,KAAA,gBAAA,CAAA,eAAA,EAAtB,gBAAsB,CAAtB;AAEA,aAAO,IAAA,aAAA,CACL;AACEjC,QAAAA,QAAQ,EAAE,CAAA,MAAA,EADZ,MACY,CADZ;AAEEC,QAAAA,UAAU,EAFZ,UAAA;AAGEF,QAAAA,UAAU,EAAE,CAACA,UAAU,CAAX,OAAA,EAAqBA,UAAU,CAH7C,OAGc,CAHd;AAIEpD,QAAAA,UAAU,EAJZ,UAAA;AAKEM,QAAAA,cAAc,EALhB,cAAA;AAMEP,QAAAA,WAAW,EANb,WAAA;AAOEM,QAAAA,eAAe,EAPjB,eAAA;AASEM,QAAAA,QAAQ,EATV,cAAA;AAUEE,QAAAA,QAAQ,EAVV,QAAA;AAWEI,QAAAA,QAAQ,EAXV,QAAA;AAYER,QAAAA,cAAc,EAZhB,cAAA;AAaEO,QAAAA,QAAQ,EAARA;AAbF,OADK,EAgBL,KAAA,gBAAA,CAAsB;AACpBuE,QAAAA,EAAE,EAAE;AADgB,OAAtB,CAhBK,EAmBL;AACEpE,QAAAA,IAAI,EAAE;AACJyD,UAAAA,UAAU,EAAE;AACVY,YAAAA,MAAM,EAAExD,KAAK,CADH,iBAAA;AAEVyD,YAAAA,UAAU,EAAEhD,SAAS,CAACiD;AAFZ;AADR,SADR;AAOEC,QAAAA,iBAAiB,EAAE3D,KAAK,CAP1B,YAAA;AAQE4D,QAAAA,qBAAqB,EAAEnD,SAAS,CARlC,YAAA;AASEoD,QAAAA,YAAY,EAAE3C,MAAM,GAAGD;AATzB,OAnBK,CAAP;AA+BD;;;oCAEe;AAAA,UAAA,mBAAA,GACa,KAAA,KAAA,CADb,OAAA;AAAA,UACPjB,KADO,GAAA,mBAAA,CAAA,KAAA;AAAA,UACAS,SADA,GAAA,mBAAA,CAAA,SAAA;AAEd,OAAA,KAAA,EAAA,SAAA,EAAA,OAAA,CAA2B,UAAA,MAAA,EAAU;AAAA,YAC5BiD,iBAD4B,GACOI,MADP,CAAA,iBAAA;AAAA,YACT1D,YADS,GACO0D,MADP,CAAA,YAAA;AAEnC1D,QAAAA,YAAY,CAAZA,QAAY,CAAZA;;AACA,YAAA,iBAAA,EAAuB;AACrBsD,UAAAA,iBAAiB,CAAjBA,QAAiB,CAAjBA;AACD;AALH,OAAA;;AAOA,MAAA,IAAA,CAAA,eAAA,CAAA,YAAA,CAAA,SAAA,CAAA,EAAA,eAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA;AACD;;;2CAIsB7C,I,EAAM;AAAA,UACpBzB,KADoB,GACDyB,IADC,CAAA,KAAA;AAAA,UACbkD,QADa,GACDlD,IADC,CAAA,QAAA;AAAA,UAEpBlC,QAFoB,GAEUS,KAFV,CAAA,QAAA;AAAA,UAEV4E,gBAFU,GAEU5E,KAFV,CAAA,gBAAA;AAAA,UAGpBuD,QAHoB,GAGR,KAHQ,OAGR,CAHQ,QAAA;AAI3B,UAAMsB,eAAe,GAAGF,QAAQ,CAARA,QAAAA,KAAxB,QAAA;AAJ2B,UAKpBnE,UALoB,GAKN,KALM,KAKN,CALM,UAAA;AAO3B,UAAMsE,gBAAgB,GAAG,KAAA,kBAAA,CAAzB,uBAAyB,CAAzB;AAEA,UAAMC,iBAAiB,GAAGD,gBAAgB,IAAI,KAA9C,kBAA8C,EAA9C;AAT2B,UAWtB/C,WAXsB,GAWP,KAXO,KAWP,CAXO,WAAA;;AAY3B,UAAA,gBAAA,EAAsB;AACpBA,QAAAA,WAAW,GAAGiD,cAAc,CAAC,KAAD,aAAC,EAAD,EAAuB,KAAnDjD,eAAmD,EAAvB,CAA5BA;AACA,aAAA,QAAA,CAAc;AAACA,UAAAA,WAAW,EAAXA;AAAD,SAAd;AACD;;AACD,UAAI+C,gBAAgB,IAApB,eAAA,EAAyC;AAAA,YAAA,cAAA,GAC0BK,aAAa,CAAA,WAAA,EAAA,QAAA,EAAA,QAAA,EADvC,gBACuC,CADvC;AAAA,YAChCnD,UADgC,GAAA,cAAA,CAAA,UAAA;AAAA,YACpBsB,WADoB,GAAA,cAAA,CAAA,WAAA;AAAA,YACP2B,KADO,GAAA,cAAA,CAAA,KAAA;AAAA,YACAC,MADA,GAAA,cAAA,CAAA,MAAA;AAAA,YACQpD,MADR,GAAA,cAAA,CAAA,MAAA;AAAA,YACgBD,MADhB,GAAA,cAAA,CAAA,MAAA;;AAOvC,aAAA,iBAAA,CAAA,MAAA,EAAA,MAAA;AACA,aAAA,QAAA,CAAc;AACZG,UAAAA,UAAU,EADE,UAAA;AAEZsB,UAAAA,WAAW,EAFC,WAAA;AAGZpB,UAAAA,UAAU,EAAE,CAAC,CAAA,CAAA,GAAKoB,WAAW,CAAjB,CAAiB,CAAjB,EAAsB,CAAA,CAAA,GAAKA,WAAW,CAHtC,CAGsC,CAAtC,CAHA;AAIZ2B,UAAAA,KAAK,EAJO,KAAA;AAKZC,UAAAA,MAAM,EALM,MAAA;AAMZpD,UAAAA,MAAM,EANM,MAAA;AAOZD,UAAAA,MAAM,EAANA;AAPY,SAAd;AASD;;AAED,UAAMuD,oBAAoB,GACxBL,iBAAiB,IACjB,KAAA,kBAAA,CAAA,IAAA,EAA8B;AAC5BM,QAAAA,SAAS,EAAE7E,UAAU,CADO,IAAA;AAE5B8E,QAAAA,UAAU,EAAE;AAFgB,OAA9B,CAFF;;AAOA,UAAA,oBAAA,EAA0B;AACxB,aAAA,gBAAA,CAAA,IAAA;AACD;;AACD,WAAA,QAAA,CAAc;AACZF,QAAAA,oBAAoB,EAApBA;AADY,OAAd;AAGD;;;qCAIgB3D,I,EAAM;AAAA,UAAA,WAAA,GAC4BA,IAAI,CADhC,KAAA;AAAA,UACdzC,gBADc,GAAA,WAAA,CAAA,gBAAA;AAAA,UACII,oBADJ,GAAA,WAAA,CAAA,oBAAA;AAAA,UAAA,oBAAA,GAEM,KAAA,KAAA,CAFN,OAAA;AAAA,UAEdwB,KAFc,GAAA,oBAAA,CAAA,KAAA;AAAA,UAEPS,SAFO,GAAA,oBAAA,CAAA,SAAA;AAGrBT,MAAAA,KAAK,CAALA,SAAAA,GAAkB2E,qBAAqB,CAAvC3E,gBAAuC,CAAvCA;AACAS,MAAAA,SAAS,CAATA,SAAAA,GAAsBkE,qBAAqB,CAA3ClE,oBAA2C,CAA3CA;AACD;;;;EA/QuClB,oB;;SAArBD,Y;AAkRrBA,YAAY,CAAZA,SAAAA,GAAAA,cAAAA;AACAA,YAAY,CAAZA,YAAAA,GAAAA,YAAAA","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Buffer} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {log} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION} from '../utils/aggregation-operation-utils';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport {pointToDensityGridDataCPU} from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\n\nconst defaultProps = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {type: 'accessor', value: x => 1},\n  colorAggregation: 'SUM',\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {type: 'accessor', value: x => 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: x => x.position},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n// This layer only perform GPU aggregation, no need to seperate data and weight props\n// aggregation will be dirty when any of the props are changed.\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n  // rest of the changes are detected by `state.attributesChanged`\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\nexport default class GPUGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {gl} = this.context;\n    const isSupported = GPUGridAggregator.isSupported(gl);\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n    super.initializeState({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false, // aggregation in world space\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      color: {size: 3, accessor: 'getColorWeight'},\n      elevation: {size: 3, accessor: 'getElevationWeight'}\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      // Skip update, layer not supported\n      return;\n    }\n    super.updateState(opts);\n    const {aggregationDirty} = this.state;\n    if (aggregationDirty) {\n      // reset cached CPU Aggregation results (used for picking)\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index) {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    // This will match the index to the hash-key to access aggregation data from CPU aggregation results.\n    const latIdx = Math.floor(\n      (yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]\n    );\n    const lonIdx = Math.floor(\n      (xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]\n    );\n    return `${latIdx}-${lonIdx}`;\n  }\n\n  getPositionForIndex(index) {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo({info, mode}) {\n    const {index} = info;\n    let object = null;\n    if (index >= 0) {\n      const {gpuGridAggregator} = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData(\n        Object.assign({pixelIndex: index}, gpuGridAggregator.getData('color'))\n      );\n      const elevationInfo = GPUGridAggregator.getAggregationData(\n        Object.assign({pixelIndex: index}, gpuGridAggregator.getData('elevation'))\n      );\n\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n      if (mode !== 'hover') {\n        // perform CPU aggregation for full list of points for each cell\n        const {props} = this;\n        let {gridHash} = this.state;\n        if (!gridHash) {\n          const {gridOffset, translation, boundingBox} = this.state;\n          const {viewport} = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({gridHash});\n        }\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    return Object.assign(info, {\n      picked: Boolean(object),\n      // override object with picked cell\n      object\n    });\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n\n    const {weights, numRow, numCol, gridOrigin, gridOffset} = this.state;\n    const {color, elevation} = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n\n    return new SubLayerClass(\n      {\n        gridSize: [numCol, numRow],\n        gridOrigin,\n        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n        colorRange,\n        elevationRange,\n        colorDomain,\n        elevationDomain,\n\n        cellSize: cellSizeMeters,\n        coverage,\n        material,\n        elevationScale,\n        extruded\n      },\n      this.getSubLayerProps({\n        id: 'gpu-grid-cell'\n      }),\n      {\n        data: {\n          attributes: {\n            colors: color.aggregationBuffer,\n            elevations: elevation.aggregationBuffer\n          }\n        },\n        colorMaxMinBuffer: color.maxMinBuffer,\n        elevationMaxMinBuffer: elevation.maxMinBuffer,\n        numInstances: numCol * numRow\n      }\n    );\n  }\n\n  finalizeState() {\n    const {color, elevation} = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {aggregationBuffer, maxMinBuffer} = weight;\n      maxMinBuffer.delete();\n      if (aggregationBuffer) {\n        aggregationBuffer.delete();\n      }\n    });\n    super.finalizeState();\n  }\n\n  // Aggregation Overrides\n\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {dimensions} = this.state;\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    // any attribute changed\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      attributesChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: dimensions.data,\n        compareAll: true\n      });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {colorAggregation, elevationAggregation} = opts.props;\n    const {color, elevation} = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n}\n\nGPUGridLayer.layerName = 'GPUGridLayer';\nGPUGridLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}