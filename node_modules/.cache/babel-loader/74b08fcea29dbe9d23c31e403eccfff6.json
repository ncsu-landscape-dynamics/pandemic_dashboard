{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Matrix4 } from 'math.gl';\nimport { MVTLoader } from '@loaders.gl/mvt';\nimport { load } from '@loaders.gl/core';\nimport { COORDINATE_SYSTEM } from '@deck.gl/core';\nimport TileLayer from '../tile-layer/tile-layer';\nimport { getURLFromTemplate } from '../tile-layer/utils';\nimport ClipExtension from './clip-extension';\nvar WORLD_SIZE = 512;\nvar defaultProps = {\n  uniqueIdProperty: {\n    type: 'string',\n    value: ''\n  },\n  highlightedFeatureId: null\n};\n\nvar MVTLayer = function (_TileLayer) {\n  _inherits(MVTLayer, _TileLayer);\n\n  function MVTLayer() {\n    _classCallCheck(this, MVTLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MVTLayer).apply(this, arguments));\n  }\n\n  _createClass(MVTLayer, [{\n    key: \"getTileData\",\n    value: function getTileData(tile) {\n      var url = getURLFromTemplate(this.props.data, tile);\n\n      if (!url) {\n        return Promise.reject('Invalid URL');\n      }\n\n      return load(url, MVTLoader, this.getLoadOptions());\n    }\n  }, {\n    key: \"renderSubLayers\",\n    value: function renderSubLayers(props) {\n      var tile = props.tile;\n      var worldScale = Math.pow(2, tile.z);\n      var xScale = WORLD_SIZE / worldScale;\n      var yScale = -xScale;\n      var xOffset = WORLD_SIZE * tile.x / worldScale;\n      var yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n      var modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n      props.autoHighlight = false;\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [].concat(_toConsumableArray(props.extensions || []), [new ClipExtension()]);\n      return _get(_getPrototypeOf(MVTLayer.prototype), \"renderSubLayers\", this).call(this, props);\n    }\n  }, {\n    key: \"onHover\",\n    value: function onHover(info, pickingEvent) {\n      var _this$props = this.props,\n          uniqueIdProperty = _this$props.uniqueIdProperty,\n          autoHighlight = _this$props.autoHighlight;\n\n      if (autoHighlight) {\n        var hoveredFeatureId = this.state.hoveredFeatureId;\n        var hoveredFeature = info.object;\n        var newHoveredFeatureId;\n\n        if (hoveredFeature) {\n          newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n        }\n\n        if (hoveredFeatureId !== newHoveredFeatureId) {\n          this.setState({\n            hoveredFeatureId: newHoveredFeatureId\n          });\n        }\n      }\n\n      return _get(_getPrototypeOf(MVTLayer.prototype), \"onHover\", this).call(this, info, pickingEvent);\n    }\n  }, {\n    key: \"getHighlightedObjectIndex\",\n    value: function getHighlightedObjectIndex(tile) {\n      var hoveredFeatureId = this.state.hoveredFeatureId;\n      var _this$props2 = this.props,\n          uniqueIdProperty = _this$props2.uniqueIdProperty,\n          highlightedFeatureId = _this$props2.highlightedFeatureId;\n      var data = tile.data;\n      var isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isFeatureIdDefined(highlightedFeatureId);\n\n      if (!isFeatureIdPresent || !Array.isArray(data)) {\n        return -1;\n      }\n\n      var featureIdToHighlight = isFeatureIdDefined(highlightedFeatureId) ? highlightedFeatureId : hoveredFeatureId;\n      return data.findIndex(function (feature) {\n        return getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n      });\n    }\n  }]);\n\n  return MVTLayer;\n}(TileLayer);\n\nexport { MVTLayer as default };\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return -1;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/mvt-layer/mvt-layer.js"],"names":["WORLD_SIZE","defaultProps","uniqueIdProperty","type","value","highlightedFeatureId","MVTLayer","TileLayer","tile","url","getURLFromTemplate","Promise","load","props","worldScale","Math","xScale","yScale","xOffset","yOffset","modelMatrix","COORDINATE_SYSTEM","info","pickingEvent","autoHighlight","hoveredFeatureId","hoveredFeature","newHoveredFeatureId","getFeatureUniqueId","data","isFeatureIdPresent","isFeatureIdDefined","Array","featureIdToHighlight","feature"],"mappings":";;;;;;;AAAA,SAAA,OAAA,QAAA,SAAA;AACA,SAAA,SAAA,QAAA,iBAAA;AACA,SAAA,IAAA,QAAA,kBAAA;AACA,SAAA,iBAAA,QAAA,eAAA;AAEA,OAAA,SAAA,MAAA,0BAAA;AACA,SAAA,kBAAA,QAAA,qBAAA;AACA,OAAA,aAAA,MAAA,kBAAA;AAEA,IAAMA,UAAU,GAAhB,GAAA;AAEA,IAAMC,YAAY,GAAG;AACnBC,EAAAA,gBAAgB,EAAE;AAACC,IAAAA,IAAI,EAAL,QAAA;AAAiBC,IAAAA,KAAK,EAAE;AAAxB,GADC;AAEnBC,EAAAA,oBAAoB,EAAE;AAFH,CAArB;;IAKqBC,Q;;;;;;;;;;;gCACPE,I,EAAM;AAChB,UAAMC,GAAG,GAAGC,kBAAkB,CAAC,KAAA,KAAA,CAAD,IAAA,EAA9B,IAA8B,CAA9B;;AACA,UAAI,CAAJ,GAAA,EAAU;AACR,eAAOC,OAAO,CAAPA,MAAAA,CAAP,aAAOA,CAAP;AACD;;AACD,aAAOC,IAAI,CAAA,GAAA,EAAA,SAAA,EAAiB,KAA5B,cAA4B,EAAjB,CAAX;AACD;;;oCAEeC,K,EAAO;AAAA,UACdL,IADc,GACNK,KADM,CAAA,IAAA;AAErB,UAAMC,UAAU,GAAGC,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAYP,IAAI,CAAnC,CAAmBO,CAAnB;AAEA,UAAMC,MAAM,GAAGhB,UAAU,GAAzB,UAAA;AACA,UAAMiB,MAAM,GAAG,CAAf,MAAA;AAEA,UAAMC,OAAO,GAAIlB,UAAU,GAAGQ,IAAI,CAAlB,CAACR,GAAjB,UAAA;AACA,UAAMmB,OAAO,GAAGnB,UAAU,IAAI,IAAIQ,IAAI,CAAJA,CAAAA,GAAlC,UAA0B,CAA1B;AAEA,UAAMY,WAAW,GAAG,IAAA,OAAA,GAAA,KAAA,CAAoB,CAAA,MAAA,EAAA,MAAA,EAAxC,CAAwC,CAApB,CAApB;AAEAP,MAAAA,KAAK,CAALA,aAAAA,GAAAA,KAAAA;AACAA,MAAAA,KAAK,CAALA,WAAAA,GAAAA,WAAAA;AACAA,MAAAA,KAAK,CAALA,gBAAAA,GAAyB,CAAA,OAAA,EAAA,OAAA,EAAzBA,CAAyB,CAAzBA;AACAA,MAAAA,KAAK,CAALA,gBAAAA,GAAyBQ,iBAAiB,CAA1CR,SAAAA;AACAA,MAAAA,KAAK,CAALA,UAAAA,GAAAA,GAAAA,MAAAA,CAAAA,kBAAAA,CAAwBA,KAAK,CAALA,UAAAA,IAAxBA,EAAAA,CAAAA,EAAAA,CAAiD,IAAjDA,aAAiD,EAAjDA,CAAAA,CAAAA;AAEA,aAAA,IAAA,CAAA,eAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAA,iBAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,KAAA,CAAA;AACD;;;4BAEOS,I,EAAMC,Y,EAAc;AAAA,UAAA,WAAA,GACgB,KADhB,KAAA;AAAA,UACnBrB,gBADmB,GAAA,WAAA,CAAA,gBAAA;AAAA,UACDsB,aADC,GAAA,WAAA,CAAA,aAAA;;AAG1B,UAAA,aAAA,EAAmB;AAAA,YACVC,gBADU,GACU,KADV,KACU,CADV,gBAAA;AAEjB,YAAMC,cAAc,GAAGJ,IAAI,CAA3B,MAAA;AACA,YAAA,mBAAA;;AAEA,YAAA,cAAA,EAAoB;AAClBK,UAAAA,mBAAmB,GAAGC,kBAAkB,CAAA,cAAA,EAAxCD,gBAAwC,CAAxCA;AACD;;AAED,YAAIF,gBAAgB,KAApB,mBAAA,EAA8C;AAC5C,eAAA,QAAA,CAAc;AAACA,YAAAA,gBAAgB,EAAEE;AAAnB,WAAd;AACD;AACF;;AAED,aAAA,IAAA,CAAA,eAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAA,SAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,IAAA,EAAA,YAAA,CAAA;AACD;;;8CAEyBnB,I,EAAM;AAAA,UACvBiB,gBADuB,GACH,KADG,KACH,CADG,gBAAA;AAAA,UAAA,YAAA,GAEmB,KAFnB,KAAA;AAAA,UAEvBvB,gBAFuB,GAAA,YAAA,CAAA,gBAAA;AAAA,UAELG,oBAFK,GAAA,YAAA,CAAA,oBAAA;AAAA,UAGvBwB,IAHuB,GAGfrB,IAHe,CAAA,IAAA;AAK9B,UAAMsB,kBAAkB,GACtBC,kBAAkB,CAAlBA,gBAAkB,CAAlBA,IAAwCA,kBAAkB,CAD5D,oBAC4D,CAD5D;;AAGA,UAAI,CAAA,kBAAA,IAAuB,CAACC,KAAK,CAALA,OAAAA,CAA5B,IAA4BA,CAA5B,EAAiD;AAC/C,eAAO,CAAP,CAAA;AACD;;AAED,UAAMC,oBAAoB,GAAGF,kBAAkB,CAAlBA,oBAAkB,CAAlBA,GAAAA,oBAAAA,GAA7B,gBAAA;AAIA,aAAO,IAAI,CAAJ,SAAA,CACL,UAAA,OAAA,EAAO;AAAA,eAAIH,kBAAkB,CAAA,OAAA,EAAlBA,gBAAkB,CAAlBA,KAAJ,oBAAA;AADT,OAAO,CAAP;AAGD;;;;EArEmCrB,S;;SAAjBD,Q;;AAwErB,SAAA,kBAAA,CAAA,OAAA,EAAA,gBAAA,EAAuD;AACrD,MAAA,gBAAA,EAAsB;AACpB,WAAO4B,OAAO,CAAPA,UAAAA,CAAP,gBAAOA,CAAP;AACD;;AAED,MAAI,QAAJ,OAAA,EAAqB;AACnB,WAAOA,OAAO,CAAd,EAAA;AACD;;AAED,SAAO,CAAP,CAAA;AACD;;AAED,SAAA,kBAAA,CAAA,KAAA,EAAmC;AACjC,SAAO9B,KAAK,KAALA,SAAAA,IAAuBA,KAAK,KAA5BA,IAAAA,IAAyCA,KAAK,KAArD,EAAA;AACD;;AAEDE,QAAQ,CAARA,SAAAA,GAAAA,UAAAA;AACAA,QAAQ,CAARA,YAAAA,GAAAA,YAAAA","sourcesContent":["import {Matrix4} from 'math.gl';\nimport {MVTLoader} from '@loaders.gl/mvt';\nimport {load} from '@loaders.gl/core';\nimport {COORDINATE_SYSTEM} from '@deck.gl/core';\n\nimport TileLayer from '../tile-layer/tile-layer';\nimport {getURLFromTemplate} from '../tile-layer/utils';\nimport ClipExtension from './clip-extension';\n\nconst WORLD_SIZE = 512;\n\nconst defaultProps = {\n  uniqueIdProperty: {type: 'string', value: ''},\n  highlightedFeatureId: null\n};\n\nexport default class MVTLayer extends TileLayer {\n  getTileData(tile) {\n    const url = getURLFromTemplate(this.props.data, tile);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n    return load(url, MVTLoader, this.getLoadOptions());\n  }\n\n  renderSubLayers(props) {\n    const {tile} = props;\n    const worldScale = Math.pow(2, tile.z);\n\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n\n    const xOffset = (WORLD_SIZE * tile.x) / worldScale;\n    const yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n\n    props.autoHighlight = false;\n    props.modelMatrix = modelMatrix;\n    props.coordinateOrigin = [xOffset, yOffset, 0];\n    props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n    props.extensions = [...(props.extensions || []), new ClipExtension()];\n\n    return super.renderSubLayers(props);\n  }\n\n  onHover(info, pickingEvent) {\n    const {uniqueIdProperty, autoHighlight} = this.props;\n\n    if (autoHighlight) {\n      const {hoveredFeatureId} = this.state;\n      const hoveredFeature = info.object;\n      let newHoveredFeatureId;\n\n      if (hoveredFeature) {\n        newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      }\n\n      if (hoveredFeatureId !== newHoveredFeatureId) {\n        this.setState({hoveredFeatureId: newHoveredFeatureId});\n      }\n    }\n\n    return super.onHover(info, pickingEvent);\n  }\n\n  getHighlightedObjectIndex(tile) {\n    const {hoveredFeatureId} = this.state;\n    const {uniqueIdProperty, highlightedFeatureId} = this.props;\n    const {data} = tile;\n\n    const isFeatureIdPresent =\n      isFeatureIdDefined(hoveredFeatureId) || isFeatureIdDefined(highlightedFeatureId);\n\n    if (!isFeatureIdPresent || !Array.isArray(data)) {\n      return -1;\n    }\n\n    const featureIdToHighlight = isFeatureIdDefined(highlightedFeatureId)\n      ? highlightedFeatureId\n      : hoveredFeatureId;\n\n    return data.findIndex(\n      feature => getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight\n    );\n  }\n}\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return -1;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}