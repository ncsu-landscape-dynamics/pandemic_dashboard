{"ast":null,"code":"import extent from '@mapbox/geojson-extent';\nimport * as Constants from '../constants';\nconst {\n  LAT_MIN,\n  LAT_MAX,\n  LAT_RENDERED_MIN,\n  LAT_RENDERED_MAX,\n  LNG_MIN,\n  LNG_MAX\n} = Constants; // Ensure that we do not drag north-south far enough for\n// - any part of any feature to exceed the poles\n// - any feature to be completely lost in the space between the projection's\n//   edge and the poles, such that it couldn't be re-selected and moved back\n\nexport default function (geojsonFeatures, delta) {\n  // \"inner edge\" = a feature's latitude closest to the equator\n  let northInnerEdge = LAT_MIN;\n  let southInnerEdge = LAT_MAX; // \"outer edge\" = a feature's latitude furthest from the equator\n\n  let northOuterEdge = LAT_MIN;\n  let southOuterEdge = LAT_MAX;\n  let westEdge = LNG_MAX;\n  let eastEdge = LNG_MIN;\n  geojsonFeatures.forEach(feature => {\n    const bounds = extent(feature);\n    const featureSouthEdge = bounds[1];\n    const featureNorthEdge = bounds[3];\n    const featureWestEdge = bounds[0];\n    const featureEastEdge = bounds[2];\n    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;\n    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;\n    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;\n    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;\n    if (featureWestEdge < westEdge) westEdge = featureWestEdge;\n    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;\n  }); // These changes are not mutually exclusive: we might hit the inner\n  // edge but also have hit the outer edge and therefore need\n  // another readjustment\n\n  const constrainedDelta = delta;\n\n  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {\n    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;\n  }\n\n  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {\n    constrainedDelta.lat = LAT_MAX - northOuterEdge;\n  }\n\n  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {\n    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;\n  }\n\n  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {\n    constrainedDelta.lat = LAT_MIN - southOuterEdge;\n  }\n\n  if (westEdge + constrainedDelta.lng <= LNG_MIN) {\n    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n\n  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {\n    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n\n  return constrainedDelta;\n}","map":{"version":3,"sources":["/Users/garrettmillar/pandemic_dashboard/node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js"],"names":["extent","Constants","LAT_MIN","LAT_MAX","LAT_RENDERED_MIN","LAT_RENDERED_MAX","LNG_MIN","LNG_MAX","geojsonFeatures","delta","northInnerEdge","southInnerEdge","northOuterEdge","southOuterEdge","westEdge","eastEdge","forEach","feature","bounds","featureSouthEdge","featureNorthEdge","featureWestEdge","featureEastEdge","constrainedDelta","lat","lng","Math","ceil","abs"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,wBAAnB;AACA,OAAO,KAAKC,SAAZ,MAA2B,cAA3B;AAEA,MAAM;AACJC,EAAAA,OADI;AAEJC,EAAAA,OAFI;AAGJC,EAAAA,gBAHI;AAIJC,EAAAA,gBAJI;AAKJC,EAAAA,OALI;AAMJC,EAAAA;AANI,IAOFN,SAPJ,C,CASA;AACA;AACA;AACA;;AACA,eAAe,UAASO,eAAT,EAA0BC,KAA1B,EAAiC;AAC9C;AACA,MAAIC,cAAc,GAAGR,OAArB;AACA,MAAIS,cAAc,GAAGR,OAArB,CAH8C,CAI9C;;AACA,MAAIS,cAAc,GAAGV,OAArB;AACA,MAAIW,cAAc,GAAGV,OAArB;AAEA,MAAIW,QAAQ,GAAGP,OAAf;AACA,MAAIQ,QAAQ,GAAGT,OAAf;AAEAE,EAAAA,eAAe,CAACQ,OAAhB,CAAyBC,OAAD,IAAa;AACnC,UAAMC,MAAM,GAAGlB,MAAM,CAACiB,OAAD,CAArB;AACA,UAAME,gBAAgB,GAAGD,MAAM,CAAC,CAAD,CAA/B;AACA,UAAME,gBAAgB,GAAGF,MAAM,CAAC,CAAD,CAA/B;AACA,UAAMG,eAAe,GAAGH,MAAM,CAAC,CAAD,CAA9B;AACA,UAAMI,eAAe,GAAGJ,MAAM,CAAC,CAAD,CAA9B;AACA,QAAIC,gBAAgB,GAAGT,cAAvB,EAAuCA,cAAc,GAAGS,gBAAjB;AACvC,QAAIC,gBAAgB,GAAGT,cAAvB,EAAuCA,cAAc,GAAGS,gBAAjB;AACvC,QAAIA,gBAAgB,GAAGR,cAAvB,EAAuCA,cAAc,GAAGQ,gBAAjB;AACvC,QAAID,gBAAgB,GAAGN,cAAvB,EAAuCA,cAAc,GAAGM,gBAAjB;AACvC,QAAIE,eAAe,GAAGP,QAAtB,EAAgCA,QAAQ,GAAGO,eAAX;AAChC,QAAIC,eAAe,GAAGP,QAAtB,EAAgCA,QAAQ,GAAGO,eAAX;AACjC,GAZD,EAX8C,CA0B9C;AACA;AACA;;AACA,QAAMC,gBAAgB,GAAGd,KAAzB;;AACA,MAAIC,cAAc,GAAGa,gBAAgB,CAACC,GAAlC,GAAwCnB,gBAA5C,EAA8D;AAC5DkB,IAAAA,gBAAgB,CAACC,GAAjB,GAAuBnB,gBAAgB,GAAGK,cAA1C;AACD;;AACD,MAAIE,cAAc,GAAGW,gBAAgB,CAACC,GAAlC,GAAwCrB,OAA5C,EAAqD;AACnDoB,IAAAA,gBAAgB,CAACC,GAAjB,GAAuBrB,OAAO,GAAGS,cAAjC;AACD;;AACD,MAAID,cAAc,GAAGY,gBAAgB,CAACC,GAAlC,GAAwCpB,gBAA5C,EAA8D;AAC5DmB,IAAAA,gBAAgB,CAACC,GAAjB,GAAuBpB,gBAAgB,GAAGO,cAA1C;AACD;;AACD,MAAIE,cAAc,GAAGU,gBAAgB,CAACC,GAAlC,GAAwCtB,OAA5C,EAAqD;AACnDqB,IAAAA,gBAAgB,CAACC,GAAjB,GAAuBtB,OAAO,GAAGW,cAAjC;AACD;;AACD,MAAIC,QAAQ,GAAGS,gBAAgB,CAACE,GAA5B,IAAmCnB,OAAvC,EAAgD;AAC9CiB,IAAAA,gBAAgB,CAACE,GAAjB,IAAwBC,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACE,GAAL,CAASL,gBAAgB,CAACE,GAA1B,IAAiC,GAA3C,IAAkD,GAA1E;AACD;;AACD,MAAIV,QAAQ,GAAGQ,gBAAgB,CAACE,GAA5B,IAAmClB,OAAvC,EAAgD;AAC9CgB,IAAAA,gBAAgB,CAACE,GAAjB,IAAwBC,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACE,GAAL,CAASL,gBAAgB,CAACE,GAA1B,IAAiC,GAA3C,IAAkD,GAA1E;AACD;;AAED,SAAOF,gBAAP;AACD","sourcesContent":["import extent from '@mapbox/geojson-extent';\nimport * as Constants from '../constants';\n\nconst {\n  LAT_MIN,\n  LAT_MAX,\n  LAT_RENDERED_MIN,\n  LAT_RENDERED_MAX,\n  LNG_MIN,\n  LNG_MAX\n} = Constants;\n\n// Ensure that we do not drag north-south far enough for\n// - any part of any feature to exceed the poles\n// - any feature to be completely lost in the space between the projection's\n//   edge and the poles, such that it couldn't be re-selected and moved back\nexport default function(geojsonFeatures, delta) {\n  // \"inner edge\" = a feature's latitude closest to the equator\n  let northInnerEdge = LAT_MIN;\n  let southInnerEdge = LAT_MAX;\n  // \"outer edge\" = a feature's latitude furthest from the equator\n  let northOuterEdge = LAT_MIN;\n  let southOuterEdge = LAT_MAX;\n\n  let westEdge = LNG_MAX;\n  let eastEdge = LNG_MIN;\n\n  geojsonFeatures.forEach((feature) => {\n    const bounds = extent(feature);\n    const featureSouthEdge = bounds[1];\n    const featureNorthEdge = bounds[3];\n    const featureWestEdge = bounds[0];\n    const featureEastEdge = bounds[2];\n    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;\n    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;\n    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;\n    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;\n    if (featureWestEdge < westEdge) westEdge = featureWestEdge;\n    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;\n  });\n\n\n  // These changes are not mutually exclusive: we might hit the inner\n  // edge but also have hit the outer edge and therefore need\n  // another readjustment\n  const constrainedDelta = delta;\n  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {\n    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;\n  }\n  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {\n    constrainedDelta.lat = LAT_MAX - northOuterEdge;\n  }\n  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {\n    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;\n  }\n  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {\n    constrainedDelta.lat = LAT_MIN - southOuterEdge;\n  }\n  if (westEdge + constrainedDelta.lng <= LNG_MIN) {\n    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {\n    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n\n  return constrainedDelta;\n}\n"]},"metadata":{},"sourceType":"module"}