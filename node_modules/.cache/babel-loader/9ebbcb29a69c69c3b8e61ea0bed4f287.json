{"ast":null,"code":"import { makeStringIterator } from './string-iterator';\nimport { makeArrayBufferIterator } from './array-buffer-iterator';\nimport { makeBlobIterator } from './blob-iterator';\nimport { assert } from '@loaders.gl/loader-utils';\nimport { makeStreamIterator } from './stream-iterator';\nimport { isBlob, isReadableStream, isResponse } from '../../javascript-utils/is-type';\nexport function makeIterator(data) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof data === 'string') {\n    return makeStringIterator(data, options);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return makeArrayBufferIterator(data, options);\n  }\n\n  if (isBlob(data)) {\n    return makeBlobIterator(data, options);\n  }\n\n  if (isReadableStream(data)) {\n    return makeStreamIterator(data);\n  }\n\n  if (isResponse(data)) {\n    return makeStreamIterator(data.body);\n  }\n\n  return assert(false);\n}","map":{"version":3,"sources":["../../../../src/iterator-utils/make-iterator/make-iterator.js"],"names":["options","makeStringIterator","data","makeArrayBufferIterator","isBlob","makeBlobIterator","isReadableStream","makeStreamIterator","isResponse","assert"],"mappings":"AAAA,SAAA,kBAAA,QAAA,mBAAA;AACA,SAAA,uBAAA,QAAA,yBAAA;AACA,SAAA,gBAAA,QAAA,iBAAA;AACA,SAAA,MAAA,QAAA,0BAAA;AACA,SAAA,kBAAA,QAAA,mBAAA;AACA,SAAA,MAAA,EAAA,gBAAA,EAAA,UAAA,QAAA,gCAAA;AAaA,OAAO,SAAA,YAAA,CAAA,IAAA,EAA0C;AAAA,MAAdA,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;;AAC/C,MAAI,OAAA,IAAA,KAAJ,QAAA,EAA8B;AAE5B,WAAOC,kBAAkB,CAAA,IAAA,EAAzB,OAAyB,CAAzB;AACD;;AACD,MAAIC,IAAI,YAAR,WAAA,EAAiC;AAC/B,WAAOC,uBAAuB,CAAA,IAAA,EAA9B,OAA8B,CAA9B;AACD;;AACD,MAAIC,MAAM,CAAV,IAAU,CAAV,EAAkB;AAChB,WAAOC,gBAAgB,CAAA,IAAA,EAAvB,OAAuB,CAAvB;AACD;;AACD,MAAIC,gBAAgB,CAApB,IAAoB,CAApB,EAA4B;AAC1B,WAAOC,kBAAkB,CAAzB,IAAyB,CAAzB;AACD;;AACD,MAAIC,UAAU,CAAd,IAAc,CAAd,EAAsB;AACpB,WAAOD,kBAAkB,CAACL,IAAI,CAA9B,IAAyB,CAAzB;AACD;;AACD,SAAOO,MAAM,CAAb,KAAa,CAAb;AACD","sourcesContent":["import {makeStringIterator} from './string-iterator';\nimport {makeArrayBufferIterator} from './array-buffer-iterator';\nimport {makeBlobIterator} from './blob-iterator';\nimport {assert} from '@loaders.gl/loader-utils';\nimport {makeStreamIterator} from './stream-iterator';\nimport {isBlob, isReadableStream, isResponse} from '../../javascript-utils/is-type';\n\n/**\n * Returns an iterator that breaks its input into chunks and yields them one-by-one.\n *\n * @param data a big `ArrayBuffer`, `Blob` or string, or a stream.\n * @param {object} options\n * @param {number} [options.chunkSize]  max number of bytes per chunk. chunkSize is ignored for streams.\n * @returns iterator or async iterator that yields chunks of specified size.\n *\n * This function can e.g. be used to enable data sources that can only be read atomically\n * (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.\n */\nexport function makeIterator(data, options = {}) {\n  if (typeof data === 'string') {\n    // Note: Converts string chunks to binary\n    return makeStringIterator(data, options);\n  }\n  if (data instanceof ArrayBuffer) {\n    return makeArrayBufferIterator(data, options);\n  }\n  if (isBlob(data)) {\n    return makeBlobIterator(data, options);\n  }\n  if (isReadableStream(data)) {\n    return makeStreamIterator(data);\n  }\n  if (isResponse(data)) {\n    return makeStreamIterator(data.body);\n  }\n  return assert(false);\n}\n"]},"metadata":{},"sourceType":"module"}