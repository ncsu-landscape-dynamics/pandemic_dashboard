{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { createIterable } from '@deck.gl/core';\nimport { getGridOffset } from '../utils/grid-aggregation-utils';\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  var hashInfo = pointsToGridHashing(props, aggregationParams);\n  var result = getGridLayerDataFromGridHash(hashInfo);\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\n\nfunction pointsToGridHashing(props, aggregationParams) {\n  var _props$data = props.data,\n      data = _props$data === void 0 ? [] : _props$data,\n      cellSize = props.cellSize;\n  var attributes = aggregationParams.attributes,\n      viewport = aggregationParams.viewport,\n      projectPoints = aggregationParams.projectPoints,\n      numInstances = aggregationParams.numInstances;\n  var positions = attributes.positions.value;\n\n  var _attributes$positions = attributes.positions.getAccessor(),\n      size = _attributes$positions.size;\n\n  var boundingBox = aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  var offsets = aggregationParams.posOffset || [180, 90];\n  var gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {\n      gridHash: {},\n      gridOffset: gridOffset\n    };\n  }\n\n  var width = viewport.width,\n      height = viewport.height;\n  var numCol = Math.ceil(width / gridOffset.xOffset);\n  var numRow = Math.ceil(height / gridOffset.yOffset);\n  var gridHash = {};\n\n  var _createIterable = createIterable(data),\n      iterable = _createIterable.iterable,\n      objectInfo = _createIterable.objectInfo;\n\n  var position = new Array(3);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var pt = _step.value;\n      objectInfo.index++;\n      position[0] = positions[objectInfo.index * size];\n      position[1] = positions[objectInfo.index * size + 1];\n      position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n\n      var _ref = projectPoints ? viewport.project(position) : position,\n          _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n\n      if (Number.isFinite(x) && Number.isFinite(y)) {\n        var yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n        var xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n\n        if (!projectPoints || xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow) {\n          var key = \"\".concat(yIndex, \"-\").concat(xIndex);\n          gridHash[key] = gridHash[key] || {\n            count: 0,\n            points: [],\n            lonIdx: xIndex,\n            latIdx: yIndex\n          };\n          gridHash[key].count += 1;\n          gridHash[key].points.push(pt);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return {\n    gridHash: gridHash,\n    gridOffset: gridOffset,\n    offsets: [offsets[0] * -1, offsets[1] * -1]\n  };\n}\n\nfunction getGridLayerDataFromGridHash(_ref3) {\n  var gridHash = _ref3.gridHash,\n      gridOffset = _ref3.gridOffset,\n      offsets = _ref3.offsets;\n  var data = new Array(Object.keys(gridHash).length);\n  var i = 0;\n\n  for (var key in gridHash) {\n    var idxs = key.split('-');\n    var latIdx = parseInt(idxs[0], 10);\n    var lonIdx = parseInt(idxs[1], 10);\n    var index = i++;\n    data[index] = Object.assign({\n      index: index,\n      position: [offsets[0] + gridOffset.xOffset * lonIdx, offsets[1] + gridOffset.yOffset * latIdx]\n    }, gridHash[key]);\n  }\n\n  return data;\n}\n\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  var positions = positionAttribute.value;\n\n  var _positionAttribute$ge = positionAttribute.getAccessor(),\n      size = _positionAttribute$ge.size;\n\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var y;\n  var x;\n\n  for (var i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {\n    xMin: xMin,\n    xMax: xMax,\n    yMin: yMin,\n    yMax: yMax\n  };\n}","map":{"version":3,"sources":["../../../src/cpu-grid-layer/grid-aggregator.js"],"names":["hashInfo","pointsToGridHashing","result","getGridLayerDataFromGridHash","gridHash","gridOffset","data","cellSize","props","attributes","viewport","projectPoints","numInstances","aggregationParams","positions","size","boundingBox","getPositionBoundingBox","offsets","getGridOffset","width","height","numCol","Math","numRow","iterable","objectInfo","createIterable","position","pt","x","y","Number","yIndex","xIndex","key","count","points","lonIdx","latIdx","Object","i","idxs","parseInt","index","positionAttribute","yMin","yMax","xMin","xMax"],"mappings":";AAoBA,SAAA,cAAA,QAAA,eAAA;AACA,SAAA,aAAA,QAAA,iCAAA;AAoBA,OAAO,SAAA,yBAAA,CAAA,KAAA,EAAA,iBAAA,EAA6D;AAClE,MAAMA,QAAQ,GAAGC,mBAAmB,CAAA,KAAA,EAApC,iBAAoC,CAApC;AACA,MAAMC,MAAM,GAAGC,4BAA4B,CAA3C,QAA2C,CAA3C;AAEA,SAAO;AACLC,IAAAA,QAAQ,EAAEJ,QAAQ,CADb,QAAA;AAELK,IAAAA,UAAU,EAAEL,QAAQ,CAFf,UAAA;AAGLM,IAAAA,IAAI,EAAEJ;AAHD,GAAP;AAKD;;AAUD,SAAA,mBAAA,CAAA,KAAA,EAAA,iBAAA,EAAuD;AAAA,MAAA,WAAA,GACvBM,KADuB,CAAA,IAAA;AAAA,MAC9CF,IAD8C,GAAA,WAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,WAAA;AAAA,MACnCC,QADmC,GACvBC,KADuB,CAAA,QAAA;AAAA,MAE9CC,UAF8C,GAEOI,iBAFP,CAAA,UAAA;AAAA,MAElCH,QAFkC,GAEOG,iBAFP,CAAA,QAAA;AAAA,MAExBF,aAFwB,GAEOE,iBAFP,CAAA,aAAA;AAAA,MAETD,YAFS,GAEOC,iBAFP,CAAA,YAAA;AAGrD,MAAMC,SAAS,GAAGL,UAAU,CAAVA,SAAAA,CAAlB,KAAA;;AAHqD,MAAA,qBAAA,GAItCA,UAAU,CAAVA,SAAAA,CAJsC,WAItCA,EAJsC;AAAA,MAI9CM,IAJ8C,GAAA,qBAAA,CAAA,IAAA;;AAKrD,MAAMC,WAAW,GACfH,iBAAiB,CAAjBA,WAAAA,IAAiCI,sBAAsB,CAACR,UAAU,CAAX,SAAA,EADzD,YACyD,CADzD;AAEA,MAAMS,OAAO,GAAGL,iBAAiB,CAAjBA,SAAAA,IAA+B,CAAA,GAAA,EAA/C,EAA+C,CAA/C;AACA,MAAMR,UAAU,GAAGQ,iBAAiB,CAAjBA,UAAAA,IAAgCM,aAAa,CAAA,WAAA,EAAhE,QAAgE,CAAhE;;AAEA,MAAId,UAAU,CAAVA,OAAAA,IAAAA,CAAAA,IAA2BA,UAAU,CAAVA,OAAAA,IAA/B,CAAA,EAAwD;AACtD,WAAO;AAACD,MAAAA,QAAQ,EAAT,EAAA;AAAeC,MAAAA,UAAU,EAAVA;AAAf,KAAP;AACD;;AAZoD,MAc9Ce,KAd8C,GAc7BV,QAd6B,CAAA,KAAA;AAAA,MAcvCW,MAduC,GAc7BX,QAd6B,CAAA,MAAA;AAerD,MAAMY,MAAM,GAAGC,IAAI,CAAJA,IAAAA,CAAUH,KAAK,GAAGf,UAAU,CAA3C,OAAekB,CAAf;AACA,MAAMC,MAAM,GAAGD,IAAI,CAAJA,IAAAA,CAAUF,MAAM,GAAGhB,UAAU,CAA5C,OAAekB,CAAf;AAGA,MAAMnB,QAAQ,GAAd,EAAA;;AAnBqD,MAAA,eAAA,GAqBtBuB,cAAc,CArBQ,IAqBR,CArBQ;AAAA,MAqB9CF,QArB8C,GAAA,eAAA,CAAA,QAAA;AAAA,MAqBpCC,UArBoC,GAAA,eAAA,CAAA,UAAA;;AAsBrD,MAAME,QAAQ,GAAG,IAAA,KAAA,CAAjB,CAAiB,CAAjB;AAtBqD,MAAA,yBAAA,GAAA,IAAA;AAAA,MAAA,iBAAA,GAAA,KAAA;AAAA,MAAA,cAAA,GAAA,SAAA;;AAAA,MAAA;AAuBrD,SAAA,IAAA,SAAA,GAAiBH,QAAjB,CAAA,MAAA,CAAA,QAAA,CAAiBA,EAAjB,EAAA,KAAA,EAAA,EAAA,yBAAA,GAAA,CAAA,KAAA,GAAA,SAAA,CAAA,IAAA,EAAA,EAAA,IAAA,CAAA,EAAA,yBAAA,GAAA,IAAA,EAA2B;AAAA,UAAhBI,EAAgB,GAAA,KAAA,CAAA,KAAA;AACzBH,MAAAA,UAAU,CAAVA,KAAAA;AACAE,MAAAA,QAAQ,CAARA,CAAQ,CAARA,GAAcd,SAAS,CAACY,UAAU,CAAVA,KAAAA,GAAxBE,IAAuB,CAAvBA;AACAA,MAAAA,QAAQ,CAARA,CAAQ,CAARA,GAAcd,SAAS,CAACY,UAAU,CAAVA,KAAAA,GAAAA,IAAAA,GAAxBE,CAAuB,CAAvBA;AACAA,MAAAA,QAAQ,CAARA,CAAQ,CAARA,GAAcb,IAAI,IAAJA,CAAAA,GAAYD,SAAS,CAACY,UAAU,CAAVA,KAAAA,GAAAA,IAAAA,GAAtBX,CAAqB,CAArBA,GAAda,CAAAA;;AAJyB,UAAA,IAAA,GAKVjB,aAAa,GAAGD,QAAQ,CAARA,OAAAA,CAAH,QAAGA,CAAH,GALH,QAAA;AAAA,UAAA,KAAA,GAAA,cAAA,CAAA,IAAA,EAAA,CAAA,CAAA;AAAA,UAKlBoB,CALkB,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,UAKfC,CALe,GAAA,KAAA,CAAA,CAAA,CAAA;;AAMzB,UAAIC,MAAM,CAANA,QAAAA,CAAAA,CAAAA,KAAsBA,MAAM,CAANA,QAAAA,CAA1B,CAA0BA,CAA1B,EAA8C;AAC5C,YAAMC,MAAM,GAAGV,IAAI,CAAJA,KAAAA,CAAW,CAACQ,CAAC,GAAGb,OAAO,CAAZ,CAAY,CAAZ,IAAmBb,UAAU,CAAvD,OAAekB,CAAf;AACA,YAAMW,MAAM,GAAGX,IAAI,CAAJA,KAAAA,CAAW,CAACO,CAAC,GAAGZ,OAAO,CAAZ,CAAY,CAAZ,IAAmBb,UAAU,CAAvD,OAAekB,CAAf;;AACA,YACE,CAAA,aAAA,IAECW,MAAM,IAANA,CAAAA,IAAeA,MAAM,GAArBA,MAAAA,IAAkCD,MAAM,IAAxCC,CAAAA,IAAiDD,MAAM,GAH1D,MAAA,EAIE;AACA,cAAME,GAAG,GAAA,GAAA,MAAA,CAAA,MAAA,EAAA,GAAA,EAAA,MAAA,CAAT,MAAS,CAAT;AAEA/B,UAAAA,QAAQ,CAARA,GAAQ,CAARA,GAAgBA,QAAQ,CAARA,GAAQ,CAARA,IAAiB;AAACgC,YAAAA,KAAK,EAAN,CAAA;AAAWC,YAAAA,MAAM,EAAjB,EAAA;AAAuBC,YAAAA,MAAM,EAA7B,MAAA;AAAuCC,YAAAA,MAAM,EAAEN;AAA/C,WAAjC7B;AACAA,UAAAA,QAAQ,CAARA,GAAQ,CAARA,CAAAA,KAAAA,IAAAA,CAAAA;AACAA,UAAAA,QAAQ,CAARA,GAAQ,CAARA,CAAAA,MAAAA,CAAAA,IAAAA,CAAAA,EAAAA;AACD;AACF;AACF;AA5CoD,GAAA,CAAA,OAAA,GAAA,EAAA;AAAA,IAAA,iBAAA,GAAA,IAAA;AAAA,IAAA,cAAA,GAAA,GAAA;AAAA,GAAA,SAAA;AAAA,QAAA;AAAA,UAAA,CAAA,yBAAA,IAAA,SAAA,CAAA,QAAA,CAAA,IAAA,IAAA,EAAA;AAAA,QAAA,SAAA,CAAA,QAAA,CAAA;AAAA;AAAA,KAAA,SAAA;AAAA,UAAA,iBAAA,EAAA;AAAA,cAAA,cAAA;AAAA;AAAA;AAAA;;AA8CrD,SAAO;AAACA,IAAAA,QAAQ,EAAT,QAAA;AAAWC,IAAAA,UAAU,EAArB,UAAA;AAAuBa,IAAAA,OAAO,EAAE,CAACA,OAAO,CAAPA,CAAO,CAAPA,GAAa,CAAd,CAAA,EAAkBA,OAAO,CAAPA,CAAO,CAAPA,GAAa,CAA/B,CAAA;AAAhC,GAAP;AACD;;AAGD,SAAA,4BAAA,CAAA,KAAA,EAAuE;AAAA,MAAhCd,QAAgC,GAAA,KAAA,CAAhCA,QAAgC;AAAA,MAAtBC,UAAsB,GAAA,KAAA,CAAtBA,UAAsB;AAAA,MAAVa,OAAU,GAAA,KAAA,CAAVA,OAAU;AACrE,MAAMZ,IAAI,GAAG,IAAA,KAAA,CAAUkC,MAAM,CAANA,IAAAA,CAAAA,QAAAA,EAAvB,MAAa,CAAb;AACA,MAAIC,CAAC,GAAL,CAAA;;AACA,OAAK,IAAL,GAAA,IAAA,QAAA,EAA4B;AAC1B,QAAMC,IAAI,GAAGP,GAAG,CAAHA,KAAAA,CAAb,GAAaA,CAAb;AACA,QAAMI,MAAM,GAAGI,QAAQ,CAACD,IAAI,CAAL,CAAK,CAAL,EAAvB,EAAuB,CAAvB;AACA,QAAMJ,MAAM,GAAGK,QAAQ,CAACD,IAAI,CAAL,CAAK,CAAL,EAAvB,EAAuB,CAAvB;AACA,QAAME,KAAK,GAAGH,CAAd,EAAA;AAEAnC,IAAAA,IAAI,CAAJA,KAAI,CAAJA,GAAc,MAAM,CAAN,MAAA,CACZ;AACEsC,MAAAA,KAAK,EADP,KAAA;AAEEhB,MAAAA,QAAQ,EAAE,CACRV,OAAO,CAAPA,CAAO,CAAPA,GAAab,UAAU,CAAVA,OAAAA,GADL,MAAA,EAERa,OAAO,CAAPA,CAAO,CAAPA,GAAab,UAAU,CAAVA,OAAAA,GAFL,MAAA;AAFZ,KADY,EAQZD,QAAQ,CARVE,GAQU,CARI,CAAdA;AAUD;;AACD,SAAA,IAAA;AACD;;AAGD,SAAA,sBAAA,CAAA,iBAAA,EAAA,WAAA,EAAgE;AAE9D,MAAMQ,SAAS,GAAG+B,iBAAiB,CAAnC,KAAA;;AAF8D,MAAA,qBAAA,GAG/CA,iBAAiB,CAH8B,WAG/CA,EAH+C;AAAA,MAGvD9B,IAHuD,GAAA,qBAAA,CAAA,IAAA;;AAK9D,MAAI+B,IAAI,GAAR,QAAA;AACA,MAAIC,IAAI,GAAG,CAAX,QAAA;AACA,MAAIC,IAAI,GAAR,QAAA;AACA,MAAIC,IAAI,GAAG,CAAX,QAAA;AACA,MAAA,CAAA;AACA,MAAA,CAAA;;AAEA,OAAK,IAAIR,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,WAAA,EAAiCA,CAAjC,EAAA,EAAsC;AACpCX,IAAAA,CAAC,GAAGhB,SAAS,CAAC2B,CAAC,GAAfX,IAAa,CAAbA;AACAC,IAAAA,CAAC,GAAGjB,SAAS,CAAC2B,CAAC,GAADA,IAAAA,GAAdV,CAAa,CAAbA;;AACA,QAAIC,MAAM,CAANA,QAAAA,CAAAA,CAAAA,KAAsBA,MAAM,CAANA,QAAAA,CAA1B,CAA0BA,CAA1B,EAA8C;AAC5Cc,MAAAA,IAAI,GAAGf,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPe,IAAAA;AACAC,MAAAA,IAAI,GAAGhB,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPgB,IAAAA;AACAC,MAAAA,IAAI,GAAGlB,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPkB,IAAAA;AACAC,MAAAA,IAAI,GAAGnB,CAAC,GAADA,IAAAA,GAAAA,CAAAA,GAAPmB,IAAAA;AACD;AACF;;AAED,SAAO;AAACD,IAAAA,IAAI,EAAL,IAAA;AAAOC,IAAAA,IAAI,EAAX,IAAA;AAAaH,IAAAA,IAAI,EAAjB,IAAA;AAAmBC,IAAAA,IAAI,EAAJA;AAAnB,GAAP;AACD","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {createIterable} from '@deck.gl/core';\nimport {getGridOffset} from '../utils/grid-aggregation-utils';\n\n/**\n * Calculate density grid from an array of points\n * @param {Object} props - object containing :\n * @param {Iterable} [props.data] - data objects to be aggregated\n * @param {Integer} [props.cellSize] - size of the grid cell\n *\n * @param {Object} aggregationParams - object containing :\n * @param {Object} gridOffset - {xOffset, yOffset} cell size in meters\n * @param {Integer} width - width of the grid\n * @param {Integer} height - height of the grid\n * @param {Boolean} projectPoints - `true` if doing screen space projection, `false` otherwise\n * @param {Array} attributes - attributes array containing position values\n * @param {Viewport} viewport - viewport to be used for projection\n * @param {Array} posOffset - [xOffset, yOffset] offset to be applied to positions to get cell index\n * @param {Object} boundingBox - {xMin, yMin, xMax, yMax} bounding box of input data\n *\n * @returns {object} - grid data, cell dimension\n */\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  const hashInfo = pointsToGridHashing(props, aggregationParams);\n  const result = getGridLayerDataFromGridHash(hashInfo);\n\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {Iterable} points\n * @param {number} cellSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\n/* eslint-disable max-statements, complexity */\nfunction pointsToGridHashing(props, aggregationParams) {\n  const {data = [], cellSize} = props;\n  const {attributes, viewport, projectPoints, numInstances} = aggregationParams;\n  const positions = attributes.positions.value;\n  const {size} = attributes.positions.getAccessor();\n  const boundingBox =\n    aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  const offsets = aggregationParams.posOffset || [180, 90];\n  const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {gridHash: {}, gridOffset};\n  }\n\n  const {width, height} = viewport;\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n\n  // calculate count per cell\n  const gridHash = {};\n\n  const {iterable, objectInfo} = createIterable(data);\n  const position = new Array(3);\n  for (const pt of iterable) {\n    objectInfo.index++;\n    position[0] = positions[objectInfo.index * size];\n    position[1] = positions[objectInfo.index * size + 1];\n    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n    const [x, y] = projectPoints ? viewport.project(position) : position;\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n      if (\n        !projectPoints ||\n        // when doing screen space agggregation (projectPoints = true), filter points outside of the viewport range.\n        (xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow)\n      ) {\n        const key = `${yIndex}-${xIndex}`;\n\n        gridHash[key] = gridHash[key] || {count: 0, points: [], lonIdx: xIndex, latIdx: yIndex};\n        gridHash[key].count += 1;\n        gridHash[key].points.push(pt);\n      }\n    }\n  }\n\n  return {gridHash, gridOffset, offsets: [offsets[0] * -1, offsets[1] * -1]};\n}\n/* eslint-enable max-statements, complexity */\n\nfunction getGridLayerDataFromGridHash({gridHash, gridOffset, offsets}) {\n  const data = new Array(Object.keys(gridHash).length);\n  let i = 0;\n  for (const key in gridHash) {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const index = i++;\n\n    data[index] = Object.assign(\n      {\n        index,\n        position: [\n          offsets[0] + gridOffset.xOffset * lonIdx,\n          offsets[1] + gridOffset.yOffset * latIdx\n        ]\n      },\n      gridHash[key]\n    );\n  }\n  return data;\n}\n\n// Calculate bounding box of position attribute\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  // TODO - value might not exist (e.g. attribute transition)\n  const positions = positionAttribute.value;\n  const {size} = positionAttribute.getAccessor();\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {xMin, xMax, yMin, yMax};\n}\n"]},"metadata":{},"sourceType":"module"}