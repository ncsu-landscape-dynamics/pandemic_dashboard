{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { Deck, WebMercatorViewport } from '@deck.gl/core';\nexport function getDeckInstance(_ref) {\n  var map = _ref.map,\n      gl = _ref.gl,\n      deck = _ref.deck;\n\n  if (map.__deck) {\n    return map.__deck;\n  }\n\n  var customRender = deck && deck.props._customRender;\n  var deckProps = {\n    useDevicePixels: true,\n    _customRender: function _customRender() {\n      map.triggerRepaint();\n\n      if (customRender) {\n        customRender();\n      }\n    },\n    parameters: {\n      depthMask: true,\n      depthTest: true,\n      blendFunc: [770, 771, 1, 771],\n      blendEquation: 32774\n    },\n    userData: {\n      isExternal: false,\n      mapboxLayers: new Set()\n    }\n  };\n\n  if (deck) {\n    deck.setProps(deckProps);\n    deck.props.userData.isExternal = true;\n  } else {\n    Object.assign(deckProps, {\n      gl: gl,\n      width: false,\n      height: false,\n      viewState: getViewState(map)\n    });\n    deck = new Deck(deckProps);\n    map.on('move', function () {\n      return onMapMove(deck, map);\n    });\n    map.on('remove', function () {\n      deck.finalize();\n      map.__deck = null;\n    });\n  }\n\n  deck.props.userData.mapboxVersion = getMapboxVersion(map);\n  map.__deck = deck;\n  map.on('render', function () {\n    if (deck.layerManager) afterRender(deck, map);\n  });\n  return deck;\n}\nexport function addLayer(deck, layer) {\n  deck.props.userData.mapboxLayers.add(layer);\n  updateLayers(deck);\n}\nexport function removeLayer(deck, layer) {\n  deck.props.userData.mapboxLayers[\"delete\"](layer);\n  updateLayers(deck);\n}\nexport function updateLayer(deck, layer) {\n  updateLayers(deck);\n}\nexport function drawLayer(deck, map, layer) {\n  var currentViewport = deck.props.userData.currentViewport;\n\n  if (!currentViewport) {\n    currentViewport = getViewport(deck, map, true);\n    deck.props.userData.currentViewport = currentViewport;\n  }\n\n  if (!deck.layerManager) {\n    return;\n  }\n\n  deck._drawLayers('mapbox-repaint', {\n    viewports: [currentViewport],\n    layers: getLayers(deck, function (deckLayer) {\n      return shouldDrawLayer(layer.id, deckLayer);\n    }),\n    clearCanvas: false\n  });\n}\n\nfunction getViewState(map) {\n  var _map$getCenter = map.getCenter(),\n      lng = _map$getCenter.lng,\n      lat = _map$getCenter.lat;\n\n  return {\n    longitude: lng,\n    latitude: lat,\n    zoom: map.getZoom(),\n    bearing: map.getBearing(),\n    pitch: map.getPitch()\n  };\n}\n\nfunction getMapboxVersion(map) {\n  var major = 0;\n  var minor = 0;\n\n  if (map.version) {\n    var _map$version$split$sl = map.version.split('.').slice(0, 2).map(Number);\n\n    var _map$version$split$sl2 = _slicedToArray(_map$version$split$sl, 2);\n\n    major = _map$version$split$sl2[0];\n    minor = _map$version$split$sl2[1];\n  }\n\n  return {\n    major: major,\n    minor: minor\n  };\n}\n\nfunction getViewport(deck, map) {\n  var useMapboxProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var mapboxVersion = deck.props.userData.mapboxVersion;\n  return new WebMercatorViewport(Object.assign({\n    x: 0,\n    y: 0,\n    width: deck.width,\n    height: deck.height,\n    repeat: true\n  }, getViewState(map), useMapboxProjection ? {\n    nearZMultiplier: mapboxVersion.major === 1 && mapboxVersion.minor >= 3 || mapboxVersion.major >= 2 ? 0.02 : 1 / (deck.height || 1)\n  } : {\n    nearZMultiplier: 0.1\n  }));\n}\n\nfunction afterRender(deck, map) {\n  var _deck$props$userData = deck.props.userData,\n      mapboxLayers = _deck$props$userData.mapboxLayers,\n      isExternal = _deck$props$userData.isExternal;\n\n  if (isExternal) {\n    var mapboxLayerIds = Array.from(mapboxLayers, function (layer) {\n      return layer.id;\n    });\n    var layers = getLayers(deck, function (deckLayer) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = mapboxLayerIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var id = _step.value;\n\n          if (shouldDrawLayer(id, deckLayer)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    });\n\n    if (layers.length > 0) {\n      deck._drawLayers('mapbox-repaint', {\n        viewports: [getViewport(deck, map, false)],\n        layers: layers,\n        clearCanvas: false\n      });\n    }\n  }\n\n  deck.props.userData.currentViewport = null;\n}\n\nfunction onMapMove(deck, map) {\n  deck.setProps({\n    viewState: getViewState(map)\n  });\n  deck.needsRedraw({\n    clearRedrawFlags: true\n  });\n}\n\nfunction getLayers(deck, layerFilter) {\n  var layers = deck.layerManager.getLayers();\n  return layers.filter(layerFilter);\n}\n\nfunction shouldDrawLayer(id, layer) {\n  var layerInstance = layer;\n\n  while (layerInstance) {\n    if (layerInstance.id === id) {\n      return true;\n    }\n\n    layerInstance = layerInstance.parent;\n  }\n\n  return false;\n}\n\nfunction updateLayers(deck) {\n  if (deck.props.userData.isExternal) {\n    return;\n  }\n\n  var layers = [];\n  deck.props.userData.mapboxLayers.forEach(function (deckLayer) {\n    var LayerType = deckLayer.props.type;\n    var layer = new LayerType(deckLayer.props);\n    layers.push(layer);\n  });\n  deck.setProps({\n    layers: layers\n  });\n}","map":{"version":3,"sources":["../../src/deck-utils.js"],"names":["map","gl","deck","customRender","deckProps","useDevicePixels","_customRender","parameters","depthMask","depthTest","blendFunc","blendEquation","userData","isExternal","mapboxLayers","Object","width","height","viewState","getViewState","onMapMove","getMapboxVersion","afterRender","updateLayers","currentViewport","getViewport","viewports","layers","getLayers","shouldDrawLayer","layer","clearCanvas","lng","lat","longitude","latitude","zoom","bearing","pitch","major","minor","useMapboxProjection","mapboxVersion","x","y","repeat","nearZMultiplier","mapboxLayerIds","id","clearRedrawFlags","layerInstance","LayerType","deckLayer"],"mappings":"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","sourcesContent":["import {Deck, WebMercatorViewport} from '@deck.gl/core';\n\nexport function getDeckInstance({map, gl, deck}) {\n  // Only create one deck instance per context\n  if (map.__deck) {\n    return map.__deck;\n  }\n\n  const customRender = deck && deck.props._customRender;\n\n  const deckProps = {\n    useDevicePixels: true,\n    _customRender: () => {\n      map.triggerRepaint();\n      if (customRender) {\n        // customRender may be subscribed by DeckGL React component to update child props\n        // make sure it is still called\n        customRender();\n      }\n    },\n    // TODO: import these defaults from a single source of truth\n    parameters: {\n      depthMask: true,\n      depthTest: true,\n      blendFunc: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA],\n      blendEquation: gl.FUNC_ADD\n    },\n    userData: {\n      isExternal: false,\n      mapboxLayers: new Set()\n    }\n  };\n\n  if (deck) {\n    deck.setProps(deckProps);\n    deck.props.userData.isExternal = true;\n  } else {\n    // Using external gl context - do not set css size\n    Object.assign(deckProps, {\n      gl,\n      width: false,\n      height: false,\n      viewState: getViewState(map)\n    });\n    deck = new Deck(deckProps);\n\n    // If deck is externally provided (React use case), we use deck's viewState to\n    // drive the map.\n    // Otherwise (pure JS use case), we use the map's viewState to drive deck.\n    map.on('move', () => onMapMove(deck, map));\n    map.on('remove', () => {\n      deck.finalize();\n      map.__deck = null;\n    });\n  }\n  deck.props.userData.mapboxVersion = getMapboxVersion(map);\n  map.__deck = deck;\n  map.on('render', () => {\n    if (deck.layerManager) afterRender(deck, map);\n  });\n\n  return deck;\n}\n\nexport function addLayer(deck, layer) {\n  deck.props.userData.mapboxLayers.add(layer);\n  updateLayers(deck);\n}\n\nexport function removeLayer(deck, layer) {\n  deck.props.userData.mapboxLayers.delete(layer);\n  updateLayers(deck);\n}\n\nexport function updateLayer(deck, layer) {\n  updateLayers(deck);\n}\n\nexport function drawLayer(deck, map, layer) {\n  let {currentViewport} = deck.props.userData;\n  if (!currentViewport) {\n    // This is the first layer drawn in this render cycle.\n    // Generate viewport from the current map state.\n    currentViewport = getViewport(deck, map, true);\n    deck.props.userData.currentViewport = currentViewport;\n  }\n  if (!deck.layerManager) {\n    return;\n  }\n  deck._drawLayers('mapbox-repaint', {\n    viewports: [currentViewport],\n    // TODO - accept layerFilter in drawLayers' renderOptions\n    layers: getLayers(deck, deckLayer => shouldDrawLayer(layer.id, deckLayer)),\n    clearCanvas: false\n  });\n}\n\nfunction getViewState(map) {\n  const {lng, lat} = map.getCenter();\n  return {\n    longitude: lng,\n    latitude: lat,\n    zoom: map.getZoom(),\n    bearing: map.getBearing(),\n    pitch: map.getPitch()\n  };\n}\n\nfunction getMapboxVersion(map) {\n  // parse mapbox version string\n  let major = 0;\n  let minor = 0;\n  if (map.version) {\n    [major, minor] = map.version\n      .split('.')\n      .slice(0, 2)\n      .map(Number);\n  }\n  return {major, minor};\n}\n\nfunction getViewport(deck, map, useMapboxProjection = true) {\n  const {mapboxVersion} = deck.props.userData;\n\n  return new WebMercatorViewport(\n    Object.assign(\n      {\n        x: 0,\n        y: 0,\n        width: deck.width,\n        height: deck.height,\n        repeat: true\n      },\n      getViewState(map),\n      useMapboxProjection\n        ? {\n            // match mapbox's projection matrix\n            // A change of near plane was made in 1.3.0\n            // https://github.com/mapbox/mapbox-gl-js/pull/8502\n            nearZMultiplier:\n              (mapboxVersion.major === 1 && mapboxVersion.minor >= 3) || mapboxVersion.major >= 2\n                ? 0.02\n                : 1 / (deck.height || 1)\n          }\n        : {\n            // use deck.gl's own default\n            nearZMultiplier: 0.1\n          }\n    )\n  );\n}\n\nfunction afterRender(deck, map) {\n  const {mapboxLayers, isExternal} = deck.props.userData;\n\n  if (isExternal) {\n    // Draw non-Mapbox layers\n    const mapboxLayerIds = Array.from(mapboxLayers, layer => layer.id);\n    const layers = getLayers(deck, deckLayer => {\n      for (const id of mapboxLayerIds) {\n        if (shouldDrawLayer(id, deckLayer)) {\n          return false;\n        }\n      }\n      return true;\n    });\n    if (layers.length > 0) {\n      deck._drawLayers('mapbox-repaint', {\n        viewports: [getViewport(deck, map, false)],\n        layers,\n        clearCanvas: false\n      });\n    }\n  }\n\n  // End of render cycle, clear generated viewport\n  deck.props.userData.currentViewport = null;\n}\n\nfunction onMapMove(deck, map) {\n  deck.setProps({\n    viewState: getViewState(map)\n  });\n  // Camera changed, will trigger a map repaint right after this\n  // Clear any change flag triggered by setting viewState so that deck does not request\n  // a second repaint\n  deck.needsRedraw({clearRedrawFlags: true});\n}\n\nfunction getLayers(deck, layerFilter) {\n  const layers = deck.layerManager.getLayers();\n  return layers.filter(layerFilter);\n}\n\nfunction shouldDrawLayer(id, layer) {\n  let layerInstance = layer;\n  while (layerInstance) {\n    if (layerInstance.id === id) {\n      return true;\n    }\n    layerInstance = layerInstance.parent;\n  }\n  return false;\n}\n\nfunction updateLayers(deck) {\n  if (deck.props.userData.isExternal) {\n    return;\n  }\n\n  const layers = [];\n  deck.props.userData.mapboxLayers.forEach(deckLayer => {\n    const LayerType = deckLayer.props.type;\n    const layer = new LayerType(deckLayer.props);\n    layers.push(layer);\n  });\n  deck.setProps({layers});\n}\n"]},"metadata":{},"sourceType":"module"}