{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { LineLayer, SolidPolygonLayer } from '@deck.gl/layers';\nimport { generateContours } from './contour-utils';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nvar DEFAULT_COLOR = [255, 255, 255, 255];\nvar DEFAULT_STROKE_WIDTH = 1;\nvar DEFAULT_THRESHOLD = 1;\nvar defaultProps = {\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getWeight: {\n    type: 'accessor',\n    value: function value(x) {\n      return 1;\n    }\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM',\n  contours: [{\n    threshold: DEFAULT_THRESHOLD\n  }],\n  zOffset: 0.005\n};\nvar POSITION_ATTRIBUTE_NAME = 'positions';\nvar DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\nvar ContourLayer = function (_GridAggregationLayer) {\n  _inherits(ContourLayer, _GridAggregationLayer);\n\n  function ContourLayer() {\n    _classCallCheck(this, ContourLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ContourLayer).apply(this, arguments));\n  }\n\n  _createClass(ContourLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _attributeManager$add;\n\n      _get(_getPrototypeOf(ContourLayer.prototype), \"initializeState\", this).call(this, {\n        dimensions: DIMENSIONS\n      });\n\n      this.setState({\n        contourData: {},\n        projectPoints: false,\n        weights: {\n          count: {\n            size: 1,\n            operation: AGGREGATION_OPERATION.SUM\n          }\n        }\n      });\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add((_attributeManager$add = {}, _defineProperty(_attributeManager$add, POSITION_ATTRIBUTE_NAME, {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      }), _defineProperty(_attributeManager$add, \"count\", {\n        size: 3,\n        accessor: 'getWeight'\n      }), _attributeManager$add));\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(ContourLayer.prototype), \"updateState\", this).call(this, opts);\n\n      var contoursChanged = false;\n      var oldProps = opts.oldProps,\n          props = opts.props;\n      var aggregationDirty = this.state.aggregationDirty;\n\n      if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n        contoursChanged = true;\n\n        this._updateThresholdData(opts.props);\n      }\n\n      if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n        this._generateContours();\n      }\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$state$contourDa = this.state.contourData,\n          contourSegments = _this$state$contourDa.contourSegments,\n          contourPolygons = _this$state$contourDa.contourPolygons;\n      var LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n      var BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n      var lineLayer = contourSegments && contourSegments.length > 0 && new LinesSubLayerClass(this.getSubLayerProps({\n        id: 'lines'\n      }), {\n        data: this.state.contourData.contourSegments,\n        getSourcePosition: function getSourcePosition(d) {\n          return d.start;\n        },\n        getTargetPosition: function getTargetPosition(d) {\n          return d.end;\n        },\n        getColor: function getColor(d) {\n          return d.contour.color || DEFAULT_COLOR;\n        },\n        getWidth: function getWidth(d) {\n          return d.contour.strokeWidth || DEFAULT_STROKE_WIDTH;\n        }\n      });\n      var bandsLayer = contourPolygons && contourPolygons.length > 0 && new BandsSubLayerClass(this.getSubLayerProps({\n        id: 'bands'\n      }), {\n        data: this.state.contourData.contourPolygons,\n        getPolygon: function getPolygon(d) {\n          return d.vertices;\n        },\n        getFillColor: function getFillColor(d) {\n          return d.contour.color || DEFAULT_COLOR;\n        }\n      });\n      return [lineLayer, bandsLayer];\n    }\n  }, {\n    key: \"updateAggregationState\",\n    value: function updateAggregationState(opts) {\n      var props = opts.props,\n          oldProps = opts.oldProps;\n      var cellSize = props.cellSize,\n          coordinateSystem = props.coordinateSystem;\n      var viewport = this.context.viewport;\n      var cellSizeChanged = oldProps.cellSize !== cellSize;\n      var gpuAggregation = props.gpuAggregation;\n\n      if (this.state.gpuAggregation !== props.gpuAggregation) {\n        if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n          log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n          gpuAggregation = false;\n        }\n      }\n\n      var gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n      this.setState({\n        gpuAggregation: gpuAggregation\n      });\n      var dimensions = this.state.dimensions;\n      var positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n      var data = dimensions.data,\n          weights = dimensions.weights;\n      var boundingBox = this.state.boundingBox;\n\n      if (positionsChanged) {\n        boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n        this.setState({\n          boundingBox: boundingBox\n        });\n      }\n\n      if (positionsChanged || cellSizeChanged) {\n        var _getGridParams = getGridParams(boundingBox, cellSize, viewport, coordinateSystem),\n            gridOffset = _getGridParams.gridOffset,\n            translation = _getGridParams.translation,\n            width = _getGridParams.width,\n            height = _getGridParams.height,\n            numCol = _getGridParams.numCol,\n            numRow = _getGridParams.numRow;\n\n        this.allocateResources(numRow, numCol);\n        this.setState({\n          gridOffset: gridOffset,\n          boundingBox: boundingBox,\n          translation: translation,\n          posOffset: translation.slice(),\n          gridOrigin: [-1 * translation[0], -1 * translation[1]],\n          width: width,\n          height: height,\n          numCol: numCol,\n          numRow: numRow\n        });\n      }\n\n      var aggregationDataDirty = positionsChanged || gpuAggregationChanged || this.isAggregationDirty(opts, {\n        dimension: data,\n        compareAll: gpuAggregation\n      });\n      var aggregationWeightsDirty = this.isAggregationDirty(opts, {\n        dimension: weights\n      });\n\n      if (aggregationWeightsDirty) {\n        this._updateAccessors(opts);\n      }\n\n      if (aggregationDataDirty || aggregationWeightsDirty) {\n        this._resetResults();\n      }\n\n      this.setState({\n        aggregationDataDirty: aggregationDataDirty,\n        aggregationWeightsDirty: aggregationWeightsDirty\n      });\n    }\n  }, {\n    key: \"_updateAccessors\",\n    value: function _updateAccessors(opts) {\n      var _opts$props = opts.props,\n          getWeight = _opts$props.getWeight,\n          aggregation = _opts$props.aggregation;\n      var count = this.state.weights.count;\n\n      if (count) {\n        count.getWeight = getWeight;\n        count.operation = AGGREGATION_OPERATION[aggregation];\n      }\n\n      this.setState({\n        getValue: getValueFunc(aggregation, getWeight)\n      });\n    }\n  }, {\n    key: \"_resetResults\",\n    value: function _resetResults() {\n      var count = this.state.weights.count;\n\n      if (count) {\n        count.aggregationData = null;\n      }\n    }\n  }, {\n    key: \"_generateContours\",\n    value: function _generateContours() {\n      var _this$state = this.state,\n          numCol = _this$state.numCol,\n          numRow = _this$state.numRow,\n          gridOrigin = _this$state.gridOrigin,\n          gridOffset = _this$state.gridOffset,\n          thresholdData = _this$state.thresholdData;\n      var count = this.state.weights.count;\n      var aggregationData = count.aggregationData;\n\n      if (!aggregationData) {\n        aggregationData = count.aggregationBuffer.getData();\n        count.aggregationData = aggregationData;\n      }\n\n      var _GPUGridAggregator$ge = GPUGridAggregator.getCellData({\n        countsData: aggregationData\n      }),\n          cellWeights = _GPUGridAggregator$ge.cellWeights;\n\n      var contourData = generateContours({\n        thresholdData: thresholdData,\n        cellWeights: cellWeights,\n        gridSize: [numCol, numRow],\n        gridOrigin: gridOrigin,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n      });\n      this.setState({\n        contourData: contourData\n      });\n    }\n  }, {\n    key: \"_updateThresholdData\",\n    value: function _updateThresholdData(props) {\n      var contours = props.contours,\n          zOffset = props.zOffset;\n      var count = contours.length;\n      var thresholdData = new Array(count);\n\n      for (var i = 0; i < count; i++) {\n        var contour = contours[i];\n        thresholdData[i] = {\n          contour: contour,\n          zIndex: contour.zIndex || i,\n          zOffset: zOffset\n        };\n      }\n\n      this.setState({\n        thresholdData: thresholdData\n      });\n    }\n  }]);\n\n  return ContourLayer;\n}(GridAggregationLayer);\n\nexport { ContourLayer as default };\nContourLayer.layerName = 'ContourLayer';\nContourLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/contour-layer/contour-layer.js"],"names":["DEFAULT_COLOR","DEFAULT_STROKE_WIDTH","DEFAULT_THRESHOLD","defaultProps","cellSize","type","min","max","value","getPosition","x","getWeight","gpuAggregation","aggregation","contours","threshold","zOffset","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ContourLayer","GridAggregationLayer","dimensions","contourData","projectPoints","count","size","operation","AGGREGATION_OPERATION","SUM","attributeManager","accessor","fp64","opts","contoursChanged","oldProps","aggregationDirty","contourSegments","contourPolygons","LinesSubLayerClass","BandsSubLayerClass","lineLayer","id","getSourcePosition","d","getTargetPosition","getColor","getWidth","bandsLayer","getPolygon","getFillColor","coordinateSystem","viewport","cellSizeChanged","GPUGridAggregator","log","gpuAggregationChanged","positionsChanged","boundingBox","getBoundingBox","gridOffset","translation","width","height","numCol","numRow","getGridParams","posOffset","gridOrigin","aggregationDataDirty","dimension","compareAll","aggregationWeightsDirty","getValue","getValueFunc","thresholdData","aggregationData","cellWeights","countsData","generateContours","gridSize","i","contour","zIndex"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {LineLayer, SolidPolygonLayer} from '@deck.gl/layers';\nimport {generateContours} from './contour-utils';\nimport {log} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer from '../grid-aggregation-layer';\n\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_THRESHOLD = 1;\n\nconst defaultProps = {\n  // grid aggregation\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getWeight: {type: 'accessor', value: x => 1},\n  gpuAggregation: true,\n  aggregation: 'SUM',\n\n  // contour lines\n  contours: [{threshold: DEFAULT_THRESHOLD}],\n\n  zOffset: 0.005\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\nexport default class ContourLayer extends GridAggregationLayer {\n  initializeState() {\n    super.initializeState({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      contourData: {},\n      projectPoints: false,\n      weights: {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM\n        }\n      }\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    let contoursChanged = false;\n    const {oldProps, props} = opts;\n    const {aggregationDirty} = this.state;\n\n    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n      contoursChanged = true;\n      this._updateThresholdData(opts.props);\n    }\n\n    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n      this._generateContours();\n    }\n  }\n\n  renderLayers() {\n    const {contourSegments, contourPolygons} = this.state.contourData;\n\n    const LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n\n    // Contour lines layer\n    const lineLayer =\n      contourSegments &&\n      contourSegments.length > 0 &&\n      new LinesSubLayerClass(\n        this.getSubLayerProps({\n          id: 'lines'\n        }),\n        {\n          data: this.state.contourData.contourSegments,\n          getSourcePosition: d => d.start,\n          getTargetPosition: d => d.end,\n          getColor: d => d.contour.color || DEFAULT_COLOR,\n          getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH\n        }\n      );\n\n    // Contour bands layer\n    const bandsLayer =\n      contourPolygons &&\n      contourPolygons.length > 0 &&\n      new BandsSubLayerClass(\n        this.getSubLayerProps({\n          id: 'bands'\n        }),\n        {\n          data: this.state.contourData.contourPolygons,\n          getPolygon: d => d.vertices,\n          getFillColor: d => d.contour.color || DEFAULT_COLOR\n        }\n      );\n\n    return [lineLayer, bandsLayer];\n  }\n\n  // Aggregation Overrides\n\n  /* eslint-disable max-statements, complexity */\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    let gpuAggregation = props.gpuAggregation;\n    if (this.state.gpuAggregation !== props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const {dimensions} = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {data, weights} = dimensions;\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        boundingBox,\n        translation,\n        posOffset: translation.slice(), // Used for CPU aggregation, to offset points\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: data,\n        compareAll: gpuAggregation // check for all (including extentions props) when using gpu aggregation\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n  }\n  /* eslint-enable max-statements, complexity */\n\n  // Private (Aggregation)\n\n  _updateAccessors(opts) {\n    const {getWeight, aggregation} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight)});\n  }\n\n  _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n  // Private (Contours)\n\n  _generateContours() {\n    const {numCol, numRow, gridOrigin, gridOffset, thresholdData} = this.state;\n    const {count} = this.state.weights;\n    let {aggregationData} = count;\n    if (!aggregationData) {\n      aggregationData = count.aggregationBuffer.getData();\n      count.aggregationData = aggregationData;\n    }\n\n    const {cellWeights} = GPUGridAggregator.getCellData({countsData: aggregationData});\n    const contourData = generateContours({\n      thresholdData,\n      cellWeights,\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n    });\n\n    // contourData contains both iso-lines and iso-bands if requested.\n    this.setState({contourData});\n  }\n\n  _updateThresholdData(props) {\n    const {contours, zOffset} = props;\n    const count = contours.length;\n    const thresholdData = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const contour = contours[i];\n      thresholdData[i] = {\n        contour,\n        zIndex: contour.zIndex || i,\n        zOffset\n      };\n    }\n    this.setState({thresholdData});\n  }\n}\n\nContourLayer.layerName = 'ContourLayer';\nContourLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}