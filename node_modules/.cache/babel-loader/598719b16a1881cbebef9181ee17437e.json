{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { load } from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\nimport { lodJudge } from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\n\nvar I3STilesetTraverser = function (_TilesetTraverser) {\n  _inherits(I3STilesetTraverser, _TilesetTraverser);\n\n  var _super = _createSuper(I3STilesetTraverser);\n\n  function I3STilesetTraverser(options) {\n    var _this;\n\n    _classCallCheck(this, I3STilesetTraverser);\n\n    _this = _super.call(this, options);\n    _this._tileManager = new I3STileManager();\n    return _this;\n  }\n\n  _createClass(I3STilesetTraverser, [{\n    key: \"shouldRefine\",\n    value: function shouldRefine(tile, frameState) {\n      tile._lodJudge = lodJudge(tile, frameState);\n      return tile._lodJudge === 'DIG';\n    }\n  }, {\n    key: \"updateChildTiles\",\n    value: function updateChildTiles(tile, frameState) {\n      var _this2 = this;\n\n      var children = tile.header.children || [];\n      var childTiles = tile.children;\n      var tileset = tile.tileset;\n\n      var _iterator = _createForOfIteratorHelper(children),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var child = _step.value;\n          var childTile = childTiles && childTiles.find(function (t) {\n            return t.id === child.id;\n          });\n\n          if (!childTile) {\n            var request = function request() {\n              return _this2._loadTile(child.id, tileset);\n            };\n\n            var cachedRequest = _this2._tileManager.find(child.id);\n\n            if (!cachedRequest) {\n              _this2._tileManager.add(request, child.id, function (header) {\n                return _this2._onTileLoad(header, tile);\n              }, frameState);\n            } else {\n              _this2._tileManager.update(child.id, frameState);\n            }\n          } else if (childTile) {\n            _this2.updateTile(childTile, frameState);\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_loadTile\",\n    value: function () {\n      var _loadTile2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(nodeId, tileset) {\n        var loader, nodeUrl, options;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                loader = tileset.loader;\n                nodeUrl = tileset.getTileUrl(\"\".concat(tileset.url, \"/nodes/\").concat(nodeId));\n                options = {\n                  i3s: _objectSpread(_objectSpread({}, tileset.fetchOptions), {}, {\n                    isHeader: true,\n                    loadContent: false\n                  })\n                };\n                _context.next = 5;\n                return load(nodeUrl, loader, options);\n\n              case 5:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function _loadTile(_x, _x2) {\n        return _loadTile2.apply(this, arguments);\n      }\n\n      return _loadTile;\n    }()\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(header, tile) {\n      var basePath = this.options.basePath;\n      var childTile = new TileHeader(tile.tileset, header, tile, basePath);\n      tile.children.push(childTile);\n\n      var frameState = this._tileManager.find(childTile.id).frameState;\n\n      this.updateTile(childTile, frameState);\n\n      if (this._frameNumber === frameState.frameNumber) {\n        this.executeTraversal(childTile, frameState);\n      }\n    }\n  }]);\n\n  return I3STilesetTraverser;\n}(TilesetTraverser);\n\nexport { I3STilesetTraverser as default };","map":{"version":3,"sources":["../../../../src/tileset/traversers/i3s-tilset-traverser.js"],"names":["I3STilesetTraverser","TilesetTraverser","tile","frameState","lodJudge","children","childTiles","tileset","child","childTile","t","request","cachedRequest","nodeId","loader","nodeUrl","options","i3s","isHeader","loadContent","load","header","basePath"],"mappings":"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","sourcesContent":["import {load} from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\n\nimport {lodJudge} from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\n\nexport default class I3STilesetTraverser extends TilesetTraverser {\n  constructor(options) {\n    super(options);\n    this._tileManager = new I3STileManager();\n  }\n\n  shouldRefine(tile, frameState) {\n    // TODO refactor loaJudge\n    tile._lodJudge = lodJudge(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  // eslint-disable-next-line complexity\n  updateChildTiles(tile, frameState) {\n    const children = tile.header.children || [];\n    // children which are already fetched and constructed as Tile3D instances\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      // if child tile is not fetched\n      const childTile = childTiles && childTiles.find(t => t.id === child.id);\n      if (!childTile) {\n        const request = () => this._loadTile(child.id, tileset);\n        const cachedRequest = this._tileManager.find(child.id);\n        if (!cachedRequest) {\n          this._tileManager.add(\n            request,\n            child.id,\n            header => this._onTileLoad(header, tile),\n            frameState\n          );\n        } else {\n          // update frameNumber since it is still needed in current frame\n          this._tileManager.update(child.id, frameState);\n        }\n      } else if (childTile) {\n        // if child tile is fetched and available\n        this.updateTile(childTile, frameState);\n      }\n    }\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {loader} = tileset;\n    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n    // load metadata\n    const options = {\n      i3s: {\n        ...tileset.fetchOptions,\n        isHeader: true,\n        loadContent: false\n      }\n    };\n    return await load(nodeUrl, loader, options);\n  }\n\n  _onTileLoad(header, tile) {\n    const basePath = this.options.basePath;\n    // after child tile is fetched\n    const childTile = new TileHeader(tile.tileset, header, tile, basePath);\n    tile.children.push(childTile);\n    const frameState = this._tileManager.find(childTile.id).frameState;\n    this.updateTile(childTile, frameState);\n\n    // after tile fetched, resume traversal if still in current update/traversal frame\n    if (this._frameNumber === frameState.frameNumber) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}