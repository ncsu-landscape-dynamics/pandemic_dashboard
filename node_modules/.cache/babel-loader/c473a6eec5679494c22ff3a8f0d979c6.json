{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getFloatTexture } from '../utils/resource-utils.js';\nvar defaultProps = Object.assign({}, ScreenGridCellLayer.defaultProps, {\n  getPosition: {\n    type: 'accessor',\n    value: function value(d) {\n      return d.position;\n    }\n  },\n  getWeight: {\n    type: 'accessor',\n    value: function value(d) {\n      return 1;\n    }\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n});\nvar POSITION_ATTRIBUTE_NAME = 'positions';\nvar DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\nvar ScreenGridLayer = function (_GridAggregationLayer) {\n  _inherits(ScreenGridLayer, _GridAggregationLayer);\n\n  function ScreenGridLayer() {\n    _classCallCheck(this, ScreenGridLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScreenGridLayer).apply(this, arguments));\n  }\n\n  _createClass(ScreenGridLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _attributeManager$add;\n\n      var gl = this.context.gl;\n\n      if (!ScreenGridCellLayer.isSupported(gl)) {\n        this.setState({\n          supported: false\n        });\n        log.error(\"ScreenGridLayer: \".concat(this.id, \" is not supported on this browser\"))();\n        return;\n      }\n\n      _get(_getPrototypeOf(ScreenGridLayer.prototype), \"initializeState\", this).call(this, {\n        dimensions: DIMENSIONS,\n        getCellSize: function getCellSize(props) {\n          return props.cellSizePixels;\n        }\n      });\n\n      var weights = {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM,\n          needMax: true,\n          maxTexture: getFloatTexture(gl, {\n            id: \"\".concat(this.id, \"-max-texture\")\n          })\n        }\n      };\n      this.setState({\n        supported: true,\n        projectPoints: true,\n        weights: weights,\n        subLayerData: {\n          attributes: {}\n        },\n        maxTexture: weights.count.maxTexture,\n        positionAttributeName: 'positions',\n        posOffset: [0, 0],\n        translation: [1, -1]\n      });\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add((_attributeManager$add = {}, _defineProperty(_attributeManager$add, POSITION_ATTRIBUTE_NAME, {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      }), _defineProperty(_attributeManager$add, \"count\", {\n        size: 3,\n        accessor: 'getWeight'\n      }), _attributeManager$add));\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return this.state.supported && changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(ScreenGridLayer.prototype), \"updateState\", this).call(this, opts);\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      if (!this.state.supported) {\n        return [];\n      }\n\n      var _this$state = this.state,\n          maxTexture = _this$state.maxTexture,\n          numRow = _this$state.numRow,\n          numCol = _this$state.numCol,\n          weights = _this$state.weights;\n      var updateTriggers = this.props.updateTriggers;\n      var aggregationBuffer = weights.count.aggregationBuffer;\n      var CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n      return new CellLayerClass(this.props, this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers: updateTriggers\n      }), {\n        data: {\n          attributes: {\n            instanceCounts: aggregationBuffer\n          }\n        },\n        maxTexture: maxTexture,\n        numInstances: numRow * numCol\n      });\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      _get(_getPrototypeOf(ScreenGridLayer.prototype), \"finalizeState\", this).call(this);\n\n      var _this$state2 = this.state,\n          aggregationBuffer = _this$state2.aggregationBuffer,\n          maxBuffer = _this$state2.maxBuffer,\n          maxTexture = _this$state2.maxTexture;\n\n      if (aggregationBuffer) {\n        aggregationBuffer[\"delete\"]();\n      }\n\n      if (maxBuffer) {\n        maxBuffer[\"delete\"]();\n      }\n\n      if (maxTexture) {\n        maxTexture[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2) {\n      var info = _ref2.info,\n          mode = _ref2.mode;\n      var index = info.index;\n\n      if (index >= 0) {\n        var gpuGridAggregator = this.state.gpuGridAggregator;\n        var aggregationResults = gpuGridAggregator.getData('count');\n        info.object = GPUGridAggregator.getAggregationData(Object.assign({\n          pixelIndex: index\n        }, aggregationResults));\n      }\n\n      return info;\n    }\n  }, {\n    key: \"updateResults\",\n    value: function updateResults(_ref3) {\n      var aggregationData = _ref3.aggregationData,\n          maxData = _ref3.maxData;\n      var count = this.state.weights.count;\n      count.aggregationData = aggregationData;\n      count.aggregationBuffer.setData({\n        data: aggregationData\n      });\n      count.maxData = maxData;\n      count.maxTexture.setImageData({\n        data: maxData\n      });\n    }\n  }, {\n    key: \"updateAggregationState\",\n    value: function updateAggregationState(opts) {\n      var cellSize = opts.props.cellSizePixels;\n      var cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n      var viewportChanged = opts.changeFlags.viewportChanged;\n      var gpuAggregation = opts.props.gpuAggregation;\n\n      if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n        if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n          log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n          gpuAggregation = false;\n        }\n      }\n\n      var gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n      this.setState({\n        gpuAggregation: gpuAggregation\n      });\n      var positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n      var dimensions = this.state.dimensions;\n      var data = dimensions.data,\n          weights = dimensions.weights;\n      var aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation,\n        dimension: data\n      });\n      var aggregationWeightsDirty = this.isAggregationDirty(opts, {\n        dimension: weights\n      });\n      this.setState({\n        aggregationDataDirty: aggregationDataDirty,\n        aggregationWeightsDirty: aggregationWeightsDirty\n      });\n      var viewport = this.context.viewport;\n\n      if (viewportChanged || cellSizeChanged) {\n        var width = viewport.width,\n            height = viewport.height;\n        var numCol = Math.ceil(width / cellSize);\n        var numRow = Math.ceil(height / cellSize);\n        this.allocateResources(numRow, numCol);\n        this.setState({\n          scaling: [width / 2, -height / 2, 1],\n          gridOffset: {\n            xOffset: cellSize,\n            yOffset: cellSize\n          },\n          width: width,\n          height: height,\n          numCol: numCol,\n          numRow: numRow\n        });\n      }\n\n      if (aggregationWeightsDirty) {\n        this._updateAccessors(opts);\n      }\n\n      if (aggregationDataDirty || aggregationWeightsDirty) {\n        this._resetResults();\n      }\n    }\n  }, {\n    key: \"_updateAccessors\",\n    value: function _updateAccessors(opts) {\n      var _opts$props = opts.props,\n          getWeight = _opts$props.getWeight,\n          aggregation = _opts$props.aggregation;\n      var count = this.state.weights.count;\n\n      if (count) {\n        count.getWeight = getWeight;\n        count.operation = AGGREGATION_OPERATION[aggregation];\n      }\n\n      this.setState({\n        getValue: getValueFunc(aggregation, getWeight)\n      });\n    }\n  }, {\n    key: \"_resetResults\",\n    value: function _resetResults() {\n      var count = this.state.weights.count;\n\n      if (count) {\n        count.aggregationData = null;\n      }\n    }\n  }]);\n\n  return ScreenGridLayer;\n}(GridAggregationLayer);\n\nexport { ScreenGridLayer as default };\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/screen-grid-layer/screen-grid-layer.js"],"names":["defaultProps","ScreenGridCellLayer","getPosition","type","value","d","getWeight","gpuAggregation","aggregation","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ScreenGridLayer","GridAggregationLayer","gl","supported","log","dimensions","getCellSize","count","size","operation","AGGREGATION_OPERATION","needMax","maxTexture","getFloatTexture","id","projectPoints","subLayerData","attributes","positionAttributeName","posOffset","translation","attributeManager","accessor","fp64","changeFlags","opts","numRow","numCol","updateTriggers","aggregationBuffer","CellLayerClass","instanceCounts","numInstances","maxBuffer","info","mode","index","gpuGridAggregator","aggregationResults","GPUGridAggregator","pixelIndex","aggregationData","maxData","cellSize","cellSizeChanged","viewportChanged","gpuAggregationChanged","positionsChanged","aggregationDataDirty","compareAll","dimension","aggregationWeightsDirty","viewport","width","height","Math","scaling","gridOffset","xOffset","yOffset","getValue","getValueFunc"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {log} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport {getFloatTexture} from '../utils/resource-utils.js';\n\nconst defaultProps = Object.assign({}, ScreenGridCellLayer.defaultProps, {\n  getPosition: {type: 'accessor', value: d => d.position},\n  getWeight: {type: 'accessor', value: d => 1},\n\n  gpuAggregation: true,\n  aggregation: 'SUM'\n});\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {gl} = this.context;\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      // max aggregated value is sampled from a float texture\n      this.setState({supported: false});\n      log.error(`ScreenGridLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeState({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {id: `${this.id}-max-texture`})\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true, // aggregation in screen space\n      weights,\n      subLayerData: {attributes: {}},\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {maxTexture, numRow, numCol, weights} = this.state;\n    const {updateTriggers} = this.props;\n    const {aggregationBuffer} = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n\n    return new CellLayerClass(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers\n      }),\n      {\n        data: {attributes: {instanceCounts: aggregationBuffer}},\n        maxTexture,\n        numInstances: numRow * numCol\n      }\n    );\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    const {aggregationBuffer, maxBuffer, maxTexture} = this.state;\n\n    if (aggregationBuffer) {\n      aggregationBuffer.delete();\n    }\n    if (maxBuffer) {\n      maxBuffer.delete();\n    }\n    if (maxTexture) {\n      maxTexture.delete();\n    }\n  }\n\n  getPickingInfo({info, mode}) {\n    const {index} = info;\n    if (index >= 0) {\n      const {gpuGridAggregator} = this.state;\n      // Get count aggregation results\n      const aggregationResults = gpuGridAggregator.getData('count');\n\n      // Each instance (one cell) is aggregated into single pixel,\n      // Get current instance's aggregation details.\n      info.object = GPUGridAggregator.getAggregationData(\n        Object.assign({pixelIndex: index}, aggregationResults)\n      );\n    }\n\n    return info;\n  }\n\n  // Aggregation Overrides\n\n  updateResults({aggregationData, maxData}) {\n    const {count} = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({data: aggregationData});\n    count.maxData = maxData;\n    count.maxTexture.setImageData({data: maxData});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {viewportChanged} = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n\n    const {dimensions} = this.state;\n    const {data, weights} = dimensions;\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      viewportChanged ||\n      this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation, // check for all (including extentions props) when using gpu aggregation\n        dimension: data\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {dimension: weights});\n\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n\n    const {viewport} = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {width, height} = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        // transformation from clipspace to screen(pixel) space\n        scaling: [width / 2, -height / 2, 1],\n\n        gridOffset: {xOffset: cellSize, yOffset: cellSize},\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {getWeight, aggregation} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight)});\n  }\n\n  _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n}\n\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}