{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar QUANTIZED_MESH_HEADER = new Map([['centerX', Float64Array.BYTES_PER_ELEMENT], ['centerY', Float64Array.BYTES_PER_ELEMENT], ['centerZ', Float64Array.BYTES_PER_ELEMENT], ['minHeight', Float32Array.BYTES_PER_ELEMENT], ['maxHeight', Float32Array.BYTES_PER_ELEMENT], ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]]);\n\nfunction decodeZigZag(value) {\n  return value >> 1 ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  var position = 0;\n  var header = {};\n\n  var _iterator = _createForOfIteratorHelper(QUANTIZED_MESH_HEADER),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          key = _step$value[0],\n          bytesCount = _step$value[1];\n\n      var getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n      header[key] = getter.call(dataView, position, true);\n      position += bytesCount;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    header: header,\n    headerEndPosition: position\n  };\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  var position = headerEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = dataView.getUint32(position, true);\n  var vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  var elementArrayLength = vertexCount * bytesPerArrayElement;\n  var uArrayStartPosition = position;\n  var vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  var heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n  var u = 0;\n  var v = 0;\n  var height = 0;\n\n  for (var i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n  return {\n    vertexData: vertexData,\n    vertexDataEndPosition: position\n  };\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex) {\n  var encoded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  var highest = 0;\n\n  for (var i = 0; i < indices.length; ++i) {\n    var code = indices[i];\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  var position = vertexDataEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = vertexData.length / elementsPerVertex;\n  var bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - position % bytesPerIndex;\n  }\n\n  var triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var triangleIndicesCount = triangleCount * 3;\n  var triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);\n  position += triangleIndicesCount * bytesPerIndex;\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices: triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  var position = triangleIndicesEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = vertexData.length / elementsPerVertex;\n  var bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  var westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n  var southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);\n  position += southVertexCount * bytesPerIndex;\n  var eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n  var northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);\n  position += northVertexCount * bytesPerIndex;\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);\n}\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  var extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {\n      extensions: extensions,\n      extensionsEndPosition: indicesEndPosition\n    };\n  }\n\n  var position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    var extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n    var extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    var extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1:\n        {\n          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n          break;\n        }\n\n      case 2:\n        {\n          extensions.waterMask = decodeWaterMaskExtension(extensionView);\n          break;\n        }\n\n      default:\n        {}\n    }\n\n    position += extensionLength;\n  }\n\n  return {\n    extensions: extensions,\n    extensionsEndPosition: position\n  };\n}\n\nexport var DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\nvar DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\nexport default function decode(data, userOptions) {\n  var options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  var view = new DataView(data);\n\n  var _decodeHeader = decodeHeader(view),\n      header = _decodeHeader.header,\n      headerEndPosition = _decodeHeader.headerEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {\n      header: header\n    };\n  }\n\n  var _decodeVertexData = decodeVertexData(view, headerEndPosition),\n      vertexData = _decodeVertexData.vertexData,\n      vertexDataEndPosition = _decodeVertexData.vertexDataEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {\n      header: header,\n      vertexData: vertexData\n    };\n  }\n\n  var _decodeTriangleIndice = decodeTriangleIndices(view, vertexData, vertexDataEndPosition),\n      triangleIndices = _decodeTriangleIndice.triangleIndices,\n      triangleIndicesEndPosition = _decodeTriangleIndice.triangleIndicesEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {\n      header: header,\n      vertexData: vertexData,\n      triangleIndices: triangleIndices\n    };\n  }\n\n  var _decodeEdgeIndices = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition),\n      westIndices = _decodeEdgeIndices.westIndices,\n      southIndices = _decodeEdgeIndices.southIndices,\n      eastIndices = _decodeEdgeIndices.eastIndices,\n      northIndices = _decodeEdgeIndices.northIndices,\n      edgeIndicesEndPosition = _decodeEdgeIndices.edgeIndicesEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header: header,\n      vertexData: vertexData,\n      triangleIndices: triangleIndices,\n      westIndices: westIndices,\n      northIndices: northIndices,\n      eastIndices: eastIndices,\n      southIndices: southIndices\n    };\n  }\n\n  var _decodeExtensions = decodeExtensions(view, edgeIndicesEndPosition),\n      extensions = _decodeExtensions.extensions;\n\n  return {\n    header: header,\n    vertexData: vertexData,\n    triangleIndices: triangleIndices,\n    westIndices: westIndices,\n    northIndices: northIndices,\n    eastIndices: eastIndices,\n    southIndices: southIndices,\n    extensions: extensions\n  };\n}","map":{"version":3,"sources":["../../../src/lib/decode-quantized-mesh.js"],"names":["QUANTIZED_MESH_HEADER","Float64Array","Float32Array","value","position","header","key","bytesCount","getter","dataView","headerEndPosition","elementsPerVertex","vertexCount","vertexData","Uint32Array","bytesPerArrayElement","Uint16Array","elementArrayLength","uArrayStartPosition","vArrayStartPosition","heightArrayStartPosition","u","v","height","i","decodeZigZag","vertexDataEndPosition","encoded","bytesPerIndex","indices","highest","code","triangleCount","triangleIndicesCount","triangleIndices","decodeIndex","triangleIndicesEndPosition","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","edgeIndicesEndPosition","extensionDataView","extensions","extensionsEndPosition","indicesEndPosition","extensionId","Uint8Array","extensionLength","extensionView","decodeVertexNormalsExtension","decodeWaterMaskExtension","DECODING_STEPS","vertices","edgeIndices","DEFAULT_OPTIONS","maxDecodingStep","options","Object","view","decodeHeader","decodeVertexData","decodeTriangleIndices","decodeEdgeIndices","decodeExtensions"],"mappings":"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","sourcesContent":["// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst QUANTIZED_MESH_HEADER = new Map([\n  ['centerX', Float64Array.BYTES_PER_ELEMENT],\n  ['centerY', Float64Array.BYTES_PER_ELEMENT],\n  ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n\n  ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n  ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n\n  ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n\n  ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n]);\n\nfunction decodeZigZag(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n\n  return {header, headerEndPosition: position};\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(\n      dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true)\n    );\n\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n\n  return {vertexData, vertexDataEndPosition: position};\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n  let indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  let highest = 0;\n\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - (position % bytesPerIndex);\n  }\n\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    triangleIndicesCount,\n    bytesPerIndex\n  );\n  position += triangleIndicesCount * bytesPerIndex;\n\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const southIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    southVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += southVertexCount * bytesPerIndex;\n\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const northIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    northVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += northVertexCount * bytesPerIndex;\n\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(\n    extensionDataView.buffer,\n    extensionDataView.byteOffset,\n    extensionDataView.byteLength\n  );\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(\n    extensionDataView.byteOffset,\n    extensionDataView.byteOffset + extensionDataView.byteLength\n  );\n}\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {extensions, extensionsEndPosition: indicesEndPosition};\n  }\n\n  let position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1: {\n        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n\n        break;\n      }\n      case 2: {\n        extensions.waterMask = decodeWaterMaskExtension(extensionView);\n\n        break;\n      }\n      default: {\n        // console.warn(`Unknown extension with id ${extensionId}`)\n      }\n    }\n\n    position += extensionLength;\n  }\n\n  return {extensions, extensionsEndPosition: position};\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\n\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\n\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {header, headerEndPosition} = decodeHeader(view);\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {header};\n  }\n\n  const {vertexData, vertexDataEndPosition} = decodeVertexData(view, headerEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {header, vertexData};\n  }\n\n  const {triangleIndices, triangleIndicesEndPosition} = decodeTriangleIndices(\n    view,\n    vertexData,\n    vertexDataEndPosition\n  );\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {header, vertexData, triangleIndices};\n  }\n\n  const {\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices,\n    edgeIndicesEndPosition\n  } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n\n  const {extensions} = decodeExtensions(view, edgeIndicesEndPosition);\n\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}\n"]},"metadata":{},"sourceType":"module"}