{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport BinSorter from './bin-sorter';\nimport { getScaleFunctionByScaleType } from './scale-utils';\nimport { getValueFunc } from './aggregation-operation-utils';\n\nfunction nop() {}\n\nvar dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nvar _defaultDimensions = [{\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  pickingInfo: 'colorValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    }\n  },\n  nullValue: [0, 0, 0, 0]\n}, {\n  key: 'elevation',\n  accessor: 'getElevation',\n  pickingInfo: 'elevationValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    }\n  },\n  nullValue: -1\n}];\n\nvar defaultGetCellSize = function defaultGetCellSize(props) {\n  return props.cellSize;\n};\n\nvar CPUAggregator = function () {\n  function CPUAggregator(opts) {\n    _classCallCheck(this, CPUAggregator);\n\n    this.state = {\n      layerData: {},\n      dimensions: {}\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n\n    this._addDimension(opts.dimensions || _defaultDimensions);\n  }\n\n  _createClass(CPUAggregator, [{\n    key: \"updateState\",\n    value: function updateState(opts, aggregationParams) {\n      var oldProps = opts.oldProps,\n          props = opts.props,\n          changeFlags = opts.changeFlags;\n      this.updateGetValueFuncs(oldProps, props, changeFlags);\n      var reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n      var aggregationDirty = false;\n\n      if (changeFlags.dataChanged || reprojectNeeded) {\n        this.getAggregatedData(props, aggregationParams);\n        aggregationDirty = true;\n      } else {\n        var dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n        dimensionChanges.forEach(function (f) {\n          return typeof f === 'function' && f();\n        });\n        aggregationDirty = true;\n      }\n\n      this.setState({\n        aggregationDirty: aggregationDirty\n      });\n      return this.state;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      this.state = Object.assign({}, this.state, updateObject);\n    }\n  }, {\n    key: \"setDimensionState\",\n    value: function setDimensionState(key, updateObject) {\n      this.setState({\n        dimensions: Object.assign({}, this.state.dimensions, _defineProperty({}, key, Object.assign({}, this.state.dimensions[key], updateObject)))\n      });\n    }\n  }, {\n    key: \"normalizeResult\",\n    value: function normalizeResult() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (result.hexagons) {\n        return Object.assign({\n          data: result.hexagons\n        }, result);\n      } else if (result.layerData) {\n        return Object.assign({\n          data: result.layerData\n        }, result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getAggregatedData\",\n    value: function getAggregatedData(props, aggregationParams) {\n      var aggregator = this._getAggregator(props);\n\n      var result = aggregator(props, aggregationParams);\n      this.setState({\n        layerData: this.normalizeResult(result)\n      });\n      this.changeFlags = {\n        layerData: true\n      };\n      this.getSortedBins(props);\n    }\n  }, {\n    key: \"updateGetValueFuncs\",\n    value: function updateGetValueFuncs(oldProps, props, changeFlags) {\n      for (var key in this.dimensionUpdaters) {\n        var _this$dimensionUpdate = this.dimensionUpdaters[key].getBins.triggers,\n            value = _this$dimensionUpdate.value,\n            weight = _this$dimensionUpdate.weight,\n            aggregation = _this$dimensionUpdate.aggregation;\n        var getValue = props[value.prop];\n        var getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);\n\n        if (getValueChanged && getValue === null) {\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop]);\n        }\n\n        if (getValue) {\n          this.setDimensionState(key, {\n            getValue: getValue\n          });\n        }\n      }\n    }\n  }, {\n    key: \"needsReProjectPoints\",\n    value: function needsReProjectPoints(oldProps, props, changeFlags) {\n      return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);\n    }\n  }, {\n    key: \"addDimension\",\n    value: function addDimension(dimensions) {\n      this._addDimension(dimensions);\n    }\n  }, {\n    key: \"_addDimension\",\n    value: function _addDimension() {\n      var _this = this;\n\n      var dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      dimensions.forEach(function (dimension) {\n        var key = dimension.key;\n        _this.dimensionUpdaters[key] = _this.getDimensionUpdaters(dimension);\n        _this.state.dimensions[key] = {\n          getValue: null,\n          domain: null,\n          sortedBins: null,\n          scaleFunc: nop\n        };\n      });\n    }\n  }, {\n    key: \"getDimensionUpdaters\",\n    value: function getDimensionUpdaters(_ref) {\n      var key = _ref.key,\n          accessor = _ref.accessor,\n          pickingInfo = _ref.pickingInfo,\n          getBins = _ref.getBins,\n          getDomain = _ref.getDomain,\n          getScaleFunc = _ref.getScaleFunc,\n          nullValue = _ref.nullValue;\n      return {\n        key: key,\n        accessor: accessor,\n        pickingInfo: pickingInfo,\n        getBins: Object.assign({\n          updater: this.getDimensionSortedBins\n        }, getBins),\n        getDomain: Object.assign({\n          updater: this.getDimensionValueDomain\n        }, getDomain),\n        getScaleFunc: Object.assign({\n          updater: this.getDimensionScale\n        }, getScaleFunc),\n        attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n      };\n    }\n  }, {\n    key: \"needUpdateDimensionStep\",\n    value: function needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n      return Object.values(dimensionStep.triggers).some(function (item) {\n        if (item.updateTrigger) {\n          return changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n        }\n\n        return oldProps[item.prop] !== props[item.prop];\n      });\n    }\n  }, {\n    key: \"getDimensionChanges\",\n    value: function getDimensionChanges(oldProps, props, changeFlags) {\n      var _this2 = this;\n\n      var updaters = [];\n\n      var _loop = function _loop(key) {\n        var needUpdate = dimensionSteps.find(function (step) {\n          return _this2.needUpdateDimensionStep(_this2.dimensionUpdaters[key][step], oldProps, props, changeFlags);\n        });\n\n        if (needUpdate) {\n          updaters.push(_this2.dimensionUpdaters[key][needUpdate].updater.bind(_this2, props, _this2.dimensionUpdaters[key]));\n        }\n      };\n\n      for (var key in this.dimensionUpdaters) {\n        _loop(key);\n      }\n\n      return updaters.length ? updaters : null;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers(props) {\n      var _this3 = this;\n\n      var _updateTriggers = props.updateTriggers || {};\n\n      var updateTriggers = {};\n\n      var _loop2 = function _loop2(key) {\n        var accessor = _this3.dimensionUpdaters[key].accessor;\n        updateTriggers[accessor] = {};\n        dimensionSteps.forEach(function (step) {\n          Object.values(_this3.dimensionUpdaters[key][step].triggers).forEach(function (_ref2) {\n            var prop = _ref2.prop,\n                updateTrigger = _ref2.updateTrigger;\n\n            if (updateTrigger) {\n              var fromProp = _updateTriggers[updateTrigger];\n\n              if (_typeof(fromProp) === 'object' && !Array.isArray(fromProp)) {\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          });\n        });\n      };\n\n      for (var key in this.dimensionUpdaters) {\n        _loop2(key);\n      }\n\n      return updateTriggers;\n    }\n  }, {\n    key: \"getSortedBins\",\n    value: function getSortedBins(props) {\n      for (var key in this.dimensionUpdaters) {\n        this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n      }\n    }\n  }, {\n    key: \"getDimensionSortedBins\",\n    value: function getDimensionSortedBins(props, dimensionUpdater) {\n      var key = dimensionUpdater.key;\n      var getValue = this.state.dimensions[key].getValue;\n      var sortedBins = new BinSorter(this.state.layerData.data || [], {\n        getValue: getValue,\n        filterData: props._filterData\n      });\n      this.setDimensionState(key, {\n        sortedBins: sortedBins\n      });\n      this.getDimensionValueDomain(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionValueDomain\",\n    value: function getDimensionValueDomain(props, dimensionUpdater) {\n      var getDomain = dimensionUpdater.getDomain,\n          key = dimensionUpdater.key;\n      var _getDomain$triggers = getDomain.triggers,\n          lowerPercentile = _getDomain$triggers.lowerPercentile,\n          upperPercentile = _getDomain$triggers.upperPercentile,\n          scaleType = _getDomain$triggers.scaleType;\n      var valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n      this.setDimensionState(key, {\n        valueDomain: valueDomain\n      });\n      this.getDimensionScale(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionScale\",\n    value: function getDimensionScale(props, dimensionUpdater) {\n      var key = dimensionUpdater.key,\n          getScaleFunc = dimensionUpdater.getScaleFunc,\n          getDomain = dimensionUpdater.getDomain;\n      var _getScaleFunc$trigger = getScaleFunc.triggers,\n          domain = _getScaleFunc$trigger.domain,\n          range = _getScaleFunc$trigger.range;\n      var scaleType = getDomain.triggers.scaleType;\n      var onSet = getScaleFunc.onSet;\n      var dimensionRange = props[range.prop];\n      var dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n      var getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n      var scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n      if (_typeof(onSet) === 'object' && typeof props[onSet.props] === 'function') {\n        props[onSet.props](scaleFunc.domain());\n      }\n\n      this.setDimensionState(key, {\n        scaleFunc: scaleFunc\n      });\n    }\n  }, {\n    key: \"getSubLayerDimensionAttribute\",\n    value: function getSubLayerDimensionAttribute(key, nullValue) {\n      var _this4 = this;\n\n      return function (cell) {\n        var _this4$state$dimensio = _this4.state.dimensions[key],\n            sortedBins = _this4$state$dimensio.sortedBins,\n            scaleFunc = _this4$state$dimensio.scaleFunc;\n        var bin = sortedBins.binMap[cell.index];\n\n        if (bin && bin.counts === 0) {\n          return nullValue;\n        }\n\n        var cv = bin && bin.value;\n        var domain = scaleFunc.domain();\n        var isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n        return isValueInDomain ? scaleFunc(cv) : nullValue;\n      };\n    }\n  }, {\n    key: \"getSubLayerAccessors\",\n    value: function getSubLayerAccessors(props) {\n      var accessors = {};\n\n      for (var key in this.dimensionUpdaters) {\n        var accessor = this.dimensionUpdaters[key].accessor;\n        accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n      }\n\n      return accessors;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info;\n      var isPicked = info.picked && info.index > -1;\n      var object = null;\n\n      if (isPicked) {\n        var cell = this.state.layerData.data[info.index];\n        var binInfo = {};\n\n        for (var key in this.dimensionUpdaters) {\n          var pickingInfo = this.dimensionUpdaters[key].pickingInfo;\n          var sortedBins = this.state.dimensions[key].sortedBins;\n          var value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n          binInfo[pickingInfo] = value;\n        }\n\n        object = Object.assign(binInfo, cell, {\n          points: cell.filteredPoints || cell.points\n        });\n      }\n\n      return Object.assign(info, {\n        picked: Boolean(object),\n        object: object\n      });\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(dimensionKey) {\n      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n        return nop;\n      }\n\n      return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n    }\n  }], [{\n    key: \"defaultDimensions\",\n    value: function defaultDimensions() {\n      return _defaultDimensions;\n    }\n  }]);\n\n  return CPUAggregator;\n}();\n\nexport { CPUAggregator as default };","map":{"version":3,"sources":["../../../src/utils/cpu-aggregator.js"],"names":["dimensionSteps","defaultDimensions","key","accessor","pickingInfo","getBins","triggers","value","prop","updateTrigger","weight","aggregation","filterData","getDomain","lowerPercentile","upperPercentile","scaleType","getScaleFunc","domain","range","onSet","props","nullValue","defaultGetCellSize","CPUAggregator","layerData","dimensions","opts","aggregationParams","oldProps","changeFlags","reprojectNeeded","aggregationDirty","dimensionChanges","f","updateObject","Object","result","data","hexagons","aggregator","getValue","getValueChanged","getValueFunc","dimension","sortedBins","scaleFunc","nop","updater","getDimensionSortedBins","getDimensionValueDomain","getDimensionScale","attributeAccessor","dimensionStep","item","updaters","needUpdate","_updateTriggers","updateTriggers","fromProp","Array","dimensionUpdater","_filterData","valueDomain","dimensionRange","dimensionDomain","getScaleFunction","getScaleFunctionByScaleType","bin","cell","cv","isValueInDomain","accessors","info","isPicked","object","binInfo","points","picked","Boolean","dimensionKey"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from './bin-sorter';\nimport {getScaleFunctionByScaleType} from './scale-utils';\nimport {getValueFunc} from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n  {\n    key: 'fillColor',\n    accessor: 'getFillColor',\n    pickingInfo: 'colorValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {\n          prop: 'colorScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      }\n    },\n    nullValue: [0, 0, 0, 0]\n  },\n  {\n    key: 'elevation',\n    accessor: 'getElevation',\n    pickingInfo: 'elevationValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {\n          prop: 'elevationScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      }\n    },\n    nullValue: -1\n  }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      // project data into bin and aggregate wegiths per bin\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      // this here is layer\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n    this.setState({aggregationDirty});\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = Object.assign({}, this.state, updateObject);\n  }\n\n  // Update private state.dimensions\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: Object.assign({}, this.state.dimensions, {\n        [key]: Object.assign({}, this.state.dimensions[key], updateObject)\n      })\n    });\n  }\n\n  normalizeResult(result = {}) {\n    // support previous hexagonAggregator API\n    if (result.hexagons) {\n      return Object.assign({data: result.hexagons}, result);\n    } else if (result.layerData) {\n      return Object.assign({data: result.layerData}, result);\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(\n        this.dimensionUpdaters[key].getBins,\n        oldProps,\n        props,\n        changeFlags\n      );\n\n      if (getValueChanged && getValue === null) {\n        // If `getValue` is not provided from props, build it with aggregation and weight.\n        getValue = getValueFunc(props[aggregation.prop], props[weight.prop]);\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {getValue});\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return (\n      this._getCellSize(oldProps) !== this._getCellSize(props) ||\n      this._getAggregator(oldProps) !== this._getAggregator(props) ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))\n    );\n  }\n\n  // Adds dimensions\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: Object.assign({updater: this.getDimensionSortedBins}, getBins),\n      getDomain: Object.assign({updater: this.getDimensionValueDomain}, getDomain),\n      getScaleFunc: Object.assign({updater: this.getDimensionScale}, getScaleFunc),\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    // getBins: {\n    //   value: {\n    //     prop: 'getElevationValue',\n    //     updateTrigger: 'getElevationValue'\n    //   },\n    //   weight: {\n    //     prop: 'getElevationWeight',\n    //     updateTrigger: 'getElevationWeight'\n    //   },\n    //   aggregation: {\n    //     prop: 'elevationAggregation'\n    //   }\n    // }\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        return (\n          changeFlags.updateTriggersChanged &&\n          (changeFlags.updateTriggersChanged.all ||\n            changeFlags.updateTriggersChanged[item.updateTrigger])\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    // const {dimensionUpdaters} = this.state;\n    const updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const needUpdate = dimensionSteps.find(step =>\n        this.needUpdateDimensionStep(\n          this.dimensionUpdaters[key][step],\n          oldProps,\n          props,\n          changeFlags\n        )\n      );\n\n      if (needUpdate) {\n        updaters.push(\n          this.dimensionUpdaters[key][needUpdate].updater.bind(\n            this,\n            props,\n            this.dimensionUpdaters[key]\n          )\n        );\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(\n          ({prop, updateTrigger}) => {\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              const fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          }\n        );\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {key} = dimensionUpdater;\n    const {getValue} = this.state.dimensions[key];\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {sortedBins});\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {getDomain, key} = dimensionUpdater;\n    const {\n      triggers: {lowerPercentile, upperPercentile, scaleType}\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n      props[scaleType.prop],\n      [props[lowerPercentile.prop], props[upperPercentile.prop]]\n    );\n\n    this.setDimensionState(key, {valueDomain});\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {key, getScaleFunc, getDomain} = dimensionUpdater;\n    const {domain, range} = getScaleFunc.triggers;\n    const {scaleType} = getDomain.triggers;\n    const {onSet} = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {scaleFunc});\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {sortedBins, scaleFunc} = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        // no points left in bin after filtering\n        return nullValue;\n      }\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n      // if cell value is outside domain, set alpha to 0\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({info}) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      // const {sortedColorBins, sortedElevationBins} = this.state;\n\n      const cell = this.state.layerData.data[info.index];\n\n      const binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {pickingInfo} = this.dimensionUpdaters[key];\n        const {sortedBins} = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // add bin colorValue and elevationValue to info\n    return Object.assign(info, {\n      picked: Boolean(object),\n      // override object with picked cell\n      object\n    });\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}