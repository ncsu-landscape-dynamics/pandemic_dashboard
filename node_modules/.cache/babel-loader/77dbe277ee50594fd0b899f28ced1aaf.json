{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nvar _marked = _regeneratorRuntime.mark(makeArrayBufferIterator);\n\nexport function makeArrayBufferIterator(arrayBuffer) {\n  var options,\n      _options$chunkSize,\n      chunkSize,\n      byteOffset,\n      chunkByteLength,\n      chunk,\n      sourceArray,\n      chunkArray,\n      _args = arguments;\n\n  return _regeneratorRuntime.wrap(function makeArrayBufferIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? 256 * 1024 : _options$chunkSize;\n          byteOffset = 0;\n\n        case 3:\n          if (!(byteOffset < arrayBuffer.byteLength)) {\n            _context.next = 14;\n            break;\n          }\n\n          chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n          chunk = new ArrayBuffer(chunkByteLength);\n          sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n          chunkArray = new Uint8Array(chunk);\n          chunkArray.set(sourceArray);\n          byteOffset += chunkByteLength;\n          _context.next = 12;\n          return chunk;\n\n        case 12:\n          _context.next = 3;\n          break;\n\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}","map":{"version":3,"sources":["../../../../src/iterator-utils/make-iterator/array-buffer-iterator.js"],"names":["makeArrayBufferIterator","options","chunkSize","byteOffset","arrayBuffer","chunkByteLength","Math","chunk","sourceArray","chunkArray"],"mappings":";;uCAAiBA,uB;;AAAjB,OAAO,SAAA,uBAAA,CAAA,WAAA,EAAA;AAAA,MAAA,OAAA;AAAA,MAAA,kBAAA;AAAA,MAAA,SAAA;AAAA,MAAA,UAAA;AAAA,MAAA,eAAA;AAAA,MAAA,KAAA;AAAA,MAAA,WAAA;AAAA,MAAA,UAAA;AAAA,MAAA,KAAA,GAAA,SAAA;;AAAA,SAAA,mBAAA,CAAA,IAAA,CAAA,SAAA,wBAAA,CAAA,QAAA,EAAA;AAAA,WAAA,CAAA,EAAA;AAAA,cAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;AAAA,aAAA,CAAA;AAA+CC,UAAAA,OAA/C,GAAA,KAAA,CAAA,MAAA,GAAA,CAAA,IAAA,KAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,KAAA,CAAA,CAAA,CAAA,GAAA,EAA+CA;AAA/C,UAAA,kBAAA,GAC4BA,OAD5B,CAAA,SAAA,EACEC,SADF,GAAA,kBAAA,KAAA,KAAA,CAAA,GACc,MADd,IAAA,GAAA,kBAAA;AAGDC,UAAAA,UAHC,GAAA,CAGDA;;AAHC,aAAA,CAAA;AAAA,cAAA,EAKEA,UAAU,GAAGC,WAAW,CAL1B,UAAA,CAAA,EAAA;AAAA,YAAA,QAAA,CAAA,IAAA,GAAA,EAAA;AAAA;AAAA;;AAOGC,UAAAA,eAPH,GAOqBC,IAAI,CAAJA,GAAAA,CAASF,WAAW,CAAXA,UAAAA,GAATE,UAAAA,EAPrB,SAOqBA,CAAlBD;AACAE,UAAAA,KARH,GAQW,IAAA,WAAA,CARX,eAQW,CAARA;AAGAC,UAAAA,WAXH,GAWiB,IAAA,UAAA,CAAA,WAAA,EAAA,UAAA,EAXjB,eAWiB,CAAdA;AACAC,UAAAA,UAZH,GAYgB,IAAA,UAAA,CAZhB,KAYgB,CAAbA;AACNA,UAAAA,UAAU,CAAVA,GAAAA,CAAAA,WAAAA;AAGAN,UAAAA,UAAU,IAAVA,eAAAA;AAhBG,UAAA,QAAA,CAAA,IAAA,GAAA,EAAA;AAiBH,iBAAA,KAAA;;AAjBG,aAAA,EAAA;AAAA,UAAA,QAAA,CAAA,IAAA,GAAA,CAAA;AAAA;;AAAA,aAAA,EAAA;AAAA,aAAA,KAAA;AAAA,iBAAA,QAAA,CAAA,IAAA,EAAA;AAAA;AAAA;AAAA,GAAA,EAAA,OAAA,CAAA;AAAA","sourcesContent":["export function* makeArrayBufferIterator(arrayBuffer, options = {}) {\n  const {chunkSize = 256 * 1024} = options;\n\n  let byteOffset = 0;\n\n  while (byteOffset < arrayBuffer.byteLength) {\n    // Create a chunk of the right size\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n\n    // Copy data from the big chunk\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n\n    // yield the chunk\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}