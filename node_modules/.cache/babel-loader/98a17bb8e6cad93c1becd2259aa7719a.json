{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Model, Geometry, FEATURES, hasFeatures } from '@luma.gl/core';\nimport { Layer, log, picking } from '@deck.gl/core';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nvar DEFAULT_MINCOLOR = [0, 0, 0, 0];\nvar DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nvar COLOR_PROPS = [\"minColor\", \"maxColor\", \"colorRange\", \"colorDomain\"];\nvar defaultProps = {\n  cellSizePixels: {\n    value: 100,\n    min: 1\n  },\n  cellMarginPixels: {\n    value: 2,\n    min: 0,\n    max: 5\n  },\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\nvar ScreenGridCellLayer = function (_Layer) {\n  _inherits(ScreenGridCellLayer, _Layer);\n\n  function ScreenGridCellLayer() {\n    _classCallCheck(this, ScreenGridCellLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScreenGridCellLayer).apply(this, arguments));\n  }\n\n  _createClass(ScreenGridCellLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return {\n        vs: vs,\n        fs: fs,\n        modules: [picking]\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var gl = this.context.gl;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 3,\n          update: this.calculateInstancePositions\n        },\n        instanceCounts: {\n          size: 4,\n          noAlloc: true\n        }\n      });\n      this.setState({\n        model: this._getModel(gl)\n      });\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n\n      _get(_getPrototypeOf(ScreenGridCellLayer.prototype), \"updateState\", this).call(this, {\n        oldProps: oldProps,\n        props: props,\n        changeFlags: changeFlags\n      });\n\n      var attributeManager = this.getAttributeManager();\n\n      if (props.numInstances !== oldProps.numInstances) {\n        attributeManager.invalidateAll();\n      } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n        attributeManager.invalidate('instancePositions');\n      }\n\n      this._updateUniforms(oldProps, props, changeFlags);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var uniforms = _ref3.uniforms;\n      var _this$props = this.props,\n          parameters = _this$props.parameters,\n          maxTexture = _this$props.maxTexture;\n      var minColor = this.props.minColor || DEFAULT_MINCOLOR;\n      var maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n      var colorDomain = this.props.colorDomain || [1, 0];\n      var model = this.state.model;\n      var layerUniforms = {\n        minColor: minColor,\n        maxColor: maxColor,\n        maxTexture: maxTexture,\n        colorDomain: colorDomain\n      };\n      uniforms = Object.assign(layerUniforms, uniforms);\n      model.draw({\n        uniforms: uniforms,\n        parameters: Object.assign({\n          depthTest: false,\n          depthMask: false\n        }, parameters)\n      });\n    }\n  }, {\n    key: \"calculateInstancePositions\",\n    value: function calculateInstancePositions(attribute, _ref4) {\n      var numInstances = _ref4.numInstances;\n      var _this$context$viewpor = this.context.viewport,\n          width = _this$context$viewpor.width,\n          height = _this$context$viewpor.height;\n      var cellSizePixels = this.props.cellSizePixels;\n      var numCol = Math.ceil(width / cellSizePixels);\n      var value = attribute.value,\n          size = attribute.size;\n\n      for (var i = 0; i < numInstances; i++) {\n        var x = i % numCol;\n        var y = Math.floor(i / numCol);\n        value[i * size + 0] = x * cellSizePixels / width * 2 - 1;\n        value[i * size + 1] = 1 - y * cellSizePixels / height * 2;\n        value[i * size + 2] = 0;\n      }\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 6,\n          attributes: {\n            positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n          }\n        }),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"_shouldUseMinMax\",\n    value: function _shouldUseMinMax() {\n      var _this$props2 = this.props,\n          minColor = _this$props2.minColor,\n          maxColor = _this$props2.maxColor,\n          colorDomain = _this$props2.colorDomain,\n          colorRange = _this$props2.colorRange;\n\n      if (minColor || maxColor) {\n        log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n        return true;\n      }\n\n      if (colorDomain || colorRange) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_updateUniforms\",\n    value: function _updateUniforms(oldProps, props, changeFlags) {\n      var model = this.state.model;\n\n      if (COLOR_PROPS.some(function (key) {\n        return oldProps[key] !== props[key];\n      })) {\n        model.setUniforms({\n          shouldUseMinMax: this._shouldUseMinMax()\n        });\n      }\n\n      if (oldProps.colorRange !== props.colorRange) {\n        model.setUniforms({\n          colorRange: colorRangeToFlatArray(props.colorRange)\n        });\n      }\n\n      if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {\n        var _this$context$viewpor2 = this.context.viewport,\n            width = _this$context$viewpor2.width,\n            height = _this$context$viewpor2.height;\n        var _this$props3 = this.props,\n            cellSizePixels = _this$props3.cellSizePixels,\n            cellMarginPixels = _this$props3.cellMarginPixels;\n        var margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n        var cellScale = new Float32Array([(cellSizePixels - margin) / width * 2, -(cellSizePixels - margin) / height * 2, 1]);\n        model.setUniforms({\n          cellScale: cellScale\n        });\n      }\n    }\n  }], [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n    }\n  }]);\n\n  return ScreenGridCellLayer;\n}(Layer);\n\nexport { ScreenGridCellLayer as default };\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/screen-grid-layer/screen-grid-cell-layer.js"],"names":["DEFAULT_MINCOLOR","DEFAULT_MAXCOLOR","COLOR_PROPS","defaultProps","cellSizePixels","value","min","cellMarginPixels","max","colorDomain","colorRange","defaultColorRange","ScreenGridCellLayer","Layer","gl","hasFeatures","FEATURES","vs","fs","modules","attributeManager","instancePositions","size","update","calculateInstancePositions","instanceCounts","noAlloc","model","changeFlags","oldProps","props","uniforms","parameters","maxTexture","minColor","maxColor","layerUniforms","Object","depthTest","depthMask","attribute","numInstances","width","height","numCol","Math","i","x","y","id","geometry","drawMode","attributes","positions","isInstanced","log","shouldUseMinMax","colorRangeToFlatArray","margin","cellScale"],"mappings":";;;;;;AAqBA,SAAA,KAAA,EAAA,QAAA,EAAA,QAAA,EAAA,WAAA,QAAA,eAAA;AACA,SAAA,KAAA,EAAA,GAAA,EAAA,OAAA,QAAA,eAAA;AACA,SAAA,iBAAA,EAAA,qBAAA,QAAA,sBAAA;AACA,OAAA,EAAA,MAAA,iCAAA;AACA,OAAA,EAAA,MAAA,mCAAA;AAEA,IAAMA,gBAAgB,GAAG,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAzB,CAAyB,CAAzB;AACA,IAAMC,gBAAgB,GAAG,CAAA,CAAA,EAAA,GAAA,EAAA,CAAA,EAAzB,GAAyB,CAAzB;AACA,IAAMC,WAAW,GAAG,CAAA,UAAA,EAAA,UAAA,EAAA,YAAA,EAApB,aAAoB,CAApB;AAEA,IAAMC,YAAY,GAAG;AACnBC,EAAAA,cAAc,EAAE;AAACC,IAAAA,KAAK,EAAN,GAAA;AAAaC,IAAAA,GAAG,EAAE;AAAlB,GADG;AAEnBC,EAAAA,gBAAgB,EAAE;AAACF,IAAAA,KAAK,EAAN,CAAA;AAAWC,IAAAA,GAAG,EAAd,CAAA;AAAmBE,IAAAA,GAAG,EAAE;AAAxB,GAFC;AAInBC,EAAAA,WAAW,EAJQ,IAAA;AAKnBC,EAAAA,UAAU,EAAEC;AALO,CAArB;;IAQqBC,mB;;;;;;;;;;;iCAKN;AACX,aAAO;AAACK,QAAAA,EAAE,EAAH,EAAA;AAAKC,QAAAA,EAAE,EAAP,EAAA;AAASC,QAAAA,OAAO,EAAE,CAAA,OAAA;AAAlB,OAAP;AACD;;;sCAEiB;AAAA,UACTL,EADS,GACH,KADG,OACH,CADG,EAAA;AAEhB,UAAMM,gBAAgB,GAAG,KAAzB,mBAAyB,EAAzB;AACAA,MAAAA,gBAAgB,CAAhBA,YAAAA,CAA8B;AAC5BC,QAAAA,iBAAiB,EAAE;AAACC,UAAAA,IAAI,EAAL,CAAA;AAAUC,UAAAA,MAAM,EAAE,KAAKC;AAAvB,SADS;AAE5BC,QAAAA,cAAc,EAAE;AAACH,UAAAA,IAAI,EAAL,CAAA;AAAUI,UAAAA,OAAO,EAAE;AAAnB;AAFY,OAA9BN;AAIA,WAAA,QAAA,CAAc;AACZO,QAAAA,KAAK,EAAE,KAAA,SAAA,CAAA,EAAA;AADK,OAAd;AAGD;;;4CAEgC;AAAA,UAAdC,WAAc,GAAA,IAAA,CAAdA,WAAc;AAE/B,aAAOA,WAAW,CAAlB,gBAAA;AACD;;;uCAE2C;AAAA,UAA/BC,QAA+B,GAAA,KAAA,CAA/BA,QAA+B;AAAA,UAArBC,KAAqB,GAAA,KAAA,CAArBA,KAAqB;AAAA,UAAdF,WAAc,GAAA,KAAA,CAAdA,WAAc;;AAC1C,MAAA,IAAA,CAAA,eAAA,CAAA,mBAAA,CAAA,SAAA,CAAA,EAAA,aAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAkB;AAACC,QAAAA,QAAQ,EAAT,QAAA;AAAWC,QAAAA,KAAK,EAAhB,KAAA;AAAkBF,QAAAA,WAAW,EAAXA;AAAlB,OAAlB;;AAEA,UAAMR,gBAAgB,GAAG,KAAzB,mBAAyB,EAAzB;;AACA,UAAIU,KAAK,CAALA,YAAAA,KAAuBD,QAAQ,CAAnC,YAAA,EAAkD;AAChDT,QAAAA,gBAAgB,CAAhBA,aAAAA;AADF,OAAA,MAEO,IAAIS,QAAQ,CAARA,cAAAA,KAA4BC,KAAK,CAArC,cAAA,EAAsD;AAC3DV,QAAAA,gBAAgB,CAAhBA,UAAAA,CAAAA,mBAAAA;AACD;;AAED,WAAA,eAAA,CAAA,QAAA,EAAA,KAAA,EAAA,WAAA;AACD;;;gCAEgB;AAAA,UAAXW,QAAW,GAAA,KAAA,CAAXA,QAAW;AAAA,UAAA,WAAA,GACkB,KADlB,KAAA;AAAA,UACRC,UADQ,GAAA,WAAA,CAAA,UAAA;AAAA,UACIC,UADJ,GAAA,WAAA,CAAA,UAAA;AAEf,UAAMC,QAAQ,GAAG,KAAA,KAAA,CAAA,QAAA,IAAjB,gBAAA;AACA,UAAMC,QAAQ,GAAG,KAAA,KAAA,CAAA,QAAA,IAAjB,gBAAA;AAIA,UAAM1B,WAAW,GAAG,KAAA,KAAA,CAAA,WAAA,IAA0B,CAAA,CAAA,EAA9C,CAA8C,CAA9C;AAPe,UAQRkB,KARQ,GAQC,KARD,KAQC,CARD,KAAA;AASf,UAAMS,aAAa,GAAG;AACpBF,QAAAA,QAAQ,EADY,QAAA;AAEpBC,QAAAA,QAAQ,EAFY,QAAA;AAGpBF,QAAAA,UAAU,EAHU,UAAA;AAIpBxB,QAAAA,WAAW,EAAXA;AAJoB,OAAtB;AAOAsB,MAAAA,QAAQ,GAAGM,MAAM,CAANA,MAAAA,CAAAA,aAAAA,EAAXN,QAAWM,CAAXN;AACAJ,MAAAA,KAAK,CAALA,IAAAA,CAAW;AACTI,QAAAA,QAAQ,EADC,QAAA;AAETC,QAAAA,UAAU,EAAE,MAAM,CAAN,MAAA,CACV;AACEM,UAAAA,SAAS,EADX,KAAA;AAEEC,UAAAA,SAAS,EAAE;AAFb,SADU,EAAA,UAAA;AAFH,OAAXZ;AAUD;;;+CAE0Ba,S,SAA2B;AAAA,UAAfC,YAAe,GAAA,KAAA,CAAfA,YAAe;AAAA,UAAA,qBAAA,GAC5B,KAAA,OAAA,CAD4B,QAAA;AAAA,UAC7CC,KAD6C,GAAA,qBAAA,CAAA,KAAA;AAAA,UACtCC,MADsC,GAAA,qBAAA,CAAA,MAAA;AAAA,UAE7CvC,cAF6C,GAE3B,KAF2B,KAE3B,CAF2B,cAAA;AAGpD,UAAMwC,MAAM,GAAGC,IAAI,CAAJA,IAAAA,CAAUH,KAAK,GAA9B,cAAeG,CAAf;AAHoD,UAK7CxC,KAL6C,GAK9BmC,SAL8B,CAAA,KAAA;AAAA,UAKtClB,IALsC,GAK9BkB,SAL8B,CAAA,IAAA;;AAOpD,WAAK,IAAIM,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,YAAA,EAAkCA,CAAlC,EAAA,EAAuC;AACrC,YAAMC,CAAC,GAAGD,CAAC,GAAX,MAAA;AACA,YAAME,CAAC,GAAGH,IAAI,CAAJA,KAAAA,CAAWC,CAAC,GAAtB,MAAUD,CAAV;AACAxC,QAAAA,KAAK,CAACyC,CAAC,GAADA,IAAAA,GAANzC,CAAK,CAALA,GAAwB0C,CAAC,GAAF,cAACA,GAAF,KAAEA,GAAF,CAAEA,GAAxB1C,CAAAA;AACAA,QAAAA,KAAK,CAACyC,CAAC,GAADA,IAAAA,GAANzC,CAAK,CAALA,GAAsB,IAAM2C,CAAC,GAAF,cAACA,GAAF,MAAEA,GAA5B3C,CAAAA;AACAA,QAAAA,KAAK,CAACyC,CAAC,GAADA,IAAAA,GAANzC,CAAK,CAALA,GAAAA,CAAAA;AACD;AACF;;;8BAISS,E,EAAI;AACZ,aAAO,IAAA,KAAA,CAAA,EAAA,EAEL,MAAM,CAAN,MAAA,CAAA,EAAA,EAAkB,KAAlB,UAAkB,EAAlB,EAAqC;AACnCmC,QAAAA,EAAE,EAAE,KAAA,KAAA,CAD+B,EAAA;AAEnCC,QAAAA,QAAQ,EAAE,IAAA,QAAA,CAAa;AACrBC,UAAAA,QAAQ,EADa,CAAA;AAErBC,UAAAA,UAAU,EAAE;AACVC,YAAAA,SAAS,EAAE,IAAA,YAAA,CAAiB,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAjB,CAAiB,CAAjB;AADD;AAFS,SAAb,CAFyB;AAQnCC,QAAAA,WAAW,EAAE;AARsB,OAArC,CAFK,CAAP;AAaD;;;uCAEkB;AAAA,UAAA,YAAA,GACqC,KADrC,KAAA;AAAA,UACVpB,QADU,GAAA,YAAA,CAAA,QAAA;AAAA,UACAC,QADA,GAAA,YAAA,CAAA,QAAA;AAAA,UACU1B,WADV,GAAA,YAAA,CAAA,WAAA;AAAA,UACuBC,UADvB,GAAA,YAAA,CAAA,UAAA;;AAEjB,UAAIwB,QAAQ,IAAZ,QAAA,EAA0B;AACxBqB,QAAAA,GAAG,CAAHA,UAAAA,CAAAA,8CAAAA,EAAAA,yBAAAA;AACA,eAAA,IAAA;AACD;;AAGD,UAAI9C,WAAW,IAAf,UAAA,EAA+B;AAC7B,eAAA,KAAA;AACD;;AAED,aAAA,IAAA;AACD;;;oCAEeoB,Q,EAAUC,K,EAAOF,W,EAAa;AAAA,UACrCD,KADqC,GAC5B,KAD4B,KAC5B,CAD4B,KAAA;;AAE5C,UAAI,WAAW,CAAX,IAAA,CAAiB,UAAA,GAAA,EAAG;AAAA,eAAIE,QAAQ,CAARA,GAAQ,CAARA,KAAkBC,KAAK,CAA3B,GAA2B,CAA3B;AAAxB,OAAI,CAAJ,EAA2D;AACzDH,QAAAA,KAAK,CAALA,WAAAA,CAAkB;AAAC6B,UAAAA,eAAe,EAAE,KAAA,gBAAA;AAAlB,SAAlB7B;AACD;;AAED,UAAIE,QAAQ,CAARA,UAAAA,KAAwBC,KAAK,CAAjC,UAAA,EAA8C;AAC5CH,QAAAA,KAAK,CAALA,WAAAA,CAAkB;AAACjB,UAAAA,UAAU,EAAE+C,qBAAqB,CAAC3B,KAAK,CAAN,UAAA;AAAlC,SAAlBH;AACD;;AAED,UACEE,QAAQ,CAARA,gBAAAA,KAA8BC,KAAK,CAAnCD,gBAAAA,IACAA,QAAQ,CAARA,cAAAA,KAA4BC,KAAK,CADjCD,cAAAA,IAEAD,WAAW,CAHb,eAAA,EAIE;AAAA,YAAA,sBAAA,GACwB,KAAA,OAAA,CADxB,QAAA;AAAA,YACOc,KADP,GAAA,sBAAA,CAAA,KAAA;AAAA,YACcC,MADd,GAAA,sBAAA,CAAA,MAAA;AAAA,YAAA,YAAA,GAE2C,KAF3C,KAAA;AAAA,YAEOvC,cAFP,GAAA,YAAA,CAAA,cAAA;AAAA,YAEuBG,gBAFvB,GAAA,YAAA,CAAA,gBAAA;AAGA,YAAMmD,MAAM,GAAGtD,cAAc,GAAdA,gBAAAA,GAAAA,gBAAAA,GAAf,CAAA;AAEA,YAAMuD,SAAS,GAAG,IAAA,YAAA,CAAiB,CAChC,CAACvD,cAAc,GAAf,MAAA,IAAD,KAAC,GADgC,CAAA,EAEhC,EAAEA,cAAc,GAAhB,MAAA,IAAD,MAAC,GAFgC,CAAA,EAAnC,CAAmC,CAAjB,CAAlB;AAKAuB,QAAAA,KAAK,CAALA,WAAAA,CAAkB;AAACgC,UAAAA,SAAS,EAATA;AAAD,SAAlBhC;AACD;AACF;;;gCA9IkBb,E,EAAI;AACrB,aAAOC,WAAW,CAAA,EAAA,EAAK,CAACC,QAAQ,CAAhC,aAAuB,CAAL,CAAlB;AACD;;;;EAH8CH,K;;SAA5BD,mB;AAkJrBA,mBAAmB,CAAnBA,SAAAA,GAAAA,qBAAAA;AACAA,mBAAmB,CAAnBA,YAAAA,GAAAA,YAAAA","sourcesContent":["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, FEATURES, hasFeatures} from '@luma.gl/core';\nimport {Layer, log, picking} from '@deck.gl/core';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\n\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = [`minColor`, `maxColor`, `colorRange`, `colorDomain`];\n\nconst defaultProps = {\n  cellSizePixels: {value: 100, min: 1},\n  cellMarginPixels: {value: 2, min: 0, max: 5},\n\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\nexport default class ScreenGridCellLayer extends Layer {\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  getShaders() {\n    return {vs, fs, modules: [picking]};\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {size: 3, update: this.calculateInstancePositions},\n      instanceCounts: {size: 4, noAlloc: true}\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    // 'instanceCounts' buffer contetns change on viewport change.\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({oldProps, props, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw({uniforms}) {\n    const {parameters, maxTexture} = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n\n    // If colorDomain not specified we use default domain [1, maxCount]\n    // maxCount value will be sampled form maxTexture in vertex shader.\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {model} = this.state;\n    const layerUniforms = {\n      minColor,\n      maxColor,\n      maxTexture,\n      colorDomain\n    };\n\n    uniforms = Object.assign(layerUniforms, uniforms);\n    model.draw({\n      uniforms,\n      parameters: Object.assign(\n        {\n          depthTest: false,\n          depthMask: false\n        },\n        parameters\n      )\n    });\n  }\n\n  calculateInstancePositions(attribute, {numInstances}) {\n    const {width, height} = this.context.viewport;\n    const {cellSizePixels} = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n\n    const {value, size} = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = ((x * cellSizePixels) / width) * 2 - 1;\n      value[i * size + 1] = 1 - ((y * cellSizePixels) / height) * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  // Private Methods\n\n  _getModel(gl) {\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLE_FAN,\n          attributes: {\n            positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n          }\n        }),\n        isInstanced: true\n      })\n    );\n  }\n\n  _shouldUseMinMax() {\n    const {minColor, maxColor, colorDomain, colorRange} = this.props;\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n    // minColor and maxColor not supplied, check if colorRange or colorDomain supplied.\n    // NOTE: colorDomain and colorRange are experimental features, use them only when supplied.\n    if (colorDomain || colorRange) {\n      return false;\n    }\n    // None specified, use default minColor and maxColor\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags) {\n    const {model} = this.state;\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({shouldUseMinMax: this._shouldUseMinMax()});\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({colorRange: colorRangeToFlatArray(props.colorRange)});\n    }\n\n    if (\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\n      oldProps.cellSizePixels !== props.cellSizePixels ||\n      changeFlags.viewportChanged\n    ) {\n      const {width, height} = this.context.viewport;\n      const {cellSizePixels, cellMarginPixels} = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n\n      const cellScale = new Float32Array([\n        ((cellSizePixels - margin) / width) * 2,\n        (-(cellSizePixels - margin) / height) * 2,\n        1\n      ]);\n      model.setUniforms({cellScale});\n    }\n  }\n}\n\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}